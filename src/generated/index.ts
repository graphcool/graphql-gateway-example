// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.
import { GraphQLResolveInfo, GraphQLSchema } from "graphql";
import { IResolvers } from "graphql-tools/dist/Interfaces";
import { makePrismaBindingClass, BasePrismaOptions, Options } from "prisma-lib";
import { typeDefs } from "./graphql";

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  user: (where?: UserWhereInput) => Promise<boolean>;
  place: (where?: PlaceWhereInput) => Promise<boolean>;
  pricing: (where?: PricingWhereInput) => Promise<boolean>;
  guestRequirements: (where?: GuestRequirementsWhereInput) => Promise<boolean>;
  policies: (where?: PoliciesWhereInput) => Promise<boolean>;
  houseRules: (where?: HouseRulesWhereInput) => Promise<boolean>;
  views: (where?: ViewsWhereInput) => Promise<boolean>;
  location: (where?: LocationWhereInput) => Promise<boolean>;
  neighbourhood: (where?: NeighbourhoodWhereInput) => Promise<boolean>;
  city: (where?: CityWhereInput) => Promise<boolean>;
  picture: (where?: PictureWhereInput) => Promise<boolean>;
  experience: (where?: ExperienceWhereInput) => Promise<boolean>;
  experienceCategory: (
    where?: ExperienceCategoryWhereInput
  ) => Promise<boolean>;
  amenities: (where?: AmenitiesWhereInput) => Promise<boolean>;
  review: (where?: ReviewWhereInput) => Promise<boolean>;
  booking: (where?: BookingWhereInput) => Promise<boolean>;
  payment: (where?: PaymentWhereInput) => Promise<boolean>;
  paymentAccount: (where?: PaymentAccountWhereInput) => Promise<boolean>;
  paypalInformation: (where?: PaypalInformationWhereInput) => Promise<boolean>;
  creditCardInformation: (
    where?: CreditCardInformationWhereInput
  ) => Promise<boolean>;
  message: (where?: MessageWhereInput) => Promise<boolean>;
  notification: (where?: NotificationWhereInput) => Promise<boolean>;
  restaurant: (where?: RestaurantWhereInput) => Promise<boolean>;
}

export interface Node {}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;
  $delegate: Delegate;
  $getAbstractResolvers(filterSchema?: GraphQLSchema | string): IResolvers;

  /**
   * Queries
   */

  user: <T = User>(
    where: UserWhereUniqueInput,
    fragment?: string | object
  ) => T;
  users: <T = Promise<Array<UserNode>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  usersConnection: <T = UserConnection>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  place: <T = Place>(
    where: PlaceWhereUniqueInput,
    fragment?: string | object
  ) => T;
  places: <T = Promise<Array<PlaceNode>>>(
    args?: {
      where?: PlaceWhereInput;
      orderBy?: PlaceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  placesConnection: <T = PlaceConnection>(
    args?: {
      where?: PlaceWhereInput;
      orderBy?: PlaceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  pricing: <T = Pricing>(
    where: PricingWhereUniqueInput,
    fragment?: string | object
  ) => T;
  pricings: <T = Promise<Array<PricingNode>>>(
    args?: {
      where?: PricingWhereInput;
      orderBy?: PricingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  pricingsConnection: <T = PricingConnection>(
    args?: {
      where?: PricingWhereInput;
      orderBy?: PricingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  guestRequirements: <T = GuestRequirements>(
    where: GuestRequirementsWhereUniqueInput,
    fragment?: string | object
  ) => T;
  guestRequirementses: <T = Promise<Array<GuestRequirementsNode>>>(
    args?: {
      where?: GuestRequirementsWhereInput;
      orderBy?: GuestRequirementsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  guestRequirementsesConnection: <T = GuestRequirementsConnection>(
    args?: {
      where?: GuestRequirementsWhereInput;
      orderBy?: GuestRequirementsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  policies: <T = Policies>(
    where: PoliciesWhereUniqueInput,
    fragment?: string | object
  ) => T;
  policieses: <T = Promise<Array<PoliciesNode>>>(
    args?: {
      where?: PoliciesWhereInput;
      orderBy?: PoliciesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  policiesesConnection: <T = PoliciesConnection>(
    args?: {
      where?: PoliciesWhereInput;
      orderBy?: PoliciesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  houseRules: <T = HouseRules>(
    where: HouseRulesWhereUniqueInput,
    fragment?: string | object
  ) => T;
  houseRuleses: <T = Promise<Array<HouseRulesNode>>>(
    args?: {
      where?: HouseRulesWhereInput;
      orderBy?: HouseRulesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  houseRulesesConnection: <T = HouseRulesConnection>(
    args?: {
      where?: HouseRulesWhereInput;
      orderBy?: HouseRulesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  views: <T = Views>(
    where: ViewsWhereUniqueInput,
    fragment?: string | object
  ) => T;
  viewses: <T = Promise<Array<ViewsNode>>>(
    args?: {
      where?: ViewsWhereInput;
      orderBy?: ViewsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  viewsesConnection: <T = ViewsConnection>(
    args?: {
      where?: ViewsWhereInput;
      orderBy?: ViewsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  location: <T = Location>(
    where: LocationWhereUniqueInput,
    fragment?: string | object
  ) => T;
  locations: <T = Promise<Array<LocationNode>>>(
    args?: {
      where?: LocationWhereInput;
      orderBy?: LocationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  locationsConnection: <T = LocationConnection>(
    args?: {
      where?: LocationWhereInput;
      orderBy?: LocationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  neighbourhood: <T = Neighbourhood>(
    where: NeighbourhoodWhereUniqueInput,
    fragment?: string | object
  ) => T;
  neighbourhoods: <T = Promise<Array<NeighbourhoodNode>>>(
    args?: {
      where?: NeighbourhoodWhereInput;
      orderBy?: NeighbourhoodOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  neighbourhoodsConnection: <T = NeighbourhoodConnection>(
    args?: {
      where?: NeighbourhoodWhereInput;
      orderBy?: NeighbourhoodOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  city: <T = City>(
    where: CityWhereUniqueInput,
    fragment?: string | object
  ) => T;
  cities: <T = Promise<Array<CityNode>>>(
    args?: {
      where?: CityWhereInput;
      orderBy?: CityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  citiesConnection: <T = CityConnection>(
    args?: {
      where?: CityWhereInput;
      orderBy?: CityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  picture: <T = Picture>(
    where: PictureWhereUniqueInput,
    fragment?: string | object
  ) => T;
  pictures: <T = Promise<Array<PictureNode>>>(
    args?: {
      where?: PictureWhereInput;
      orderBy?: PictureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  picturesConnection: <T = PictureConnection>(
    args?: {
      where?: PictureWhereInput;
      orderBy?: PictureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  experience: <T = Experience>(
    where: ExperienceWhereUniqueInput,
    fragment?: string | object
  ) => T;
  experiences: <T = Promise<Array<ExperienceNode>>>(
    args?: {
      where?: ExperienceWhereInput;
      orderBy?: ExperienceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  experiencesConnection: <T = ExperienceConnection>(
    args?: {
      where?: ExperienceWhereInput;
      orderBy?: ExperienceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  experienceCategory: <T = ExperienceCategory>(
    where: ExperienceCategoryWhereUniqueInput,
    fragment?: string | object
  ) => T;
  experienceCategories: <T = Promise<Array<ExperienceCategoryNode>>>(
    args?: {
      where?: ExperienceCategoryWhereInput;
      orderBy?: ExperienceCategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  experienceCategoriesConnection: <T = ExperienceCategoryConnection>(
    args?: {
      where?: ExperienceCategoryWhereInput;
      orderBy?: ExperienceCategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  amenities: <T = Amenities>(
    where: AmenitiesWhereUniqueInput,
    fragment?: string | object
  ) => T;
  amenitieses: <T = Promise<Array<AmenitiesNode>>>(
    args?: {
      where?: AmenitiesWhereInput;
      orderBy?: AmenitiesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  amenitiesesConnection: <T = AmenitiesConnection>(
    args?: {
      where?: AmenitiesWhereInput;
      orderBy?: AmenitiesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  review: <T = Review>(
    where: ReviewWhereUniqueInput,
    fragment?: string | object
  ) => T;
  reviews: <T = Promise<Array<ReviewNode>>>(
    args?: {
      where?: ReviewWhereInput;
      orderBy?: ReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  reviewsConnection: <T = ReviewConnection>(
    args?: {
      where?: ReviewWhereInput;
      orderBy?: ReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  booking: <T = Booking>(
    where: BookingWhereUniqueInput,
    fragment?: string | object
  ) => T;
  bookings: <T = Promise<Array<BookingNode>>>(
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  bookingsConnection: <T = BookingConnection>(
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  payment: <T = Payment>(
    where: PaymentWhereUniqueInput,
    fragment?: string | object
  ) => T;
  payments: <T = Promise<Array<PaymentNode>>>(
    args?: {
      where?: PaymentWhereInput;
      orderBy?: PaymentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  paymentsConnection: <T = PaymentConnection>(
    args?: {
      where?: PaymentWhereInput;
      orderBy?: PaymentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  paymentAccount: <T = PaymentAccount>(
    where: PaymentAccountWhereUniqueInput,
    fragment?: string | object
  ) => T;
  paymentAccounts: <T = Promise<Array<PaymentAccountNode>>>(
    args?: {
      where?: PaymentAccountWhereInput;
      orderBy?: PaymentAccountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  paymentAccountsConnection: <T = PaymentAccountConnection>(
    args?: {
      where?: PaymentAccountWhereInput;
      orderBy?: PaymentAccountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  paypalInformation: <T = PaypalInformation>(
    where: PaypalInformationWhereUniqueInput,
    fragment?: string | object
  ) => T;
  paypalInformations: <T = Promise<Array<PaypalInformationNode>>>(
    args?: {
      where?: PaypalInformationWhereInput;
      orderBy?: PaypalInformationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  paypalInformationsConnection: <T = PaypalInformationConnection>(
    args?: {
      where?: PaypalInformationWhereInput;
      orderBy?: PaypalInformationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  creditCardInformation: <T = CreditCardInformation>(
    where: CreditCardInformationWhereUniqueInput,
    fragment?: string | object
  ) => T;
  creditCardInformations: <T = Promise<Array<CreditCardInformationNode>>>(
    args?: {
      where?: CreditCardInformationWhereInput;
      orderBy?: CreditCardInformationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  creditCardInformationsConnection: <T = CreditCardInformationConnection>(
    args?: {
      where?: CreditCardInformationWhereInput;
      orderBy?: CreditCardInformationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  message: <T = Message>(
    where: MessageWhereUniqueInput,
    fragment?: string | object
  ) => T;
  messages: <T = Promise<Array<MessageNode>>>(
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  messagesConnection: <T = MessageConnection>(
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  notification: <T = Notification>(
    where: NotificationWhereUniqueInput,
    fragment?: string | object
  ) => T;
  notifications: <T = Promise<Array<NotificationNode>>>(
    args?: {
      where?: NotificationWhereInput;
      orderBy?: NotificationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  notificationsConnection: <T = NotificationConnection>(
    args?: {
      where?: NotificationWhereInput;
      orderBy?: NotificationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  restaurant: <T = Restaurant>(
    where: RestaurantWhereUniqueInput,
    fragment?: string | object
  ) => T;
  restaurants: <T = Promise<Array<RestaurantNode>>>(
    args?: {
      where?: RestaurantWhereInput;
      orderBy?: RestaurantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  restaurantsConnection: <T = RestaurantConnection>(
    args?: {
      where?: RestaurantWhereInput;
      orderBy?: RestaurantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  node: <T = Node>(args: { id: ID_Output }, fragment?: string | object) => T;

  /**
   * Mutations
   */

  createUser: <T = User>(
    data: UserCreateInput,
    fragment?: string | object
  ) => T;
  updateUser: <T = User>(
    args: { data: UserUpdateInput; where: UserWhereUniqueInput },
    fragment?: string | object
  ) => T;
  updateManyUsers: <T = BatchPayload>(
    args: { data: UserUpdateInput; where?: UserWhereInput },
    fragment?: string | object
  ) => T;
  upsertUser: <T = User>(
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    },
    fragment?: string | object
  ) => T;
  deleteUser: <T = User>(
    where: UserWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyUsers: <T = BatchPayload>(
    where?: UserWhereInput,
    fragment?: string | object
  ) => T;
  createPlace: <T = Place>(
    data: PlaceCreateInput,
    fragment?: string | object
  ) => T;
  updatePlace: <T = Place>(
    args: { data: PlaceUpdateInput; where: PlaceWhereUniqueInput },
    fragment?: string | object
  ) => T;
  updateManyPlaces: <T = BatchPayload>(
    args: { data: PlaceUpdateInput; where?: PlaceWhereInput },
    fragment?: string | object
  ) => T;
  upsertPlace: <T = Place>(
    args: {
      where: PlaceWhereUniqueInput;
      create: PlaceCreateInput;
      update: PlaceUpdateInput;
    },
    fragment?: string | object
  ) => T;
  deletePlace: <T = Place>(
    where: PlaceWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyPlaces: <T = BatchPayload>(
    where?: PlaceWhereInput,
    fragment?: string | object
  ) => T;
  createPricing: <T = Pricing>(
    data: PricingCreateInput,
    fragment?: string | object
  ) => T;
  updatePricing: <T = Pricing>(
    args: { data: PricingUpdateInput; where: PricingWhereUniqueInput },
    fragment?: string | object
  ) => T;
  updateManyPricings: <T = BatchPayload>(
    args: { data: PricingUpdateInput; where?: PricingWhereInput },
    fragment?: string | object
  ) => T;
  upsertPricing: <T = Pricing>(
    args: {
      where: PricingWhereUniqueInput;
      create: PricingCreateInput;
      update: PricingUpdateInput;
    },
    fragment?: string | object
  ) => T;
  deletePricing: <T = Pricing>(
    where: PricingWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyPricings: <T = BatchPayload>(
    where?: PricingWhereInput,
    fragment?: string | object
  ) => T;
  createGuestRequirements: <T = GuestRequirements>(
    data: GuestRequirementsCreateInput,
    fragment?: string | object
  ) => T;
  updateGuestRequirements: <T = GuestRequirements>(
    args: {
      data: GuestRequirementsUpdateInput;
      where: GuestRequirementsWhereUniqueInput;
    },
    fragment?: string | object
  ) => T;
  updateManyGuestRequirementses: <T = BatchPayload>(
    args: {
      data: GuestRequirementsUpdateInput;
      where?: GuestRequirementsWhereInput;
    },
    fragment?: string | object
  ) => T;
  upsertGuestRequirements: <T = GuestRequirements>(
    args: {
      where: GuestRequirementsWhereUniqueInput;
      create: GuestRequirementsCreateInput;
      update: GuestRequirementsUpdateInput;
    },
    fragment?: string | object
  ) => T;
  deleteGuestRequirements: <T = GuestRequirements>(
    where: GuestRequirementsWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyGuestRequirementses: <T = BatchPayload>(
    where?: GuestRequirementsWhereInput,
    fragment?: string | object
  ) => T;
  createPolicies: <T = Policies>(
    data: PoliciesCreateInput,
    fragment?: string | object
  ) => T;
  updatePolicies: <T = Policies>(
    args: { data: PoliciesUpdateInput; where: PoliciesWhereUniqueInput },
    fragment?: string | object
  ) => T;
  updateManyPolicieses: <T = BatchPayload>(
    args: { data: PoliciesUpdateInput; where?: PoliciesWhereInput },
    fragment?: string | object
  ) => T;
  upsertPolicies: <T = Policies>(
    args: {
      where: PoliciesWhereUniqueInput;
      create: PoliciesCreateInput;
      update: PoliciesUpdateInput;
    },
    fragment?: string | object
  ) => T;
  deletePolicies: <T = Policies>(
    where: PoliciesWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyPolicieses: <T = BatchPayload>(
    where?: PoliciesWhereInput,
    fragment?: string | object
  ) => T;
  createHouseRules: <T = HouseRules>(
    data: HouseRulesCreateInput,
    fragment?: string | object
  ) => T;
  updateHouseRules: <T = HouseRules>(
    args: { data: HouseRulesUpdateInput; where: HouseRulesWhereUniqueInput },
    fragment?: string | object
  ) => T;
  updateManyHouseRuleses: <T = BatchPayload>(
    args: { data: HouseRulesUpdateInput; where?: HouseRulesWhereInput },
    fragment?: string | object
  ) => T;
  upsertHouseRules: <T = HouseRules>(
    args: {
      where: HouseRulesWhereUniqueInput;
      create: HouseRulesCreateInput;
      update: HouseRulesUpdateInput;
    },
    fragment?: string | object
  ) => T;
  deleteHouseRules: <T = HouseRules>(
    where: HouseRulesWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyHouseRuleses: <T = BatchPayload>(
    where?: HouseRulesWhereInput,
    fragment?: string | object
  ) => T;
  createViews: <T = Views>(
    data: ViewsCreateInput,
    fragment?: string | object
  ) => T;
  updateViews: <T = Views>(
    args: { data: ViewsUpdateInput; where: ViewsWhereUniqueInput },
    fragment?: string | object
  ) => T;
  updateManyViewses: <T = BatchPayload>(
    args: { data: ViewsUpdateInput; where?: ViewsWhereInput },
    fragment?: string | object
  ) => T;
  upsertViews: <T = Views>(
    args: {
      where: ViewsWhereUniqueInput;
      create: ViewsCreateInput;
      update: ViewsUpdateInput;
    },
    fragment?: string | object
  ) => T;
  deleteViews: <T = Views>(
    where: ViewsWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyViewses: <T = BatchPayload>(
    where?: ViewsWhereInput,
    fragment?: string | object
  ) => T;
  createLocation: <T = Location>(
    data: LocationCreateInput,
    fragment?: string | object
  ) => T;
  updateLocation: <T = Location>(
    args: { data: LocationUpdateInput; where: LocationWhereUniqueInput },
    fragment?: string | object
  ) => T;
  updateManyLocations: <T = BatchPayload>(
    args: { data: LocationUpdateInput; where?: LocationWhereInput },
    fragment?: string | object
  ) => T;
  upsertLocation: <T = Location>(
    args: {
      where: LocationWhereUniqueInput;
      create: LocationCreateInput;
      update: LocationUpdateInput;
    },
    fragment?: string | object
  ) => T;
  deleteLocation: <T = Location>(
    where: LocationWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyLocations: <T = BatchPayload>(
    where?: LocationWhereInput,
    fragment?: string | object
  ) => T;
  createNeighbourhood: <T = Neighbourhood>(
    data: NeighbourhoodCreateInput,
    fragment?: string | object
  ) => T;
  updateNeighbourhood: <T = Neighbourhood>(
    args: {
      data: NeighbourhoodUpdateInput;
      where: NeighbourhoodWhereUniqueInput;
    },
    fragment?: string | object
  ) => T;
  updateManyNeighbourhoods: <T = BatchPayload>(
    args: { data: NeighbourhoodUpdateInput; where?: NeighbourhoodWhereInput },
    fragment?: string | object
  ) => T;
  upsertNeighbourhood: <T = Neighbourhood>(
    args: {
      where: NeighbourhoodWhereUniqueInput;
      create: NeighbourhoodCreateInput;
      update: NeighbourhoodUpdateInput;
    },
    fragment?: string | object
  ) => T;
  deleteNeighbourhood: <T = Neighbourhood>(
    where: NeighbourhoodWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyNeighbourhoods: <T = BatchPayload>(
    where?: NeighbourhoodWhereInput,
    fragment?: string | object
  ) => T;
  createCity: <T = City>(
    data: CityCreateInput,
    fragment?: string | object
  ) => T;
  updateCity: <T = City>(
    args: { data: CityUpdateInput; where: CityWhereUniqueInput },
    fragment?: string | object
  ) => T;
  updateManyCities: <T = BatchPayload>(
    args: { data: CityUpdateInput; where?: CityWhereInput },
    fragment?: string | object
  ) => T;
  upsertCity: <T = City>(
    args: {
      where: CityWhereUniqueInput;
      create: CityCreateInput;
      update: CityUpdateInput;
    },
    fragment?: string | object
  ) => T;
  deleteCity: <T = City>(
    where: CityWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyCities: <T = BatchPayload>(
    where?: CityWhereInput,
    fragment?: string | object
  ) => T;
  createPicture: <T = Picture>(
    data: PictureCreateInput,
    fragment?: string | object
  ) => T;
  updatePicture: <T = Picture>(
    args: { data: PictureUpdateInput; where: PictureWhereUniqueInput },
    fragment?: string | object
  ) => T;
  updateManyPictures: <T = BatchPayload>(
    args: { data: PictureUpdateInput; where?: PictureWhereInput },
    fragment?: string | object
  ) => T;
  upsertPicture: <T = Picture>(
    args: {
      where: PictureWhereUniqueInput;
      create: PictureCreateInput;
      update: PictureUpdateInput;
    },
    fragment?: string | object
  ) => T;
  deletePicture: <T = Picture>(
    where: PictureWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyPictures: <T = BatchPayload>(
    where?: PictureWhereInput,
    fragment?: string | object
  ) => T;
  createExperience: <T = Experience>(
    data: ExperienceCreateInput,
    fragment?: string | object
  ) => T;
  updateExperience: <T = Experience>(
    args: { data: ExperienceUpdateInput; where: ExperienceWhereUniqueInput },
    fragment?: string | object
  ) => T;
  updateManyExperiences: <T = BatchPayload>(
    args: { data: ExperienceUpdateInput; where?: ExperienceWhereInput },
    fragment?: string | object
  ) => T;
  upsertExperience: <T = Experience>(
    args: {
      where: ExperienceWhereUniqueInput;
      create: ExperienceCreateInput;
      update: ExperienceUpdateInput;
    },
    fragment?: string | object
  ) => T;
  deleteExperience: <T = Experience>(
    where: ExperienceWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyExperiences: <T = BatchPayload>(
    where?: ExperienceWhereInput,
    fragment?: string | object
  ) => T;
  createExperienceCategory: <T = ExperienceCategory>(
    data: ExperienceCategoryCreateInput,
    fragment?: string | object
  ) => T;
  updateExperienceCategory: <T = ExperienceCategory>(
    args: {
      data: ExperienceCategoryUpdateInput;
      where: ExperienceCategoryWhereUniqueInput;
    },
    fragment?: string | object
  ) => T;
  updateManyExperienceCategories: <T = BatchPayload>(
    args: {
      data: ExperienceCategoryUpdateInput;
      where?: ExperienceCategoryWhereInput;
    },
    fragment?: string | object
  ) => T;
  upsertExperienceCategory: <T = ExperienceCategory>(
    args: {
      where: ExperienceCategoryWhereUniqueInput;
      create: ExperienceCategoryCreateInput;
      update: ExperienceCategoryUpdateInput;
    },
    fragment?: string | object
  ) => T;
  deleteExperienceCategory: <T = ExperienceCategory>(
    where: ExperienceCategoryWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyExperienceCategories: <T = BatchPayload>(
    where?: ExperienceCategoryWhereInput,
    fragment?: string | object
  ) => T;
  createAmenities: <T = Amenities>(
    data: AmenitiesCreateInput,
    fragment?: string | object
  ) => T;
  updateAmenities: <T = Amenities>(
    args: { data: AmenitiesUpdateInput; where: AmenitiesWhereUniqueInput },
    fragment?: string | object
  ) => T;
  updateManyAmenitieses: <T = BatchPayload>(
    args: { data: AmenitiesUpdateInput; where?: AmenitiesWhereInput },
    fragment?: string | object
  ) => T;
  upsertAmenities: <T = Amenities>(
    args: {
      where: AmenitiesWhereUniqueInput;
      create: AmenitiesCreateInput;
      update: AmenitiesUpdateInput;
    },
    fragment?: string | object
  ) => T;
  deleteAmenities: <T = Amenities>(
    where: AmenitiesWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyAmenitieses: <T = BatchPayload>(
    where?: AmenitiesWhereInput,
    fragment?: string | object
  ) => T;
  createReview: <T = Review>(
    data: ReviewCreateInput,
    fragment?: string | object
  ) => T;
  updateReview: <T = Review>(
    args: { data: ReviewUpdateInput; where: ReviewWhereUniqueInput },
    fragment?: string | object
  ) => T;
  updateManyReviews: <T = BatchPayload>(
    args: { data: ReviewUpdateInput; where?: ReviewWhereInput },
    fragment?: string | object
  ) => T;
  upsertReview: <T = Review>(
    args: {
      where: ReviewWhereUniqueInput;
      create: ReviewCreateInput;
      update: ReviewUpdateInput;
    },
    fragment?: string | object
  ) => T;
  deleteReview: <T = Review>(
    where: ReviewWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyReviews: <T = BatchPayload>(
    where?: ReviewWhereInput,
    fragment?: string | object
  ) => T;
  createBooking: <T = Booking>(
    data: BookingCreateInput,
    fragment?: string | object
  ) => T;
  updateBooking: <T = Booking>(
    args: { data: BookingUpdateInput; where: BookingWhereUniqueInput },
    fragment?: string | object
  ) => T;
  updateManyBookings: <T = BatchPayload>(
    args: { data: BookingUpdateInput; where?: BookingWhereInput },
    fragment?: string | object
  ) => T;
  upsertBooking: <T = Booking>(
    args: {
      where: BookingWhereUniqueInput;
      create: BookingCreateInput;
      update: BookingUpdateInput;
    },
    fragment?: string | object
  ) => T;
  deleteBooking: <T = Booking>(
    where: BookingWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyBookings: <T = BatchPayload>(
    where?: BookingWhereInput,
    fragment?: string | object
  ) => T;
  createPayment: <T = Payment>(
    data: PaymentCreateInput,
    fragment?: string | object
  ) => T;
  updatePayment: <T = Payment>(
    args: { data: PaymentUpdateInput; where: PaymentWhereUniqueInput },
    fragment?: string | object
  ) => T;
  updateManyPayments: <T = BatchPayload>(
    args: { data: PaymentUpdateInput; where?: PaymentWhereInput },
    fragment?: string | object
  ) => T;
  upsertPayment: <T = Payment>(
    args: {
      where: PaymentWhereUniqueInput;
      create: PaymentCreateInput;
      update: PaymentUpdateInput;
    },
    fragment?: string | object
  ) => T;
  deletePayment: <T = Payment>(
    where: PaymentWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyPayments: <T = BatchPayload>(
    where?: PaymentWhereInput,
    fragment?: string | object
  ) => T;
  createPaymentAccount: <T = PaymentAccount>(
    data: PaymentAccountCreateInput,
    fragment?: string | object
  ) => T;
  updatePaymentAccount: <T = PaymentAccount>(
    args: {
      data: PaymentAccountUpdateInput;
      where: PaymentAccountWhereUniqueInput;
    },
    fragment?: string | object
  ) => T;
  updateManyPaymentAccounts: <T = BatchPayload>(
    args: { data: PaymentAccountUpdateInput; where?: PaymentAccountWhereInput },
    fragment?: string | object
  ) => T;
  upsertPaymentAccount: <T = PaymentAccount>(
    args: {
      where: PaymentAccountWhereUniqueInput;
      create: PaymentAccountCreateInput;
      update: PaymentAccountUpdateInput;
    },
    fragment?: string | object
  ) => T;
  deletePaymentAccount: <T = PaymentAccount>(
    where: PaymentAccountWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyPaymentAccounts: <T = BatchPayload>(
    where?: PaymentAccountWhereInput,
    fragment?: string | object
  ) => T;
  createPaypalInformation: <T = PaypalInformation>(
    data: PaypalInformationCreateInput,
    fragment?: string | object
  ) => T;
  updatePaypalInformation: <T = PaypalInformation>(
    args: {
      data: PaypalInformationUpdateInput;
      where: PaypalInformationWhereUniqueInput;
    },
    fragment?: string | object
  ) => T;
  updateManyPaypalInformations: <T = BatchPayload>(
    args: {
      data: PaypalInformationUpdateInput;
      where?: PaypalInformationWhereInput;
    },
    fragment?: string | object
  ) => T;
  upsertPaypalInformation: <T = PaypalInformation>(
    args: {
      where: PaypalInformationWhereUniqueInput;
      create: PaypalInformationCreateInput;
      update: PaypalInformationUpdateInput;
    },
    fragment?: string | object
  ) => T;
  deletePaypalInformation: <T = PaypalInformation>(
    where: PaypalInformationWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyPaypalInformations: <T = BatchPayload>(
    where?: PaypalInformationWhereInput,
    fragment?: string | object
  ) => T;
  createCreditCardInformation: <T = CreditCardInformation>(
    data: CreditCardInformationCreateInput,
    fragment?: string | object
  ) => T;
  updateCreditCardInformation: <T = CreditCardInformation>(
    args: {
      data: CreditCardInformationUpdateInput;
      where: CreditCardInformationWhereUniqueInput;
    },
    fragment?: string | object
  ) => T;
  updateManyCreditCardInformations: <T = BatchPayload>(
    args: {
      data: CreditCardInformationUpdateInput;
      where?: CreditCardInformationWhereInput;
    },
    fragment?: string | object
  ) => T;
  upsertCreditCardInformation: <T = CreditCardInformation>(
    args: {
      where: CreditCardInformationWhereUniqueInput;
      create: CreditCardInformationCreateInput;
      update: CreditCardInformationUpdateInput;
    },
    fragment?: string | object
  ) => T;
  deleteCreditCardInformation: <T = CreditCardInformation>(
    where: CreditCardInformationWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyCreditCardInformations: <T = BatchPayload>(
    where?: CreditCardInformationWhereInput,
    fragment?: string | object
  ) => T;
  createMessage: <T = Message>(
    data: MessageCreateInput,
    fragment?: string | object
  ) => T;
  updateMessage: <T = Message>(
    args: { data: MessageUpdateInput; where: MessageWhereUniqueInput },
    fragment?: string | object
  ) => T;
  updateManyMessages: <T = BatchPayload>(
    args: { data: MessageUpdateInput; where?: MessageWhereInput },
    fragment?: string | object
  ) => T;
  upsertMessage: <T = Message>(
    args: {
      where: MessageWhereUniqueInput;
      create: MessageCreateInput;
      update: MessageUpdateInput;
    },
    fragment?: string | object
  ) => T;
  deleteMessage: <T = Message>(
    where: MessageWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyMessages: <T = BatchPayload>(
    where?: MessageWhereInput,
    fragment?: string | object
  ) => T;
  createNotification: <T = Notification>(
    data: NotificationCreateInput,
    fragment?: string | object
  ) => T;
  updateNotification: <T = Notification>(
    args: {
      data: NotificationUpdateInput;
      where: NotificationWhereUniqueInput;
    },
    fragment?: string | object
  ) => T;
  updateManyNotifications: <T = BatchPayload>(
    args: { data: NotificationUpdateInput; where?: NotificationWhereInput },
    fragment?: string | object
  ) => T;
  upsertNotification: <T = Notification>(
    args: {
      where: NotificationWhereUniqueInput;
      create: NotificationCreateInput;
      update: NotificationUpdateInput;
    },
    fragment?: string | object
  ) => T;
  deleteNotification: <T = Notification>(
    where: NotificationWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyNotifications: <T = BatchPayload>(
    where?: NotificationWhereInput,
    fragment?: string | object
  ) => T;
  createRestaurant: <T = Restaurant>(
    data: RestaurantCreateInput,
    fragment?: string | object
  ) => T;
  updateRestaurant: <T = Restaurant>(
    args: { data: RestaurantUpdateInput; where: RestaurantWhereUniqueInput },
    fragment?: string | object
  ) => T;
  updateManyRestaurants: <T = BatchPayload>(
    args: { data: RestaurantUpdateInput; where?: RestaurantWhereInput },
    fragment?: string | object
  ) => T;
  upsertRestaurant: <T = Restaurant>(
    args: {
      where: RestaurantWhereUniqueInput;
      create: RestaurantCreateInput;
      update: RestaurantUpdateInput;
    },
    fragment?: string | object
  ) => T;
  deleteRestaurant: <T = Restaurant>(
    where: RestaurantWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyRestaurants: <T = BatchPayload>(
    where?: RestaurantWhereInput,
    fragment?: string | object
  ) => T;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  user: <T = UserSubscriptionPayloadSubscription>(
    where?: UserSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  place: <T = PlaceSubscriptionPayloadSubscription>(
    where?: PlaceSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  pricing: <T = PricingSubscriptionPayloadSubscription>(
    where?: PricingSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  guestRequirements: <T = GuestRequirementsSubscriptionPayloadSubscription>(
    where?: GuestRequirementsSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  policies: <T = PoliciesSubscriptionPayloadSubscription>(
    where?: PoliciesSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  houseRules: <T = HouseRulesSubscriptionPayloadSubscription>(
    where?: HouseRulesSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  views: <T = ViewsSubscriptionPayloadSubscription>(
    where?: ViewsSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  location: <T = LocationSubscriptionPayloadSubscription>(
    where?: LocationSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  neighbourhood: <T = NeighbourhoodSubscriptionPayloadSubscription>(
    where?: NeighbourhoodSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  city: <T = CitySubscriptionPayloadSubscription>(
    where?: CitySubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  picture: <T = PictureSubscriptionPayloadSubscription>(
    where?: PictureSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  experience: <T = ExperienceSubscriptionPayloadSubscription>(
    where?: ExperienceSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  experienceCategory: <T = ExperienceCategorySubscriptionPayloadSubscription>(
    where?: ExperienceCategorySubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  amenities: <T = AmenitiesSubscriptionPayloadSubscription>(
    where?: AmenitiesSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  review: <T = ReviewSubscriptionPayloadSubscription>(
    where?: ReviewSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  booking: <T = BookingSubscriptionPayloadSubscription>(
    where?: BookingSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  payment: <T = PaymentSubscriptionPayloadSubscription>(
    where?: PaymentSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  paymentAccount: <T = PaymentAccountSubscriptionPayloadSubscription>(
    where?: PaymentAccountSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  paypalInformation: <T = PaypalInformationSubscriptionPayloadSubscription>(
    where?: PaypalInformationSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  creditCardInformation: <
    T = CreditCardInformationSubscriptionPayloadSubscription
  >(
    where?: CreditCardInformationSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  message: <T = MessageSubscriptionPayloadSubscription>(
    where?: MessageSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  notification: <T = NotificationSubscriptionPayloadSubscription>(
    where?: NotificationSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  restaurant: <T = RestaurantSubscriptionPayloadSubscription>(
    where?: RestaurantSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
}

export interface Delegate {
  (
    operation: "query" | "mutation",
    fieldName: string,
    args: {
      [key: string]: any;
    },
    infoOrQuery?: GraphQLResolveInfo,
    options?: Options
  ): Promise<any>;
  query: DelegateQuery;
  mutation: DelegateMutation;
  subscription: DelegateSubscription;
}

export interface DelegateQuery {
  user: <T = Promise<Partial<UserNode | null>>>(
    where: UserWhereUniqueInput,
    fragment?: string | object
  ) => T;
  users: <T = Promise<Array<UserNode>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  usersConnection: <T = Promise<Partial<UserConnectionNode>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  place: <T = Promise<Partial<PlaceNode | null>>>(
    where: PlaceWhereUniqueInput,
    fragment?: string | object
  ) => T;
  places: <T = Promise<Array<PlaceNode>>>(
    args?: {
      where?: PlaceWhereInput;
      orderBy?: PlaceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  placesConnection: <T = Promise<Partial<PlaceConnectionNode>>>(
    args?: {
      where?: PlaceWhereInput;
      orderBy?: PlaceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  pricing: <T = Promise<Partial<PricingNode | null>>>(
    where: PricingWhereUniqueInput,
    fragment?: string | object
  ) => T;
  pricings: <T = Promise<Array<PricingNode>>>(
    args?: {
      where?: PricingWhereInput;
      orderBy?: PricingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  pricingsConnection: <T = Promise<Partial<PricingConnectionNode>>>(
    args?: {
      where?: PricingWhereInput;
      orderBy?: PricingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  guestRequirements: <T = Promise<Partial<GuestRequirementsNode | null>>>(
    where: GuestRequirementsWhereUniqueInput,
    fragment?: string | object
  ) => T;
  guestRequirementses: <T = Promise<Array<GuestRequirementsNode>>>(
    args?: {
      where?: GuestRequirementsWhereInput;
      orderBy?: GuestRequirementsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  guestRequirementsesConnection: <
    T = Promise<Partial<GuestRequirementsConnectionNode>>
  >(
    args?: {
      where?: GuestRequirementsWhereInput;
      orderBy?: GuestRequirementsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  policies: <T = Promise<Partial<PoliciesNode | null>>>(
    where: PoliciesWhereUniqueInput,
    fragment?: string | object
  ) => T;
  policieses: <T = Promise<Array<PoliciesNode>>>(
    args?: {
      where?: PoliciesWhereInput;
      orderBy?: PoliciesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  policiesesConnection: <T = Promise<Partial<PoliciesConnectionNode>>>(
    args?: {
      where?: PoliciesWhereInput;
      orderBy?: PoliciesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  houseRules: <T = Promise<Partial<HouseRulesNode | null>>>(
    where: HouseRulesWhereUniqueInput,
    fragment?: string | object
  ) => T;
  houseRuleses: <T = Promise<Array<HouseRulesNode>>>(
    args?: {
      where?: HouseRulesWhereInput;
      orderBy?: HouseRulesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  houseRulesesConnection: <T = Promise<Partial<HouseRulesConnectionNode>>>(
    args?: {
      where?: HouseRulesWhereInput;
      orderBy?: HouseRulesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  views: <T = Promise<Partial<ViewsNode | null>>>(
    where: ViewsWhereUniqueInput,
    fragment?: string | object
  ) => T;
  viewses: <T = Promise<Array<ViewsNode>>>(
    args?: {
      where?: ViewsWhereInput;
      orderBy?: ViewsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  viewsesConnection: <T = Promise<Partial<ViewsConnectionNode>>>(
    args?: {
      where?: ViewsWhereInput;
      orderBy?: ViewsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  location: <T = Promise<Partial<LocationNode | null>>>(
    where: LocationWhereUniqueInput,
    fragment?: string | object
  ) => T;
  locations: <T = Promise<Array<LocationNode>>>(
    args?: {
      where?: LocationWhereInput;
      orderBy?: LocationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  locationsConnection: <T = Promise<Partial<LocationConnectionNode>>>(
    args?: {
      where?: LocationWhereInput;
      orderBy?: LocationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  neighbourhood: <T = Promise<Partial<NeighbourhoodNode | null>>>(
    where: NeighbourhoodWhereUniqueInput,
    fragment?: string | object
  ) => T;
  neighbourhoods: <T = Promise<Array<NeighbourhoodNode>>>(
    args?: {
      where?: NeighbourhoodWhereInput;
      orderBy?: NeighbourhoodOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  neighbourhoodsConnection: <T = Promise<Partial<NeighbourhoodConnectionNode>>>(
    args?: {
      where?: NeighbourhoodWhereInput;
      orderBy?: NeighbourhoodOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  city: <T = Promise<Partial<CityNode | null>>>(
    where: CityWhereUniqueInput,
    fragment?: string | object
  ) => T;
  cities: <T = Promise<Array<CityNode>>>(
    args?: {
      where?: CityWhereInput;
      orderBy?: CityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  citiesConnection: <T = Promise<Partial<CityConnectionNode>>>(
    args?: {
      where?: CityWhereInput;
      orderBy?: CityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  picture: <T = Promise<Partial<PictureNode | null>>>(
    where: PictureWhereUniqueInput,
    fragment?: string | object
  ) => T;
  pictures: <T = Promise<Array<PictureNode>>>(
    args?: {
      where?: PictureWhereInput;
      orderBy?: PictureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  picturesConnection: <T = Promise<Partial<PictureConnectionNode>>>(
    args?: {
      where?: PictureWhereInput;
      orderBy?: PictureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  experience: <T = Promise<Partial<ExperienceNode | null>>>(
    where: ExperienceWhereUniqueInput,
    fragment?: string | object
  ) => T;
  experiences: <T = Promise<Array<ExperienceNode>>>(
    args?: {
      where?: ExperienceWhereInput;
      orderBy?: ExperienceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  experiencesConnection: <T = Promise<Partial<ExperienceConnectionNode>>>(
    args?: {
      where?: ExperienceWhereInput;
      orderBy?: ExperienceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  experienceCategory: <T = Promise<Partial<ExperienceCategoryNode | null>>>(
    where: ExperienceCategoryWhereUniqueInput,
    fragment?: string | object
  ) => T;
  experienceCategories: <T = Promise<Array<ExperienceCategoryNode>>>(
    args?: {
      where?: ExperienceCategoryWhereInput;
      orderBy?: ExperienceCategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  experienceCategoriesConnection: <
    T = Promise<Partial<ExperienceCategoryConnectionNode>>
  >(
    args?: {
      where?: ExperienceCategoryWhereInput;
      orderBy?: ExperienceCategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  amenities: <T = Promise<Partial<AmenitiesNode | null>>>(
    where: AmenitiesWhereUniqueInput,
    fragment?: string | object
  ) => T;
  amenitieses: <T = Promise<Array<AmenitiesNode>>>(
    args?: {
      where?: AmenitiesWhereInput;
      orderBy?: AmenitiesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  amenitiesesConnection: <T = Promise<Partial<AmenitiesConnectionNode>>>(
    args?: {
      where?: AmenitiesWhereInput;
      orderBy?: AmenitiesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  review: <T = Promise<Partial<ReviewNode | null>>>(
    where: ReviewWhereUniqueInput,
    fragment?: string | object
  ) => T;
  reviews: <T = Promise<Array<ReviewNode>>>(
    args?: {
      where?: ReviewWhereInput;
      orderBy?: ReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  reviewsConnection: <T = Promise<Partial<ReviewConnectionNode>>>(
    args?: {
      where?: ReviewWhereInput;
      orderBy?: ReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  booking: <T = Promise<Partial<BookingNode | null>>>(
    where: BookingWhereUniqueInput,
    fragment?: string | object
  ) => T;
  bookings: <T = Promise<Array<BookingNode>>>(
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  bookingsConnection: <T = Promise<Partial<BookingConnectionNode>>>(
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  payment: <T = Promise<Partial<PaymentNode | null>>>(
    where: PaymentWhereUniqueInput,
    fragment?: string | object
  ) => T;
  payments: <T = Promise<Array<PaymentNode>>>(
    args?: {
      where?: PaymentWhereInput;
      orderBy?: PaymentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  paymentsConnection: <T = Promise<Partial<PaymentConnectionNode>>>(
    args?: {
      where?: PaymentWhereInput;
      orderBy?: PaymentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  paymentAccount: <T = Promise<Partial<PaymentAccountNode | null>>>(
    where: PaymentAccountWhereUniqueInput,
    fragment?: string | object
  ) => T;
  paymentAccounts: <T = Promise<Array<PaymentAccountNode>>>(
    args?: {
      where?: PaymentAccountWhereInput;
      orderBy?: PaymentAccountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  paymentAccountsConnection: <
    T = Promise<Partial<PaymentAccountConnectionNode>>
  >(
    args?: {
      where?: PaymentAccountWhereInput;
      orderBy?: PaymentAccountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  paypalInformation: <T = Promise<Partial<PaypalInformationNode | null>>>(
    where: PaypalInformationWhereUniqueInput,
    fragment?: string | object
  ) => T;
  paypalInformations: <T = Promise<Array<PaypalInformationNode>>>(
    args?: {
      where?: PaypalInformationWhereInput;
      orderBy?: PaypalInformationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  paypalInformationsConnection: <
    T = Promise<Partial<PaypalInformationConnectionNode>>
  >(
    args?: {
      where?: PaypalInformationWhereInput;
      orderBy?: PaypalInformationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  creditCardInformation: <
    T = Promise<Partial<CreditCardInformationNode | null>>
  >(
    where: CreditCardInformationWhereUniqueInput,
    fragment?: string | object
  ) => T;
  creditCardInformations: <T = Promise<Array<CreditCardInformationNode>>>(
    args?: {
      where?: CreditCardInformationWhereInput;
      orderBy?: CreditCardInformationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  creditCardInformationsConnection: <
    T = Promise<Partial<CreditCardInformationConnectionNode>>
  >(
    args?: {
      where?: CreditCardInformationWhereInput;
      orderBy?: CreditCardInformationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  message: <T = Promise<Partial<MessageNode | null>>>(
    where: MessageWhereUniqueInput,
    fragment?: string | object
  ) => T;
  messages: <T = Promise<Array<MessageNode>>>(
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  messagesConnection: <T = Promise<Partial<MessageConnectionNode>>>(
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  notification: <T = Promise<Partial<NotificationNode | null>>>(
    where: NotificationWhereUniqueInput,
    fragment?: string | object
  ) => T;
  notifications: <T = Promise<Array<NotificationNode>>>(
    args?: {
      where?: NotificationWhereInput;
      orderBy?: NotificationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  notificationsConnection: <T = Promise<Partial<NotificationConnectionNode>>>(
    args?: {
      where?: NotificationWhereInput;
      orderBy?: NotificationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  restaurant: <T = Promise<Partial<RestaurantNode | null>>>(
    where: RestaurantWhereUniqueInput,
    fragment?: string | object
  ) => T;
  restaurants: <T = Promise<Array<RestaurantNode>>>(
    args?: {
      where?: RestaurantWhereInput;
      orderBy?: RestaurantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  restaurantsConnection: <T = Promise<Partial<RestaurantConnectionNode>>>(
    args?: {
      where?: RestaurantWhereInput;
      orderBy?: RestaurantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  node: <T = Promise<Partial<NodeNode | null>>>(
    args: { id: ID_Output },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
}

export interface DelegateMutation {
  createUser: <T = Promise<Partial<UserNode>>>(
    where: UserCreateInput,
    fragment?: string | object
  ) => T;
  updateUser: <T = Promise<Partial<UserNode | null>>>(
    args: { data: UserUpdateInput; where: UserWhereUniqueInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  updateManyUsers: <T = Promise<Partial<BatchPayloadNode>>>(
    args: { data: UserUpdateInput; where?: UserWhereInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  upsertUser: <T = Promise<Partial<UserNode>>>(
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  deleteUser: <T = Promise<Partial<UserNode | null>>>(
    where: UserWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyUsers: <T = Promise<Partial<BatchPayloadNode>>>(
    where?: UserWhereInput,
    fragment?: string | object
  ) => T;
  createPlace: <T = Promise<Partial<PlaceNode>>>(
    where: PlaceCreateInput,
    fragment?: string | object
  ) => T;
  updatePlace: <T = Promise<Partial<PlaceNode | null>>>(
    args: { data: PlaceUpdateInput; where: PlaceWhereUniqueInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  updateManyPlaces: <T = Promise<Partial<BatchPayloadNode>>>(
    args: { data: PlaceUpdateInput; where?: PlaceWhereInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  upsertPlace: <T = Promise<Partial<PlaceNode>>>(
    args: {
      where: PlaceWhereUniqueInput;
      create: PlaceCreateInput;
      update: PlaceUpdateInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  deletePlace: <T = Promise<Partial<PlaceNode | null>>>(
    where: PlaceWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyPlaces: <T = Promise<Partial<BatchPayloadNode>>>(
    where?: PlaceWhereInput,
    fragment?: string | object
  ) => T;
  createPricing: <T = Promise<Partial<PricingNode>>>(
    where: PricingCreateInput,
    fragment?: string | object
  ) => T;
  updatePricing: <T = Promise<Partial<PricingNode | null>>>(
    args: { data: PricingUpdateInput; where: PricingWhereUniqueInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  updateManyPricings: <T = Promise<Partial<BatchPayloadNode>>>(
    args: { data: PricingUpdateInput; where?: PricingWhereInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  upsertPricing: <T = Promise<Partial<PricingNode>>>(
    args: {
      where: PricingWhereUniqueInput;
      create: PricingCreateInput;
      update: PricingUpdateInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  deletePricing: <T = Promise<Partial<PricingNode | null>>>(
    where: PricingWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyPricings: <T = Promise<Partial<BatchPayloadNode>>>(
    where?: PricingWhereInput,
    fragment?: string | object
  ) => T;
  createGuestRequirements: <T = Promise<Partial<GuestRequirementsNode>>>(
    where: GuestRequirementsCreateInput,
    fragment?: string | object
  ) => T;
  updateGuestRequirements: <T = Promise<Partial<GuestRequirementsNode | null>>>(
    args: {
      data: GuestRequirementsUpdateInput;
      where: GuestRequirementsWhereUniqueInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  updateManyGuestRequirementses: <T = Promise<Partial<BatchPayloadNode>>>(
    args: {
      data: GuestRequirementsUpdateInput;
      where?: GuestRequirementsWhereInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  upsertGuestRequirements: <T = Promise<Partial<GuestRequirementsNode>>>(
    args: {
      where: GuestRequirementsWhereUniqueInput;
      create: GuestRequirementsCreateInput;
      update: GuestRequirementsUpdateInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  deleteGuestRequirements: <T = Promise<Partial<GuestRequirementsNode | null>>>(
    where: GuestRequirementsWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyGuestRequirementses: <T = Promise<Partial<BatchPayloadNode>>>(
    where?: GuestRequirementsWhereInput,
    fragment?: string | object
  ) => T;
  createPolicies: <T = Promise<Partial<PoliciesNode>>>(
    where: PoliciesCreateInput,
    fragment?: string | object
  ) => T;
  updatePolicies: <T = Promise<Partial<PoliciesNode | null>>>(
    args: { data: PoliciesUpdateInput; where: PoliciesWhereUniqueInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  updateManyPolicieses: <T = Promise<Partial<BatchPayloadNode>>>(
    args: { data: PoliciesUpdateInput; where?: PoliciesWhereInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  upsertPolicies: <T = Promise<Partial<PoliciesNode>>>(
    args: {
      where: PoliciesWhereUniqueInput;
      create: PoliciesCreateInput;
      update: PoliciesUpdateInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  deletePolicies: <T = Promise<Partial<PoliciesNode | null>>>(
    where: PoliciesWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyPolicieses: <T = Promise<Partial<BatchPayloadNode>>>(
    where?: PoliciesWhereInput,
    fragment?: string | object
  ) => T;
  createHouseRules: <T = Promise<Partial<HouseRulesNode>>>(
    where: HouseRulesCreateInput,
    fragment?: string | object
  ) => T;
  updateHouseRules: <T = Promise<Partial<HouseRulesNode | null>>>(
    args: { data: HouseRulesUpdateInput; where: HouseRulesWhereUniqueInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  updateManyHouseRuleses: <T = Promise<Partial<BatchPayloadNode>>>(
    args: { data: HouseRulesUpdateInput; where?: HouseRulesWhereInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  upsertHouseRules: <T = Promise<Partial<HouseRulesNode>>>(
    args: {
      where: HouseRulesWhereUniqueInput;
      create: HouseRulesCreateInput;
      update: HouseRulesUpdateInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  deleteHouseRules: <T = Promise<Partial<HouseRulesNode | null>>>(
    where: HouseRulesWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyHouseRuleses: <T = Promise<Partial<BatchPayloadNode>>>(
    where?: HouseRulesWhereInput,
    fragment?: string | object
  ) => T;
  createViews: <T = Promise<Partial<ViewsNode>>>(
    where: ViewsCreateInput,
    fragment?: string | object
  ) => T;
  updateViews: <T = Promise<Partial<ViewsNode | null>>>(
    args: { data: ViewsUpdateInput; where: ViewsWhereUniqueInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  updateManyViewses: <T = Promise<Partial<BatchPayloadNode>>>(
    args: { data: ViewsUpdateInput; where?: ViewsWhereInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  upsertViews: <T = Promise<Partial<ViewsNode>>>(
    args: {
      where: ViewsWhereUniqueInput;
      create: ViewsCreateInput;
      update: ViewsUpdateInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  deleteViews: <T = Promise<Partial<ViewsNode | null>>>(
    where: ViewsWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyViewses: <T = Promise<Partial<BatchPayloadNode>>>(
    where?: ViewsWhereInput,
    fragment?: string | object
  ) => T;
  createLocation: <T = Promise<Partial<LocationNode>>>(
    where: LocationCreateInput,
    fragment?: string | object
  ) => T;
  updateLocation: <T = Promise<Partial<LocationNode | null>>>(
    args: { data: LocationUpdateInput; where: LocationWhereUniqueInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  updateManyLocations: <T = Promise<Partial<BatchPayloadNode>>>(
    args: { data: LocationUpdateInput; where?: LocationWhereInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  upsertLocation: <T = Promise<Partial<LocationNode>>>(
    args: {
      where: LocationWhereUniqueInput;
      create: LocationCreateInput;
      update: LocationUpdateInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  deleteLocation: <T = Promise<Partial<LocationNode | null>>>(
    where: LocationWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyLocations: <T = Promise<Partial<BatchPayloadNode>>>(
    where?: LocationWhereInput,
    fragment?: string | object
  ) => T;
  createNeighbourhood: <T = Promise<Partial<NeighbourhoodNode>>>(
    where: NeighbourhoodCreateInput,
    fragment?: string | object
  ) => T;
  updateNeighbourhood: <T = Promise<Partial<NeighbourhoodNode | null>>>(
    args: {
      data: NeighbourhoodUpdateInput;
      where: NeighbourhoodWhereUniqueInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  updateManyNeighbourhoods: <T = Promise<Partial<BatchPayloadNode>>>(
    args: { data: NeighbourhoodUpdateInput; where?: NeighbourhoodWhereInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  upsertNeighbourhood: <T = Promise<Partial<NeighbourhoodNode>>>(
    args: {
      where: NeighbourhoodWhereUniqueInput;
      create: NeighbourhoodCreateInput;
      update: NeighbourhoodUpdateInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  deleteNeighbourhood: <T = Promise<Partial<NeighbourhoodNode | null>>>(
    where: NeighbourhoodWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyNeighbourhoods: <T = Promise<Partial<BatchPayloadNode>>>(
    where?: NeighbourhoodWhereInput,
    fragment?: string | object
  ) => T;
  createCity: <T = Promise<Partial<CityNode>>>(
    where: CityCreateInput,
    fragment?: string | object
  ) => T;
  updateCity: <T = Promise<Partial<CityNode | null>>>(
    args: { data: CityUpdateInput; where: CityWhereUniqueInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  updateManyCities: <T = Promise<Partial<BatchPayloadNode>>>(
    args: { data: CityUpdateInput; where?: CityWhereInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  upsertCity: <T = Promise<Partial<CityNode>>>(
    args: {
      where: CityWhereUniqueInput;
      create: CityCreateInput;
      update: CityUpdateInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  deleteCity: <T = Promise<Partial<CityNode | null>>>(
    where: CityWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyCities: <T = Promise<Partial<BatchPayloadNode>>>(
    where?: CityWhereInput,
    fragment?: string | object
  ) => T;
  createPicture: <T = Promise<Partial<PictureNode>>>(
    where: PictureCreateInput,
    fragment?: string | object
  ) => T;
  updatePicture: <T = Promise<Partial<PictureNode | null>>>(
    args: { data: PictureUpdateInput; where: PictureWhereUniqueInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  updateManyPictures: <T = Promise<Partial<BatchPayloadNode>>>(
    args: { data: PictureUpdateInput; where?: PictureWhereInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  upsertPicture: <T = Promise<Partial<PictureNode>>>(
    args: {
      where: PictureWhereUniqueInput;
      create: PictureCreateInput;
      update: PictureUpdateInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  deletePicture: <T = Promise<Partial<PictureNode | null>>>(
    where: PictureWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyPictures: <T = Promise<Partial<BatchPayloadNode>>>(
    where?: PictureWhereInput,
    fragment?: string | object
  ) => T;
  createExperience: <T = Promise<Partial<ExperienceNode>>>(
    where: ExperienceCreateInput,
    fragment?: string | object
  ) => T;
  updateExperience: <T = Promise<Partial<ExperienceNode | null>>>(
    args: { data: ExperienceUpdateInput; where: ExperienceWhereUniqueInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  updateManyExperiences: <T = Promise<Partial<BatchPayloadNode>>>(
    args: { data: ExperienceUpdateInput; where?: ExperienceWhereInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  upsertExperience: <T = Promise<Partial<ExperienceNode>>>(
    args: {
      where: ExperienceWhereUniqueInput;
      create: ExperienceCreateInput;
      update: ExperienceUpdateInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  deleteExperience: <T = Promise<Partial<ExperienceNode | null>>>(
    where: ExperienceWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyExperiences: <T = Promise<Partial<BatchPayloadNode>>>(
    where?: ExperienceWhereInput,
    fragment?: string | object
  ) => T;
  createExperienceCategory: <T = Promise<Partial<ExperienceCategoryNode>>>(
    where: ExperienceCategoryCreateInput,
    fragment?: string | object
  ) => T;
  updateExperienceCategory: <
    T = Promise<Partial<ExperienceCategoryNode | null>>
  >(
    args: {
      data: ExperienceCategoryUpdateInput;
      where: ExperienceCategoryWhereUniqueInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  updateManyExperienceCategories: <T = Promise<Partial<BatchPayloadNode>>>(
    args: {
      data: ExperienceCategoryUpdateInput;
      where?: ExperienceCategoryWhereInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  upsertExperienceCategory: <T = Promise<Partial<ExperienceCategoryNode>>>(
    args: {
      where: ExperienceCategoryWhereUniqueInput;
      create: ExperienceCategoryCreateInput;
      update: ExperienceCategoryUpdateInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  deleteExperienceCategory: <
    T = Promise<Partial<ExperienceCategoryNode | null>>
  >(
    where: ExperienceCategoryWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyExperienceCategories: <T = Promise<Partial<BatchPayloadNode>>>(
    where?: ExperienceCategoryWhereInput,
    fragment?: string | object
  ) => T;
  createAmenities: <T = Promise<Partial<AmenitiesNode>>>(
    where: AmenitiesCreateInput,
    fragment?: string | object
  ) => T;
  updateAmenities: <T = Promise<Partial<AmenitiesNode | null>>>(
    args: { data: AmenitiesUpdateInput; where: AmenitiesWhereUniqueInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  updateManyAmenitieses: <T = Promise<Partial<BatchPayloadNode>>>(
    args: { data: AmenitiesUpdateInput; where?: AmenitiesWhereInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  upsertAmenities: <T = Promise<Partial<AmenitiesNode>>>(
    args: {
      where: AmenitiesWhereUniqueInput;
      create: AmenitiesCreateInput;
      update: AmenitiesUpdateInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  deleteAmenities: <T = Promise<Partial<AmenitiesNode | null>>>(
    where: AmenitiesWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyAmenitieses: <T = Promise<Partial<BatchPayloadNode>>>(
    where?: AmenitiesWhereInput,
    fragment?: string | object
  ) => T;
  createReview: <T = Promise<Partial<ReviewNode>>>(
    where: ReviewCreateInput,
    fragment?: string | object
  ) => T;
  updateReview: <T = Promise<Partial<ReviewNode | null>>>(
    args: { data: ReviewUpdateInput; where: ReviewWhereUniqueInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  updateManyReviews: <T = Promise<Partial<BatchPayloadNode>>>(
    args: { data: ReviewUpdateInput; where?: ReviewWhereInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  upsertReview: <T = Promise<Partial<ReviewNode>>>(
    args: {
      where: ReviewWhereUniqueInput;
      create: ReviewCreateInput;
      update: ReviewUpdateInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  deleteReview: <T = Promise<Partial<ReviewNode | null>>>(
    where: ReviewWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyReviews: <T = Promise<Partial<BatchPayloadNode>>>(
    where?: ReviewWhereInput,
    fragment?: string | object
  ) => T;
  createBooking: <T = Promise<Partial<BookingNode>>>(
    where: BookingCreateInput,
    fragment?: string | object
  ) => T;
  updateBooking: <T = Promise<Partial<BookingNode | null>>>(
    args: { data: BookingUpdateInput; where: BookingWhereUniqueInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  updateManyBookings: <T = Promise<Partial<BatchPayloadNode>>>(
    args: { data: BookingUpdateInput; where?: BookingWhereInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  upsertBooking: <T = Promise<Partial<BookingNode>>>(
    args: {
      where: BookingWhereUniqueInput;
      create: BookingCreateInput;
      update: BookingUpdateInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  deleteBooking: <T = Promise<Partial<BookingNode | null>>>(
    where: BookingWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyBookings: <T = Promise<Partial<BatchPayloadNode>>>(
    where?: BookingWhereInput,
    fragment?: string | object
  ) => T;
  createPayment: <T = Promise<Partial<PaymentNode>>>(
    where: PaymentCreateInput,
    fragment?: string | object
  ) => T;
  updatePayment: <T = Promise<Partial<PaymentNode | null>>>(
    args: { data: PaymentUpdateInput; where: PaymentWhereUniqueInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  updateManyPayments: <T = Promise<Partial<BatchPayloadNode>>>(
    args: { data: PaymentUpdateInput; where?: PaymentWhereInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  upsertPayment: <T = Promise<Partial<PaymentNode>>>(
    args: {
      where: PaymentWhereUniqueInput;
      create: PaymentCreateInput;
      update: PaymentUpdateInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  deletePayment: <T = Promise<Partial<PaymentNode | null>>>(
    where: PaymentWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyPayments: <T = Promise<Partial<BatchPayloadNode>>>(
    where?: PaymentWhereInput,
    fragment?: string | object
  ) => T;
  createPaymentAccount: <T = Promise<Partial<PaymentAccountNode>>>(
    where: PaymentAccountCreateInput,
    fragment?: string | object
  ) => T;
  updatePaymentAccount: <T = Promise<Partial<PaymentAccountNode | null>>>(
    args: {
      data: PaymentAccountUpdateInput;
      where: PaymentAccountWhereUniqueInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  updateManyPaymentAccounts: <T = Promise<Partial<BatchPayloadNode>>>(
    args: { data: PaymentAccountUpdateInput; where?: PaymentAccountWhereInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  upsertPaymentAccount: <T = Promise<Partial<PaymentAccountNode>>>(
    args: {
      where: PaymentAccountWhereUniqueInput;
      create: PaymentAccountCreateInput;
      update: PaymentAccountUpdateInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  deletePaymentAccount: <T = Promise<Partial<PaymentAccountNode | null>>>(
    where: PaymentAccountWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyPaymentAccounts: <T = Promise<Partial<BatchPayloadNode>>>(
    where?: PaymentAccountWhereInput,
    fragment?: string | object
  ) => T;
  createPaypalInformation: <T = Promise<Partial<PaypalInformationNode>>>(
    where: PaypalInformationCreateInput,
    fragment?: string | object
  ) => T;
  updatePaypalInformation: <T = Promise<Partial<PaypalInformationNode | null>>>(
    args: {
      data: PaypalInformationUpdateInput;
      where: PaypalInformationWhereUniqueInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  updateManyPaypalInformations: <T = Promise<Partial<BatchPayloadNode>>>(
    args: {
      data: PaypalInformationUpdateInput;
      where?: PaypalInformationWhereInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  upsertPaypalInformation: <T = Promise<Partial<PaypalInformationNode>>>(
    args: {
      where: PaypalInformationWhereUniqueInput;
      create: PaypalInformationCreateInput;
      update: PaypalInformationUpdateInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  deletePaypalInformation: <T = Promise<Partial<PaypalInformationNode | null>>>(
    where: PaypalInformationWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyPaypalInformations: <T = Promise<Partial<BatchPayloadNode>>>(
    where?: PaypalInformationWhereInput,
    fragment?: string | object
  ) => T;
  createCreditCardInformation: <
    T = Promise<Partial<CreditCardInformationNode>>
  >(
    where: CreditCardInformationCreateInput,
    fragment?: string | object
  ) => T;
  updateCreditCardInformation: <
    T = Promise<Partial<CreditCardInformationNode | null>>
  >(
    args: {
      data: CreditCardInformationUpdateInput;
      where: CreditCardInformationWhereUniqueInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  updateManyCreditCardInformations: <T = Promise<Partial<BatchPayloadNode>>>(
    args: {
      data: CreditCardInformationUpdateInput;
      where?: CreditCardInformationWhereInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  upsertCreditCardInformation: <
    T = Promise<Partial<CreditCardInformationNode>>
  >(
    args: {
      where: CreditCardInformationWhereUniqueInput;
      create: CreditCardInformationCreateInput;
      update: CreditCardInformationUpdateInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  deleteCreditCardInformation: <
    T = Promise<Partial<CreditCardInformationNode | null>>
  >(
    where: CreditCardInformationWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyCreditCardInformations: <T = Promise<Partial<BatchPayloadNode>>>(
    where?: CreditCardInformationWhereInput,
    fragment?: string | object
  ) => T;
  createMessage: <T = Promise<Partial<MessageNode>>>(
    where: MessageCreateInput,
    fragment?: string | object
  ) => T;
  updateMessage: <T = Promise<Partial<MessageNode | null>>>(
    args: { data: MessageUpdateInput; where: MessageWhereUniqueInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  updateManyMessages: <T = Promise<Partial<BatchPayloadNode>>>(
    args: { data: MessageUpdateInput; where?: MessageWhereInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  upsertMessage: <T = Promise<Partial<MessageNode>>>(
    args: {
      where: MessageWhereUniqueInput;
      create: MessageCreateInput;
      update: MessageUpdateInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  deleteMessage: <T = Promise<Partial<MessageNode | null>>>(
    where: MessageWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyMessages: <T = Promise<Partial<BatchPayloadNode>>>(
    where?: MessageWhereInput,
    fragment?: string | object
  ) => T;
  createNotification: <T = Promise<Partial<NotificationNode>>>(
    where: NotificationCreateInput,
    fragment?: string | object
  ) => T;
  updateNotification: <T = Promise<Partial<NotificationNode | null>>>(
    args: {
      data: NotificationUpdateInput;
      where: NotificationWhereUniqueInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  updateManyNotifications: <T = Promise<Partial<BatchPayloadNode>>>(
    args: { data: NotificationUpdateInput; where?: NotificationWhereInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  upsertNotification: <T = Promise<Partial<NotificationNode>>>(
    args: {
      where: NotificationWhereUniqueInput;
      create: NotificationCreateInput;
      update: NotificationUpdateInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  deleteNotification: <T = Promise<Partial<NotificationNode | null>>>(
    where: NotificationWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyNotifications: <T = Promise<Partial<BatchPayloadNode>>>(
    where?: NotificationWhereInput,
    fragment?: string | object
  ) => T;
  createRestaurant: <T = Promise<Partial<RestaurantNode>>>(
    where: RestaurantCreateInput,
    fragment?: string | object
  ) => T;
  updateRestaurant: <T = Promise<Partial<RestaurantNode | null>>>(
    args: { data: RestaurantUpdateInput; where: RestaurantWhereUniqueInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  updateManyRestaurants: <T = Promise<Partial<BatchPayloadNode>>>(
    args: { data: RestaurantUpdateInput; where?: RestaurantWhereInput },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  upsertRestaurant: <T = Promise<Partial<RestaurantNode>>>(
    args: {
      where: RestaurantWhereUniqueInput;
      create: RestaurantCreateInput;
      update: RestaurantUpdateInput;
    },
    info?: GraphQLResolveInfo,
    options?: Options
  ) => T;
  deleteRestaurant: <T = Promise<Partial<RestaurantNode | null>>>(
    where: RestaurantWhereUniqueInput,
    fragment?: string | object
  ) => T;
  deleteManyRestaurants: <T = Promise<Partial<BatchPayloadNode>>>(
    where?: RestaurantWhereInput,
    fragment?: string | object
  ) => T;
}

export interface DelegateSubscription {
  user: <
    T = Promise<AsyncIterator<Partial<UserSubscriptionPayloadNode | null>>>
  >(
    where?: UserSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  place: <
    T = Promise<AsyncIterator<Partial<PlaceSubscriptionPayloadNode | null>>>
  >(
    where?: PlaceSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  pricing: <
    T = Promise<AsyncIterator<Partial<PricingSubscriptionPayloadNode | null>>>
  >(
    where?: PricingSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  guestRequirements: <
    T = Promise<
      AsyncIterator<Partial<GuestRequirementsSubscriptionPayloadNode | null>>
    >
  >(
    where?: GuestRequirementsSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  policies: <
    T = Promise<AsyncIterator<Partial<PoliciesSubscriptionPayloadNode | null>>>
  >(
    where?: PoliciesSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  houseRules: <
    T = Promise<
      AsyncIterator<Partial<HouseRulesSubscriptionPayloadNode | null>>
    >
  >(
    where?: HouseRulesSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  views: <
    T = Promise<AsyncIterator<Partial<ViewsSubscriptionPayloadNode | null>>>
  >(
    where?: ViewsSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  location: <
    T = Promise<AsyncIterator<Partial<LocationSubscriptionPayloadNode | null>>>
  >(
    where?: LocationSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  neighbourhood: <
    T = Promise<
      AsyncIterator<Partial<NeighbourhoodSubscriptionPayloadNode | null>>
    >
  >(
    where?: NeighbourhoodSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  city: <
    T = Promise<AsyncIterator<Partial<CitySubscriptionPayloadNode | null>>>
  >(
    where?: CitySubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  picture: <
    T = Promise<AsyncIterator<Partial<PictureSubscriptionPayloadNode | null>>>
  >(
    where?: PictureSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  experience: <
    T = Promise<
      AsyncIterator<Partial<ExperienceSubscriptionPayloadNode | null>>
    >
  >(
    where?: ExperienceSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  experienceCategory: <
    T = Promise<
      AsyncIterator<Partial<ExperienceCategorySubscriptionPayloadNode | null>>
    >
  >(
    where?: ExperienceCategorySubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  amenities: <
    T = Promise<AsyncIterator<Partial<AmenitiesSubscriptionPayloadNode | null>>>
  >(
    where?: AmenitiesSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  review: <
    T = Promise<AsyncIterator<Partial<ReviewSubscriptionPayloadNode | null>>>
  >(
    where?: ReviewSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  booking: <
    T = Promise<AsyncIterator<Partial<BookingSubscriptionPayloadNode | null>>>
  >(
    where?: BookingSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  payment: <
    T = Promise<AsyncIterator<Partial<PaymentSubscriptionPayloadNode | null>>>
  >(
    where?: PaymentSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  paymentAccount: <
    T = Promise<
      AsyncIterator<Partial<PaymentAccountSubscriptionPayloadNode | null>>
    >
  >(
    where?: PaymentAccountSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  paypalInformation: <
    T = Promise<
      AsyncIterator<Partial<PaypalInformationSubscriptionPayloadNode | null>>
    >
  >(
    where?: PaypalInformationSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  creditCardInformation: <
    T = Promise<
      AsyncIterator<
        Partial<CreditCardInformationSubscriptionPayloadNode | null>
      >
    >
  >(
    where?: CreditCardInformationSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  message: <
    T = Promise<AsyncIterator<Partial<MessageSubscriptionPayloadNode | null>>>
  >(
    where?: MessageSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  notification: <
    T = Promise<
      AsyncIterator<Partial<NotificationSubscriptionPayloadNode | null>>
    >
  >(
    where?: NotificationSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
  restaurant: <
    T = Promise<
      AsyncIterator<Partial<RestaurantSubscriptionPayloadNode | null>>
    >
  >(
    where?: RestaurantSubscriptionWhereInput,
    fragment?: string | object
  ) => T;
}

export interface BindingConstructor<T> {
  new (options?: BasePrismaOptions): T;
}

/**
 * Types
 */

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "responseRate_ASC"
  | "responseRate_DESC"
  | "responseTime_ASC"
  | "responseTime_DESC"
  | "isSuperHost_ASC"
  | "isSuperHost_DESC";

export type CURRENCY = "CAD" | "CHF" | "EUR" | "JPY" | "USD" | "ZAR";

export type ExperienceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "pricePerPerson_ASC"
  | "pricePerPerson_DESC"
  | "popularity_ASC"
  | "popularity_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RestaurantOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "avgPricePerPerson_ASC"
  | "avgPricePerPerson_DESC"
  | "isCurated_ASC"
  | "isCurated_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "popularity_ASC"
  | "popularity_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type NotificationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "type_ASC"
  | "type_DESC"
  | "link_ASC"
  | "link_DESC"
  | "readDate_ASC"
  | "readDate_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PaypalInformationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MessageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "deliveredAt_ASC"
  | "deliveredAt_DESC"
  | "readAt_ASC"
  | "readAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ExperienceCategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "mainColor_ASC"
  | "mainColor_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PaymentAccountOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "type_ASC"
  | "type_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PLACE_SIZES =
  | "ENTIRE_HOUSE"
  | "ENTIRE_APARTMENT"
  | "ENTIRE_EARTH_HOUSE"
  | "ENTIRE_CABIN"
  | "ENTIRE_VILLA"
  | "ENTIRE_PLACE"
  | "ENTIRE_BOAT"
  | "PRIVATE_ROOM";

export type PaymentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "serviceFee_ASC"
  | "serviceFee_DESC"
  | "placePrice_ASC"
  | "placePrice_DESC"
  | "totalPrice_ASC"
  | "totalPrice_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type HouseRulesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "suitableForChildren_ASC"
  | "suitableForChildren_DESC"
  | "suitableForInfants_ASC"
  | "suitableForInfants_DESC"
  | "petsAllowed_ASC"
  | "petsAllowed_DESC"
  | "smokingAllowed_ASC"
  | "smokingAllowed_DESC"
  | "partiesAndEventsAllowed_ASC"
  | "partiesAndEventsAllowed_DESC"
  | "additionalRules_ASC"
  | "additionalRules_DESC";

export type BookingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "endDate_ASC"
  | "endDate_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GuestRequirementsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "govIssuedId_ASC"
  | "govIssuedId_DESC"
  | "recommendationsFromOtherHosts_ASC"
  | "recommendationsFromOtherHosts_DESC"
  | "guestTripInformation_ASC"
  | "guestTripInformation_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PAYMENT_PROVIDER = "PAYPAL" | "CREDIT_CARD";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type PictureOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "url_ASC"
  | "url_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AmenitiesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "elevator_ASC"
  | "elevator_DESC"
  | "petsAllowed_ASC"
  | "petsAllowed_DESC"
  | "internet_ASC"
  | "internet_DESC"
  | "kitchen_ASC"
  | "kitchen_DESC"
  | "wirelessInternet_ASC"
  | "wirelessInternet_DESC"
  | "familyKidFriendly_ASC"
  | "familyKidFriendly_DESC"
  | "freeParkingOnPremises_ASC"
  | "freeParkingOnPremises_DESC"
  | "hotTub_ASC"
  | "hotTub_DESC"
  | "pool_ASC"
  | "pool_DESC"
  | "smokingAllowed_ASC"
  | "smokingAllowed_DESC"
  | "wheelchairAccessible_ASC"
  | "wheelchairAccessible_DESC"
  | "breakfast_ASC"
  | "breakfast_DESC"
  | "cableTv_ASC"
  | "cableTv_DESC"
  | "suitableForEvents_ASC"
  | "suitableForEvents_DESC"
  | "dryer_ASC"
  | "dryer_DESC"
  | "washer_ASC"
  | "washer_DESC"
  | "indoorFireplace_ASC"
  | "indoorFireplace_DESC"
  | "tv_ASC"
  | "tv_DESC"
  | "heating_ASC"
  | "heating_DESC"
  | "hangers_ASC"
  | "hangers_DESC"
  | "iron_ASC"
  | "iron_DESC"
  | "hairDryer_ASC"
  | "hairDryer_DESC"
  | "doorman_ASC"
  | "doorman_DESC"
  | "paidParkingOffPremises_ASC"
  | "paidParkingOffPremises_DESC"
  | "freeParkingOnStreet_ASC"
  | "freeParkingOnStreet_DESC"
  | "gym_ASC"
  | "gym_DESC"
  | "airConditioning_ASC"
  | "airConditioning_DESC"
  | "shampoo_ASC"
  | "shampoo_DESC"
  | "essentials_ASC"
  | "essentials_DESC"
  | "laptopFriendlyWorkspace_ASC"
  | "laptopFriendlyWorkspace_DESC"
  | "privateEntrance_ASC"
  | "privateEntrance_DESC"
  | "buzzerWirelessIntercom_ASC"
  | "buzzerWirelessIntercom_DESC"
  | "babyBath_ASC"
  | "babyBath_DESC"
  | "babyMonitor_ASC"
  | "babyMonitor_DESC"
  | "babysitterRecommendations_ASC"
  | "babysitterRecommendations_DESC"
  | "bathtub_ASC"
  | "bathtub_DESC"
  | "changingTable_ASC"
  | "changingTable_DESC"
  | "childrensBooksAndToys_ASC"
  | "childrensBooksAndToys_DESC"
  | "childrensDinnerware_ASC"
  | "childrensDinnerware_DESC"
  | "crib_ASC"
  | "crib_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type NeighbourhoodOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "featured_ASC"
  | "featured_DESC"
  | "popularity_ASC"
  | "popularity_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ViewsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "lastWeek_ASC"
  | "lastWeek_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PlaceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "size_ASC"
  | "size_DESC"
  | "shortDescription_ASC"
  | "shortDescription_DESC"
  | "description_ASC"
  | "description_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "maxGuests_ASC"
  | "maxGuests_DESC"
  | "numBedrooms_ASC"
  | "numBedrooms_DESC"
  | "numBeds_ASC"
  | "numBeds_DESC"
  | "numBaths_ASC"
  | "numBaths_DESC"
  | "popularity_ASC"
  | "popularity_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type NOTIFICATION_TYPE =
  | "OFFER"
  | "INSTANT_BOOK"
  | "RESPONSIVENESS"
  | "NEW_AMENITIES"
  | "HOUSE_RULES";

export type ReviewOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "text_ASC"
  | "text_DESC"
  | "stars_ASC"
  | "stars_DESC"
  | "accuracy_ASC"
  | "accuracy_DESC"
  | "location_ASC"
  | "location_DESC"
  | "checkIn_ASC"
  | "checkIn_DESC"
  | "value_ASC"
  | "value_DESC"
  | "cleanliness_ASC"
  | "cleanliness_DESC"
  | "communication_ASC"
  | "communication_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type LocationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "lat_ASC"
  | "lat_DESC"
  | "lng_ASC"
  | "lng_DESC"
  | "address_ASC"
  | "address_DESC"
  | "directions_ASC"
  | "directions_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PoliciesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "checkInStartTime_ASC"
  | "checkInStartTime_DESC"
  | "checkInEndTime_ASC"
  | "checkInEndTime_DESC"
  | "checkoutTime_ASC"
  | "checkoutTime_DESC";

export type CityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CreditCardInformationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "cardNumber_ASC"
  | "cardNumber_DESC"
  | "expiresOnMonth_ASC"
  | "expiresOnMonth_DESC"
  | "expiresOnYear_ASC"
  | "expiresOnYear_DESC"
  | "securityCode_ASC"
  | "securityCode_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "postalCode_ASC"
  | "postalCode_DESC"
  | "country_ASC"
  | "country_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PricingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "monthlyDiscount_ASC"
  | "monthlyDiscount_DESC"
  | "weeklyDiscount_ASC"
  | "weeklyDiscount_DESC"
  | "perNight_ASC"
  | "perNight_DESC"
  | "smartPricing_ASC"
  | "smartPricing_DESC"
  | "basePrice_ASC"
  | "basePrice_DESC"
  | "averageWeekly_ASC"
  | "averageWeekly_DESC"
  | "averageMonthly_ASC"
  | "averageMonthly_DESC"
  | "cleaningFee_ASC"
  | "cleaningFee_DESC"
  | "securityDeposit_ASC"
  | "securityDeposit_DESC"
  | "extraGuests_ASC"
  | "extraGuests_DESC"
  | "weekendPricing_ASC"
  | "weekendPricing_DESC"
  | "currency_ASC"
  | "currency_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface AmenitiesUpsertWithoutPlaceInput {
  update: AmenitiesUpdateWithoutPlaceDataInput;
  create: AmenitiesCreateWithoutPlaceInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id?: ID_Input;
  email?: String;
}>;

export interface PaymentAccountUpdateManyWithoutUserInput {
  create?:
    | PaymentAccountCreateWithoutUserInput[]
    | PaymentAccountCreateWithoutUserInput;
  delete?: PaymentAccountWhereUniqueInput[] | PaymentAccountWhereUniqueInput;
  connect?: PaymentAccountWhereUniqueInput[] | PaymentAccountWhereUniqueInput;
  disconnect?:
    | PaymentAccountWhereUniqueInput[]
    | PaymentAccountWhereUniqueInput;
  update?:
    | PaymentAccountUpdateWithWhereUniqueWithoutUserInput[]
    | PaymentAccountUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | PaymentAccountUpsertWithWhereUniqueWithoutUserInput[]
    | PaymentAccountUpsertWithWhereUniqueWithoutUserInput;
}

export interface PricingWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  place?: PlaceWhereInput;
  monthlyDiscount?: Int;
  monthlyDiscount_not?: Int;
  monthlyDiscount_in?: Int[] | Int;
  monthlyDiscount_not_in?: Int[] | Int;
  monthlyDiscount_lt?: Int;
  monthlyDiscount_lte?: Int;
  monthlyDiscount_gt?: Int;
  monthlyDiscount_gte?: Int;
  weeklyDiscount?: Int;
  weeklyDiscount_not?: Int;
  weeklyDiscount_in?: Int[] | Int;
  weeklyDiscount_not_in?: Int[] | Int;
  weeklyDiscount_lt?: Int;
  weeklyDiscount_lte?: Int;
  weeklyDiscount_gt?: Int;
  weeklyDiscount_gte?: Int;
  perNight?: Int;
  perNight_not?: Int;
  perNight_in?: Int[] | Int;
  perNight_not_in?: Int[] | Int;
  perNight_lt?: Int;
  perNight_lte?: Int;
  perNight_gt?: Int;
  perNight_gte?: Int;
  smartPricing?: Boolean;
  smartPricing_not?: Boolean;
  basePrice?: Int;
  basePrice_not?: Int;
  basePrice_in?: Int[] | Int;
  basePrice_not_in?: Int[] | Int;
  basePrice_lt?: Int;
  basePrice_lte?: Int;
  basePrice_gt?: Int;
  basePrice_gte?: Int;
  averageWeekly?: Int;
  averageWeekly_not?: Int;
  averageWeekly_in?: Int[] | Int;
  averageWeekly_not_in?: Int[] | Int;
  averageWeekly_lt?: Int;
  averageWeekly_lte?: Int;
  averageWeekly_gt?: Int;
  averageWeekly_gte?: Int;
  averageMonthly?: Int;
  averageMonthly_not?: Int;
  averageMonthly_in?: Int[] | Int;
  averageMonthly_not_in?: Int[] | Int;
  averageMonthly_lt?: Int;
  averageMonthly_lte?: Int;
  averageMonthly_gt?: Int;
  averageMonthly_gte?: Int;
  cleaningFee?: Int;
  cleaningFee_not?: Int;
  cleaningFee_in?: Int[] | Int;
  cleaningFee_not_in?: Int[] | Int;
  cleaningFee_lt?: Int;
  cleaningFee_lte?: Int;
  cleaningFee_gt?: Int;
  cleaningFee_gte?: Int;
  securityDeposit?: Int;
  securityDeposit_not?: Int;
  securityDeposit_in?: Int[] | Int;
  securityDeposit_not_in?: Int[] | Int;
  securityDeposit_lt?: Int;
  securityDeposit_lte?: Int;
  securityDeposit_gt?: Int;
  securityDeposit_gte?: Int;
  extraGuests?: Int;
  extraGuests_not?: Int;
  extraGuests_in?: Int[] | Int;
  extraGuests_not_in?: Int[] | Int;
  extraGuests_lt?: Int;
  extraGuests_lte?: Int;
  extraGuests_gt?: Int;
  extraGuests_gte?: Int;
  weekendPricing?: Int;
  weekendPricing_not?: Int;
  weekendPricing_in?: Int[] | Int;
  weekendPricing_not_in?: Int[] | Int;
  weekendPricing_lt?: Int;
  weekendPricing_lte?: Int;
  weekendPricing_gt?: Int;
  weekendPricing_gte?: Int;
  currency?: CURRENCY;
  currency_not?: CURRENCY;
  currency_in?: CURRENCY[] | CURRENCY;
  currency_not_in?: CURRENCY[] | CURRENCY;
  AND?: PricingWhereInput[] | PricingWhereInput;
  OR?: PricingWhereInput[] | PricingWhereInput;
  NOT?: PricingWhereInput[] | PricingWhereInput;
}

export interface PaymentAccountUpdateWithWhereUniqueWithoutUserInput {
  where: PaymentAccountWhereUniqueInput;
  data: PaymentAccountUpdateWithoutUserDataInput;
}

export interface GuestRequirementsWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  govIssuedId?: Boolean;
  govIssuedId_not?: Boolean;
  recommendationsFromOtherHosts?: Boolean;
  recommendationsFromOtherHosts_not?: Boolean;
  guestTripInformation?: Boolean;
  guestTripInformation_not?: Boolean;
  place?: PlaceWhereInput;
  AND?: GuestRequirementsWhereInput[] | GuestRequirementsWhereInput;
  OR?: GuestRequirementsWhereInput[] | GuestRequirementsWhereInput;
  NOT?: GuestRequirementsWhereInput[] | GuestRequirementsWhereInput;
}

export interface PaymentAccountUpdateWithoutUserDataInput {
  type?: PAYMENT_PROVIDER;
  payments?: PaymentUpdateManyWithoutPaymentMethodInput;
  paypal?: PaypalInformationUpdateOneWithoutPaymentAccountInput;
  creditcard?: CreditCardInformationUpdateOneWithoutPaymentAccountInput;
}

export interface HouseRulesWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  suitableForChildren?: Boolean;
  suitableForChildren_not?: Boolean;
  suitableForInfants?: Boolean;
  suitableForInfants_not?: Boolean;
  petsAllowed?: Boolean;
  petsAllowed_not?: Boolean;
  smokingAllowed?: Boolean;
  smokingAllowed_not?: Boolean;
  partiesAndEventsAllowed?: Boolean;
  partiesAndEventsAllowed_not?: Boolean;
  additionalRules?: String;
  additionalRules_not?: String;
  additionalRules_in?: String[] | String;
  additionalRules_not_in?: String[] | String;
  additionalRules_lt?: String;
  additionalRules_lte?: String;
  additionalRules_gt?: String;
  additionalRules_gte?: String;
  additionalRules_contains?: String;
  additionalRules_not_contains?: String;
  additionalRules_starts_with?: String;
  additionalRules_not_starts_with?: String;
  additionalRules_ends_with?: String;
  additionalRules_not_ends_with?: String;
  AND?: HouseRulesWhereInput[] | HouseRulesWhereInput;
  OR?: HouseRulesWhereInput[] | HouseRulesWhereInput;
  NOT?: HouseRulesWhereInput[] | HouseRulesWhereInput;
}

export interface ViewsCreateOneWithoutPlaceInput {
  create?: ViewsCreateWithoutPlaceInput;
  connect?: ViewsWhereUniqueInput;
}

export interface ViewsUpdateInput {
  lastWeek?: Int;
  place?: PlaceUpdateOneWithoutViewsInput;
}

export interface ViewsCreateWithoutPlaceInput {
  lastWeek: Int;
}

export interface PaymentUpdateManyWithoutPaymentMethodInput {
  create?:
    | PaymentCreateWithoutPaymentMethodInput[]
    | PaymentCreateWithoutPaymentMethodInput;
  delete?: PaymentWhereUniqueInput[] | PaymentWhereUniqueInput;
  connect?: PaymentWhereUniqueInput[] | PaymentWhereUniqueInput;
  disconnect?: PaymentWhereUniqueInput[] | PaymentWhereUniqueInput;
  update?:
    | PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    | PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput;
  upsert?:
    | PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    | PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput;
}

export interface GuestRequirementsCreateOneWithoutPlaceInput {
  create?: GuestRequirementsCreateWithoutPlaceInput;
  connect?: GuestRequirementsWhereUniqueInput;
}

export interface NotificationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: NotificationWhereInput;
  AND?:
    | NotificationSubscriptionWhereInput[]
    | NotificationSubscriptionWhereInput;
  OR?:
    | NotificationSubscriptionWhereInput[]
    | NotificationSubscriptionWhereInput;
  NOT?:
    | NotificationSubscriptionWhereInput[]
    | NotificationSubscriptionWhereInput;
}

export interface GuestRequirementsCreateWithoutPlaceInput {
  govIssuedId?: Boolean;
  recommendationsFromOtherHosts?: Boolean;
  guestTripInformation?: Boolean;
}

export interface CreditCardInformationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CreditCardInformationWhereInput;
  AND?:
    | CreditCardInformationSubscriptionWhereInput[]
    | CreditCardInformationSubscriptionWhereInput;
  OR?:
    | CreditCardInformationSubscriptionWhereInput[]
    | CreditCardInformationSubscriptionWhereInput;
  NOT?:
    | CreditCardInformationSubscriptionWhereInput[]
    | CreditCardInformationSubscriptionWhereInput;
}

export interface PoliciesCreateOneWithoutPlaceInput {
  create?: PoliciesCreateWithoutPlaceInput;
  connect?: PoliciesWhereUniqueInput;
}

export interface MessageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  from?: UserWhereInput;
  to?: UserWhereInput;
  deliveredAt?: DateTimeInput;
  deliveredAt_not?: DateTimeInput;
  deliveredAt_in?: DateTimeInput[] | DateTimeInput;
  deliveredAt_not_in?: DateTimeInput[] | DateTimeInput;
  deliveredAt_lt?: DateTimeInput;
  deliveredAt_lte?: DateTimeInput;
  deliveredAt_gt?: DateTimeInput;
  deliveredAt_gte?: DateTimeInput;
  readAt?: DateTimeInput;
  readAt_not?: DateTimeInput;
  readAt_in?: DateTimeInput[] | DateTimeInput;
  readAt_not_in?: DateTimeInput[] | DateTimeInput;
  readAt_lt?: DateTimeInput;
  readAt_lte?: DateTimeInput;
  readAt_gt?: DateTimeInput;
  readAt_gte?: DateTimeInput;
  AND?: MessageWhereInput[] | MessageWhereInput;
  OR?: MessageWhereInput[] | MessageWhereInput;
  NOT?: MessageWhereInput[] | MessageWhereInput;
}

export interface PoliciesCreateWithoutPlaceInput {
  checkInStartTime: Float;
  checkInEndTime: Float;
  checkoutTime: Float;
}

export interface PaymentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PaymentWhereInput;
  AND?: PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput;
  OR?: PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput;
  NOT?: PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput;
}

export interface HouseRulesCreateOneInput {
  create?: HouseRulesCreateInput;
  connect?: HouseRulesWhereUniqueInput;
}

export interface BookingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BookingWhereInput;
  AND?: BookingSubscriptionWhereInput[] | BookingSubscriptionWhereInput;
  OR?: BookingSubscriptionWhereInput[] | BookingSubscriptionWhereInput;
  NOT?: BookingSubscriptionWhereInput[] | BookingSubscriptionWhereInput;
}

export interface HouseRulesCreateInput {
  suitableForChildren?: Boolean;
  suitableForInfants?: Boolean;
  petsAllowed?: Boolean;
  smokingAllowed?: Boolean;
  partiesAndEventsAllowed?: Boolean;
  additionalRules?: String;
}

export interface ReviewSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ReviewWhereInput;
  AND?: ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput;
  OR?: ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput;
  NOT?: ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput;
}

export interface BookingCreateManyWithoutPlaceInput {
  create?: BookingCreateWithoutPlaceInput[] | BookingCreateWithoutPlaceInput;
  connect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
}

export interface ExperienceCategorySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ExperienceCategoryWhereInput;
  AND?:
    | ExperienceCategorySubscriptionWhereInput[]
    | ExperienceCategorySubscriptionWhereInput;
  OR?:
    | ExperienceCategorySubscriptionWhereInput[]
    | ExperienceCategorySubscriptionWhereInput;
  NOT?:
    | ExperienceCategorySubscriptionWhereInput[]
    | ExperienceCategorySubscriptionWhereInput;
}

export interface BookingCreateWithoutPlaceInput {
  bookee: UserCreateOneWithoutBookingsInput;
  startDate: DateTimeInput;
  endDate: DateTimeInput;
  payment?: PaymentCreateOneWithoutBookingInput;
}

export interface PictureSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PictureWhereInput;
  AND?: PictureSubscriptionWhereInput[] | PictureSubscriptionWhereInput;
  OR?: PictureSubscriptionWhereInput[] | PictureSubscriptionWhereInput;
  NOT?: PictureSubscriptionWhereInput[] | PictureSubscriptionWhereInput;
}

export interface PaymentCreateOneWithoutBookingInput {
  create?: PaymentCreateWithoutBookingInput;
  connect?: PaymentWhereUniqueInput;
}

export interface PaymentAccountWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  type?: PAYMENT_PROVIDER;
  type_not?: PAYMENT_PROVIDER;
  type_in?: PAYMENT_PROVIDER[] | PAYMENT_PROVIDER;
  type_not_in?: PAYMENT_PROVIDER[] | PAYMENT_PROVIDER;
  user?: UserWhereInput;
  payments_every?: PaymentWhereInput;
  payments_some?: PaymentWhereInput;
  payments_none?: PaymentWhereInput;
  paypal?: PaypalInformationWhereInput;
  creditcard?: CreditCardInformationWhereInput;
  AND?: PaymentAccountWhereInput[] | PaymentAccountWhereInput;
  OR?: PaymentAccountWhereInput[] | PaymentAccountWhereInput;
  NOT?: PaymentAccountWhereInput[] | PaymentAccountWhereInput;
}

export interface PaymentCreateWithoutBookingInput {
  serviceFee: Float;
  placePrice: Float;
  totalPrice: Float;
  paymentMethod: PaymentAccountCreateOneWithoutPaymentsInput;
}

export interface LocationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LocationWhereInput;
  AND?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
  OR?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
  NOT?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
}

export interface PaymentAccountCreateOneWithoutPaymentsInput {
  create?: PaymentAccountCreateWithoutPaymentsInput;
  connect?: PaymentAccountWhereUniqueInput;
}

export interface PaymentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  serviceFee?: Float;
  serviceFee_not?: Float;
  serviceFee_in?: Float[] | Float;
  serviceFee_not_in?: Float[] | Float;
  serviceFee_lt?: Float;
  serviceFee_lte?: Float;
  serviceFee_gt?: Float;
  serviceFee_gte?: Float;
  placePrice?: Float;
  placePrice_not?: Float;
  placePrice_in?: Float[] | Float;
  placePrice_not_in?: Float[] | Float;
  placePrice_lt?: Float;
  placePrice_lte?: Float;
  placePrice_gt?: Float;
  placePrice_gte?: Float;
  totalPrice?: Float;
  totalPrice_not?: Float;
  totalPrice_in?: Float[] | Float;
  totalPrice_not_in?: Float[] | Float;
  totalPrice_lt?: Float;
  totalPrice_lte?: Float;
  totalPrice_gt?: Float;
  totalPrice_gte?: Float;
  booking?: BookingWhereInput;
  paymentMethod?: PaymentAccountWhereInput;
  AND?: PaymentWhereInput[] | PaymentWhereInput;
  OR?: PaymentWhereInput[] | PaymentWhereInput;
  NOT?: PaymentWhereInput[] | PaymentWhereInput;
}

export interface PaymentAccountCreateWithoutPaymentsInput {
  type?: PAYMENT_PROVIDER;
  user: UserCreateOneWithoutPaymentAccountInput;
  paypal?: PaypalInformationCreateOneWithoutPaymentAccountInput;
  creditcard?: CreditCardInformationCreateOneWithoutPaymentAccountInput;
}

export interface PoliciesSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PoliciesWhereInput;
  AND?: PoliciesSubscriptionWhereInput[] | PoliciesSubscriptionWhereInput;
  OR?: PoliciesSubscriptionWhereInput[] | PoliciesSubscriptionWhereInput;
  NOT?: PoliciesSubscriptionWhereInput[] | PoliciesSubscriptionWhereInput;
}

export interface UserCreateOneWithoutPaymentAccountInput {
  create?: UserCreateWithoutPaymentAccountInput;
  connect?: UserWhereUniqueInput;
}

export interface RestaurantWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  avgPricePerPerson?: Int;
  avgPricePerPerson_not?: Int;
  avgPricePerPerson_in?: Int[] | Int;
  avgPricePerPerson_not_in?: Int[] | Int;
  avgPricePerPerson_lt?: Int;
  avgPricePerPerson_lte?: Int;
  avgPricePerPerson_gt?: Int;
  avgPricePerPerson_gte?: Int;
  pictures_every?: PictureWhereInput;
  pictures_some?: PictureWhereInput;
  pictures_none?: PictureWhereInput;
  location?: LocationWhereInput;
  isCurated?: Boolean;
  isCurated_not?: Boolean;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  popularity?: Int;
  popularity_not?: Int;
  popularity_in?: Int[] | Int;
  popularity_not_in?: Int[] | Int;
  popularity_lt?: Int;
  popularity_lte?: Int;
  popularity_gt?: Int;
  popularity_gte?: Int;
  AND?: RestaurantWhereInput[] | RestaurantWhereInput;
  OR?: RestaurantWhereInput[] | RestaurantWhereInput;
  NOT?: RestaurantWhereInput[] | RestaurantWhereInput;
}

export interface UserCreateWithoutPaymentAccountInput {
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceCreateManyWithoutHostInput;
  location?: LocationCreateOneWithoutUserInput;
  bookings?: BookingCreateManyWithoutBookeeInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receivedMessages?: MessageCreateManyWithoutToInput;
  notifications?: NotificationCreateManyWithoutUserInput;
  profilePicture?: PictureCreateOneInput;
  hostingExperiences?: ExperienceCreateManyWithoutHostInput;
}

export interface CityWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  neighbourhoods_every?: NeighbourhoodWhereInput;
  neighbourhoods_some?: NeighbourhoodWhereInput;
  neighbourhoods_none?: NeighbourhoodWhereInput;
  AND?: CityWhereInput[] | CityWhereInput;
  OR?: CityWhereInput[] | CityWhereInput;
  NOT?: CityWhereInput[] | CityWhereInput;
}

export interface MessageCreateManyWithoutToInput {
  create?: MessageCreateWithoutToInput[] | MessageCreateWithoutToInput;
  connect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
}

export interface PictureWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  AND?: PictureWhereInput[] | PictureWhereInput;
  OR?: PictureWhereInput[] | PictureWhereInput;
  NOT?: PictureWhereInput[] | PictureWhereInput;
}

export interface MessageCreateWithoutToInput {
  from: UserCreateOneWithoutSentMessagesInput;
  deliveredAt: DateTimeInput;
  readAt: DateTimeInput;
}

export interface PlaceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PlaceWhereInput;
  AND?: PlaceSubscriptionWhereInput[] | PlaceSubscriptionWhereInput;
  OR?: PlaceSubscriptionWhereInput[] | PlaceSubscriptionWhereInput;
  NOT?: PlaceSubscriptionWhereInput[] | PlaceSubscriptionWhereInput;
}

export interface UserCreateOneWithoutSentMessagesInput {
  create?: UserCreateWithoutSentMessagesInput;
  connect?: UserWhereUniqueInput;
}

export interface LocationUpsertWithoutRestaurantInput {
  update: LocationUpdateWithoutRestaurantDataInput;
  create: LocationCreateWithoutRestaurantInput;
}

export interface UserCreateWithoutSentMessagesInput {
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceCreateManyWithoutHostInput;
  location?: LocationCreateOneWithoutUserInput;
  bookings?: BookingCreateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountCreateManyWithoutUserInput;
  receivedMessages?: MessageCreateManyWithoutToInput;
  notifications?: NotificationCreateManyWithoutUserInput;
  profilePicture?: PictureCreateOneInput;
  hostingExperiences?: ExperienceCreateManyWithoutHostInput;
}

export type PlaceWhereUniqueInput = AtLeastOne<{
  id?: ID_Input;
}>;

export interface PaypalInformationCreateOneWithoutPaymentAccountInput {
  create?: PaypalInformationCreateWithoutPaymentAccountInput;
  connect?: PaypalInformationWhereUniqueInput;
}

export interface RestaurantUpdateInput {
  title?: String;
  avgPricePerPerson?: Int;
  pictures?: PictureUpdateManyInput;
  location?: LocationUpdateOneWithoutRestaurantInput;
  isCurated?: Boolean;
  slug?: String;
  popularity?: Int;
}

export interface PaypalInformationCreateWithoutPaymentAccountInput {
  email: String;
}

export type PricingWhereUniqueInput = AtLeastOne<{
  id?: ID_Input;
}>;

export interface CreditCardInformationCreateOneWithoutPaymentAccountInput {
  create?: CreditCardInformationCreateWithoutPaymentAccountInput;
  connect?: CreditCardInformationWhereUniqueInput;
}

export interface LocationCreateOneWithoutRestaurantInput {
  create?: LocationCreateWithoutRestaurantInput;
  connect?: LocationWhereUniqueInput;
}

export interface CreditCardInformationCreateWithoutPaymentAccountInput {
  cardNumber: String;
  expiresOnMonth: Int;
  expiresOnYear: Int;
  securityCode: String;
  firstName: String;
  lastName: String;
  postalCode: String;
  country: String;
}

export interface UserUpsertWithoutNotificationsInput {
  update: UserUpdateWithoutNotificationsDataInput;
  create: UserCreateWithoutNotificationsInput;
}

export interface ExperienceCreateOneWithoutLocationInput {
  create?: ExperienceCreateWithoutLocationInput;
  connect?: ExperienceWhereUniqueInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  responseRate?: Float;
  responseRate_not?: Float;
  responseRate_in?: Float[] | Float;
  responseRate_not_in?: Float[] | Float;
  responseRate_lt?: Float;
  responseRate_lte?: Float;
  responseRate_gt?: Float;
  responseRate_gte?: Float;
  responseTime?: Int;
  responseTime_not?: Int;
  responseTime_in?: Int[] | Int;
  responseTime_not_in?: Int[] | Int;
  responseTime_lt?: Int;
  responseTime_lte?: Int;
  responseTime_gt?: Int;
  responseTime_gte?: Int;
  isSuperHost?: Boolean;
  isSuperHost_not?: Boolean;
  ownedPlaces_every?: PlaceWhereInput;
  ownedPlaces_some?: PlaceWhereInput;
  ownedPlaces_none?: PlaceWhereInput;
  location?: LocationWhereInput;
  bookings_every?: BookingWhereInput;
  bookings_some?: BookingWhereInput;
  bookings_none?: BookingWhereInput;
  paymentAccount_every?: PaymentAccountWhereInput;
  paymentAccount_some?: PaymentAccountWhereInput;
  paymentAccount_none?: PaymentAccountWhereInput;
  sentMessages_every?: MessageWhereInput;
  sentMessages_some?: MessageWhereInput;
  sentMessages_none?: MessageWhereInput;
  receivedMessages_every?: MessageWhereInput;
  receivedMessages_some?: MessageWhereInput;
  receivedMessages_none?: MessageWhereInput;
  notifications_every?: NotificationWhereInput;
  notifications_some?: NotificationWhereInput;
  notifications_none?: NotificationWhereInput;
  profilePicture?: PictureWhereInput;
  hostingExperiences_every?: ExperienceWhereInput;
  hostingExperiences_some?: ExperienceWhereInput;
  hostingExperiences_none?: ExperienceWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface ExperienceCreateWithoutLocationInput {
  category?: ExperienceCategoryCreateOneWithoutExperienceInput;
  title: String;
  host: UserCreateOneWithoutHostingExperiencesInput;
  pricePerPerson: Int;
  reviews?: ReviewCreateManyWithoutExperienceInput;
  preview: PictureCreateOneInput;
  popularity: Int;
}

export interface UserUpdateOneWithoutNotificationsInput {
  create?: UserCreateWithoutNotificationsInput;
  update?: UserUpdateWithoutNotificationsDataInput;
  upsert?: UserUpsertWithoutNotificationsInput;
  delete?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  password?: String;
  phone?: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceUpdateManyWithoutHostInput;
  location?: LocationUpdateOneWithoutUserInput;
  bookings?: BookingUpdateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountUpdateManyWithoutUserInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receivedMessages?: MessageUpdateManyWithoutToInput;
  notifications?: NotificationUpdateManyWithoutUserInput;
  profilePicture?: PictureUpdateOneInput;
  hostingExperiences?: ExperienceUpdateManyWithoutHostInput;
}

export type PoliciesWhereUniqueInput = AtLeastOne<{
  id?: ID_Input;
}>;

export interface PlaceUpdateManyWithoutHostInput {
  create?: PlaceCreateWithoutHostInput[] | PlaceCreateWithoutHostInput;
  delete?: PlaceWhereUniqueInput[] | PlaceWhereUniqueInput;
  connect?: PlaceWhereUniqueInput[] | PlaceWhereUniqueInput;
  disconnect?: PlaceWhereUniqueInput[] | PlaceWhereUniqueInput;
  update?:
    | PlaceUpdateWithWhereUniqueWithoutHostInput[]
    | PlaceUpdateWithWhereUniqueWithoutHostInput;
  upsert?:
    | PlaceUpsertWithWhereUniqueWithoutHostInput[]
    | PlaceUpsertWithWhereUniqueWithoutHostInput;
}

export interface UserCreateWithoutNotificationsInput {
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceCreateManyWithoutHostInput;
  location?: LocationCreateOneWithoutUserInput;
  bookings?: BookingCreateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountCreateManyWithoutUserInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receivedMessages?: MessageCreateManyWithoutToInput;
  profilePicture?: PictureCreateOneInput;
  hostingExperiences?: ExperienceCreateManyWithoutHostInput;
}

export interface PlaceUpdateWithWhereUniqueWithoutHostInput {
  where: PlaceWhereUniqueInput;
  data: PlaceUpdateWithoutHostDataInput;
}

export interface NotificationCreateInput {
  type?: NOTIFICATION_TYPE;
  user: UserCreateOneWithoutNotificationsInput;
  link: String;
  readDate: DateTimeInput;
}

export interface PlaceUpdateWithoutHostDataInput {
  name?: String;
  size?: PLACE_SIZES;
  shortDescription?: String;
  description?: String;
  slug?: String;
  maxGuests?: Int;
  numBedrooms?: Int;
  numBeds?: Int;
  numBaths?: Int;
  reviews?: ReviewUpdateManyWithoutPlaceInput;
  amenities?: AmenitiesUpdateOneWithoutPlaceInput;
  pricing?: PricingUpdateOneWithoutPlaceInput;
  location?: LocationUpdateOneWithoutPlaceInput;
  views?: ViewsUpdateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsUpdateOneWithoutPlaceInput;
  policies?: PoliciesUpdateOneWithoutPlaceInput;
  houseRules?: HouseRulesUpdateOneInput;
  bookings?: BookingUpdateManyWithoutPlaceInput;
  pictures?: PictureUpdateManyInput;
  popularity?: Int;
}

export interface ExperienceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  category?: ExperienceCategoryWhereInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  host?: UserWhereInput;
  location?: LocationWhereInput;
  pricePerPerson?: Int;
  pricePerPerson_not?: Int;
  pricePerPerson_in?: Int[] | Int;
  pricePerPerson_not_in?: Int[] | Int;
  pricePerPerson_lt?: Int;
  pricePerPerson_lte?: Int;
  pricePerPerson_gt?: Int;
  pricePerPerson_gte?: Int;
  reviews_every?: ReviewWhereInput;
  reviews_some?: ReviewWhereInput;
  reviews_none?: ReviewWhereInput;
  preview?: PictureWhereInput;
  popularity?: Int;
  popularity_not?: Int;
  popularity_in?: Int[] | Int;
  popularity_not_in?: Int[] | Int;
  popularity_lt?: Int;
  popularity_lte?: Int;
  popularity_gt?: Int;
  popularity_gte?: Int;
  AND?: ExperienceWhereInput[] | ExperienceWhereInput;
  OR?: ExperienceWhereInput[] | ExperienceWhereInput;
  NOT?: ExperienceWhereInput[] | ExperienceWhereInput;
}

export interface ReviewUpdateManyWithoutPlaceInput {
  create?: ReviewCreateWithoutPlaceInput[] | ReviewCreateWithoutPlaceInput;
  delete?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  connect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  disconnect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  update?:
    | ReviewUpdateWithWhereUniqueWithoutPlaceInput[]
    | ReviewUpdateWithWhereUniqueWithoutPlaceInput;
  upsert?:
    | ReviewUpsertWithWhereUniqueWithoutPlaceInput[]
    | ReviewUpsertWithWhereUniqueWithoutPlaceInput;
}

export interface MessageCreateInput {
  from: UserCreateOneWithoutSentMessagesInput;
  to: UserCreateOneWithoutReceivedMessagesInput;
  deliveredAt: DateTimeInput;
  readAt: DateTimeInput;
}

export interface ReviewUpdateWithWhereUniqueWithoutPlaceInput {
  where: ReviewWhereUniqueInput;
  data: ReviewUpdateWithoutPlaceDataInput;
}

export type ViewsWhereUniqueInput = AtLeastOne<{
  id?: ID_Input;
}>;

export interface ReviewUpdateWithoutPlaceDataInput {
  text?: String;
  stars?: Int;
  accuracy?: Int;
  location?: Int;
  checkIn?: Int;
  value?: Int;
  cleanliness?: Int;
  communication?: Int;
  experience?: ExperienceUpdateOneWithoutReviewsInput;
}

export interface PaymentAccountUpdateWithoutCreditcardDataInput {
  type?: PAYMENT_PROVIDER;
  user?: UserUpdateOneWithoutPaymentAccountInput;
  payments?: PaymentUpdateManyWithoutPaymentMethodInput;
  paypal?: PaypalInformationUpdateOneWithoutPaymentAccountInput;
}

export interface ExperienceUpdateOneWithoutReviewsInput {
  create?: ExperienceCreateWithoutReviewsInput;
  update?: ExperienceUpdateWithoutReviewsDataInput;
  upsert?: ExperienceUpsertWithoutReviewsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ExperienceWhereUniqueInput;
}

export interface CreditCardInformationUpdateInput {
  cardNumber?: String;
  expiresOnMonth?: Int;
  expiresOnYear?: Int;
  securityCode?: String;
  firstName?: String;
  lastName?: String;
  postalCode?: String;
  country?: String;
  paymentAccount?: PaymentAccountUpdateOneWithoutCreditcardInput;
}

export interface ExperienceUpdateWithoutReviewsDataInput {
  category?: ExperienceCategoryUpdateOneWithoutExperienceInput;
  title?: String;
  host?: UserUpdateOneWithoutHostingExperiencesInput;
  location?: LocationUpdateOneWithoutExperienceInput;
  pricePerPerson?: Int;
  preview?: PictureUpdateOneInput;
  popularity?: Int;
}

export interface PaymentAccountCreateWithoutCreditcardInput {
  type?: PAYMENT_PROVIDER;
  user: UserCreateOneWithoutPaymentAccountInput;
  payments?: PaymentCreateManyWithoutPaymentMethodInput;
  paypal?: PaypalInformationCreateOneWithoutPaymentAccountInput;
}

export interface ExperienceCategoryUpdateOneWithoutExperienceInput {
  create?: ExperienceCategoryCreateWithoutExperienceInput;
  update?: ExperienceCategoryUpdateWithoutExperienceDataInput;
  upsert?: ExperienceCategoryUpsertWithoutExperienceInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ExperienceCategoryWhereUniqueInput;
}

export interface CreditCardInformationCreateInput {
  cardNumber: String;
  expiresOnMonth: Int;
  expiresOnYear: Int;
  securityCode: String;
  firstName: String;
  lastName: String;
  postalCode: String;
  country: String;
  paymentAccount?: PaymentAccountCreateOneWithoutCreditcardInput;
}

export interface ExperienceCategoryUpdateWithoutExperienceDataInput {
  mainColor?: String;
  name?: String;
}

export interface PaymentAccountUpsertWithoutPaypalInput {
  update: PaymentAccountUpdateWithoutPaypalDataInput;
  create: PaymentAccountCreateWithoutPaypalInput;
}

export interface ExperienceCategoryUpsertWithoutExperienceInput {
  update: ExperienceCategoryUpdateWithoutExperienceDataInput;
  create: ExperienceCategoryCreateWithoutExperienceInput;
}

export interface PaymentAccountUpdateOneWithoutPaypalInput {
  create?: PaymentAccountCreateWithoutPaypalInput;
  update?: PaymentAccountUpdateWithoutPaypalDataInput;
  upsert?: PaymentAccountUpsertWithoutPaypalInput;
  delete?: Boolean;
  connect?: PaymentAccountWhereUniqueInput;
}

export interface UserUpdateOneWithoutHostingExperiencesInput {
  create?: UserCreateWithoutHostingExperiencesInput;
  update?: UserUpdateWithoutHostingExperiencesDataInput;
  upsert?: UserUpsertWithoutHostingExperiencesInput;
  delete?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface PlaceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  size?: PLACE_SIZES;
  size_not?: PLACE_SIZES;
  size_in?: PLACE_SIZES[] | PLACE_SIZES;
  size_not_in?: PLACE_SIZES[] | PLACE_SIZES;
  shortDescription?: String;
  shortDescription_not?: String;
  shortDescription_in?: String[] | String;
  shortDescription_not_in?: String[] | String;
  shortDescription_lt?: String;
  shortDescription_lte?: String;
  shortDescription_gt?: String;
  shortDescription_gte?: String;
  shortDescription_contains?: String;
  shortDescription_not_contains?: String;
  shortDescription_starts_with?: String;
  shortDescription_not_starts_with?: String;
  shortDescription_ends_with?: String;
  shortDescription_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  maxGuests?: Int;
  maxGuests_not?: Int;
  maxGuests_in?: Int[] | Int;
  maxGuests_not_in?: Int[] | Int;
  maxGuests_lt?: Int;
  maxGuests_lte?: Int;
  maxGuests_gt?: Int;
  maxGuests_gte?: Int;
  numBedrooms?: Int;
  numBedrooms_not?: Int;
  numBedrooms_in?: Int[] | Int;
  numBedrooms_not_in?: Int[] | Int;
  numBedrooms_lt?: Int;
  numBedrooms_lte?: Int;
  numBedrooms_gt?: Int;
  numBedrooms_gte?: Int;
  numBeds?: Int;
  numBeds_not?: Int;
  numBeds_in?: Int[] | Int;
  numBeds_not_in?: Int[] | Int;
  numBeds_lt?: Int;
  numBeds_lte?: Int;
  numBeds_gt?: Int;
  numBeds_gte?: Int;
  numBaths?: Int;
  numBaths_not?: Int;
  numBaths_in?: Int[] | Int;
  numBaths_not_in?: Int[] | Int;
  numBaths_lt?: Int;
  numBaths_lte?: Int;
  numBaths_gt?: Int;
  numBaths_gte?: Int;
  reviews_every?: ReviewWhereInput;
  reviews_some?: ReviewWhereInput;
  reviews_none?: ReviewWhereInput;
  amenities?: AmenitiesWhereInput;
  host?: UserWhereInput;
  pricing?: PricingWhereInput;
  location?: LocationWhereInput;
  views?: ViewsWhereInput;
  guestRequirements?: GuestRequirementsWhereInput;
  policies?: PoliciesWhereInput;
  houseRules?: HouseRulesWhereInput;
  bookings_every?: BookingWhereInput;
  bookings_some?: BookingWhereInput;
  bookings_none?: BookingWhereInput;
  pictures_every?: PictureWhereInput;
  pictures_some?: PictureWhereInput;
  pictures_none?: PictureWhereInput;
  popularity?: Int;
  popularity_not?: Int;
  popularity_in?: Int[] | Int;
  popularity_not_in?: Int[] | Int;
  popularity_lt?: Int;
  popularity_lte?: Int;
  popularity_gt?: Int;
  popularity_gte?: Int;
  AND?: PlaceWhereInput[] | PlaceWhereInput;
  OR?: PlaceWhereInput[] | PlaceWhereInput;
  NOT?: PlaceWhereInput[] | PlaceWhereInput;
}

export interface UserUpdateWithoutHostingExperiencesDataInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  password?: String;
  phone?: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceUpdateManyWithoutHostInput;
  location?: LocationUpdateOneWithoutUserInput;
  bookings?: BookingUpdateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountUpdateManyWithoutUserInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receivedMessages?: MessageUpdateManyWithoutToInput;
  notifications?: NotificationUpdateManyWithoutUserInput;
  profilePicture?: PictureUpdateOneInput;
}

export interface PaymentAccountCreateWithoutPaypalInput {
  type?: PAYMENT_PROVIDER;
  user: UserCreateOneWithoutPaymentAccountInput;
  payments?: PaymentCreateManyWithoutPaymentMethodInput;
  creditcard?: CreditCardInformationCreateOneWithoutPaymentAccountInput;
}

export interface LocationUpdateOneWithoutUserInput {
  create?: LocationCreateWithoutUserInput;
  update?: LocationUpdateWithoutUserDataInput;
  upsert?: LocationUpsertWithoutUserInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: LocationWhereUniqueInput;
}

export type PictureWhereUniqueInput = AtLeastOne<{
  id?: ID_Input;
}>;

export interface LocationUpdateWithoutUserDataInput {
  lat?: Float;
  lng?: Float;
  neighbourHood?: NeighbourhoodUpdateOneWithoutLocationsInput;
  place?: PlaceUpdateOneWithoutLocationInput;
  address?: String;
  directions?: String;
  experience?: ExperienceUpdateOneWithoutLocationInput;
  restaurant?: RestaurantUpdateOneWithoutLocationInput;
}

export interface PaymentAccountUpdateInput {
  type?: PAYMENT_PROVIDER;
  user?: UserUpdateOneWithoutPaymentAccountInput;
  payments?: PaymentUpdateManyWithoutPaymentMethodInput;
  paypal?: PaypalInformationUpdateOneWithoutPaymentAccountInput;
  creditcard?: CreditCardInformationUpdateOneWithoutPaymentAccountInput;
}

export interface NeighbourhoodUpdateOneWithoutLocationsInput {
  create?: NeighbourhoodCreateWithoutLocationsInput;
  update?: NeighbourhoodUpdateWithoutLocationsDataInput;
  upsert?: NeighbourhoodUpsertWithoutLocationsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: NeighbourhoodWhereUniqueInput;
}

export type ExperienceWhereUniqueInput = AtLeastOne<{
  id?: ID_Input;
}>;

export interface NeighbourhoodUpdateWithoutLocationsDataInput {
  name?: String;
  slug?: String;
  homePreview?: PictureUpdateOneInput;
  city?: CityUpdateOneWithoutNeighbourhoodsInput;
  featured?: Boolean;
  popularity?: Int;
}

export interface PaymentCreateInput {
  serviceFee: Float;
  placePrice: Float;
  totalPrice: Float;
  booking: BookingCreateOneWithoutPaymentInput;
  paymentMethod: PaymentAccountCreateOneWithoutPaymentsInput;
}

export interface PictureUpdateOneInput {
  create?: PictureCreateInput;
  update?: PictureUpdateDataInput;
  upsert?: PictureUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PictureWhereUniqueInput;
}

export type ExperienceCategoryWhereUniqueInput = AtLeastOne<{
  id?: ID_Input;
}>;

export interface PictureUpdateDataInput {
  url?: String;
}

export interface ReviewUpdateInput {
  text?: String;
  stars?: Int;
  accuracy?: Int;
  location?: Int;
  checkIn?: Int;
  value?: Int;
  cleanliness?: Int;
  communication?: Int;
  place?: PlaceUpdateOneWithoutReviewsInput;
  experience?: ExperienceUpdateOneWithoutReviewsInput;
}

export interface PictureUpsertNestedInput {
  update: PictureUpdateDataInput;
  create: PictureCreateInput;
}

export interface PlaceUpsertWithoutAmenitiesInput {
  update: PlaceUpdateWithoutAmenitiesDataInput;
  create: PlaceCreateWithoutAmenitiesInput;
}

export interface CityUpdateOneWithoutNeighbourhoodsInput {
  create?: CityCreateWithoutNeighbourhoodsInput;
  update?: CityUpdateWithoutNeighbourhoodsDataInput;
  upsert?: CityUpsertWithoutNeighbourhoodsInput;
  delete?: Boolean;
  connect?: CityWhereUniqueInput;
}

export interface PlaceUpdateWithoutAmenitiesDataInput {
  name?: String;
  size?: PLACE_SIZES;
  shortDescription?: String;
  description?: String;
  slug?: String;
  maxGuests?: Int;
  numBedrooms?: Int;
  numBeds?: Int;
  numBaths?: Int;
  reviews?: ReviewUpdateManyWithoutPlaceInput;
  host?: UserUpdateOneWithoutOwnedPlacesInput;
  pricing?: PricingUpdateOneWithoutPlaceInput;
  location?: LocationUpdateOneWithoutPlaceInput;
  views?: ViewsUpdateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsUpdateOneWithoutPlaceInput;
  policies?: PoliciesUpdateOneWithoutPlaceInput;
  houseRules?: HouseRulesUpdateOneInput;
  bookings?: BookingUpdateManyWithoutPlaceInput;
  pictures?: PictureUpdateManyInput;
  popularity?: Int;
}

export interface CityUpdateWithoutNeighbourhoodsDataInput {
  name?: String;
}

export interface AmenitiesUpdateInput {
  place?: PlaceUpdateOneWithoutAmenitiesInput;
  elevator?: Boolean;
  petsAllowed?: Boolean;
  internet?: Boolean;
  kitchen?: Boolean;
  wirelessInternet?: Boolean;
  familyKidFriendly?: Boolean;
  freeParkingOnPremises?: Boolean;
  hotTub?: Boolean;
  pool?: Boolean;
  smokingAllowed?: Boolean;
  wheelchairAccessible?: Boolean;
  breakfast?: Boolean;
  cableTv?: Boolean;
  suitableForEvents?: Boolean;
  dryer?: Boolean;
  washer?: Boolean;
  indoorFireplace?: Boolean;
  tv?: Boolean;
  heating?: Boolean;
  hangers?: Boolean;
  iron?: Boolean;
  hairDryer?: Boolean;
  doorman?: Boolean;
  paidParkingOffPremises?: Boolean;
  freeParkingOnStreet?: Boolean;
  gym?: Boolean;
  airConditioning?: Boolean;
  shampoo?: Boolean;
  essentials?: Boolean;
  laptopFriendlyWorkspace?: Boolean;
  privateEntrance?: Boolean;
  buzzerWirelessIntercom?: Boolean;
  babyBath?: Boolean;
  babyMonitor?: Boolean;
  babysitterRecommendations?: Boolean;
  bathtub?: Boolean;
  changingTable?: Boolean;
  childrensBooksAndToys?: Boolean;
  childrensDinnerware?: Boolean;
  crib?: Boolean;
}

export interface CityUpsertWithoutNeighbourhoodsInput {
  update: CityUpdateWithoutNeighbourhoodsDataInput;
  create: CityCreateWithoutNeighbourhoodsInput;
}

export type ReviewWhereUniqueInput = AtLeastOne<{
  id?: ID_Input;
}>;

export interface NeighbourhoodUpsertWithoutLocationsInput {
  update: NeighbourhoodUpdateWithoutLocationsDataInput;
  create: NeighbourhoodCreateWithoutLocationsInput;
}

export interface AmenitiesCreateInput {
  place: PlaceCreateOneWithoutAmenitiesInput;
  elevator?: Boolean;
  petsAllowed?: Boolean;
  internet?: Boolean;
  kitchen?: Boolean;
  wirelessInternet?: Boolean;
  familyKidFriendly?: Boolean;
  freeParkingOnPremises?: Boolean;
  hotTub?: Boolean;
  pool?: Boolean;
  smokingAllowed?: Boolean;
  wheelchairAccessible?: Boolean;
  breakfast?: Boolean;
  cableTv?: Boolean;
  suitableForEvents?: Boolean;
  dryer?: Boolean;
  washer?: Boolean;
  indoorFireplace?: Boolean;
  tv?: Boolean;
  heating?: Boolean;
  hangers?: Boolean;
  iron?: Boolean;
  hairDryer?: Boolean;
  doorman?: Boolean;
  paidParkingOffPremises?: Boolean;
  freeParkingOnStreet?: Boolean;
  gym?: Boolean;
  airConditioning?: Boolean;
  shampoo?: Boolean;
  essentials?: Boolean;
  laptopFriendlyWorkspace?: Boolean;
  privateEntrance?: Boolean;
  buzzerWirelessIntercom?: Boolean;
  babyBath?: Boolean;
  babyMonitor?: Boolean;
  babysitterRecommendations?: Boolean;
  bathtub?: Boolean;
  changingTable?: Boolean;
  childrensBooksAndToys?: Boolean;
  childrensDinnerware?: Boolean;
  crib?: Boolean;
}

export interface PlaceUpdateOneWithoutLocationInput {
  create?: PlaceCreateWithoutLocationInput;
  update?: PlaceUpdateWithoutLocationDataInput;
  upsert?: PlaceUpsertWithoutLocationInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PlaceWhereUniqueInput;
}

export type BookingWhereUniqueInput = AtLeastOne<{
  id?: ID_Input;
}>;

export interface PlaceUpdateWithoutLocationDataInput {
  name?: String;
  size?: PLACE_SIZES;
  shortDescription?: String;
  description?: String;
  slug?: String;
  maxGuests?: Int;
  numBedrooms?: Int;
  numBeds?: Int;
  numBaths?: Int;
  reviews?: ReviewUpdateManyWithoutPlaceInput;
  amenities?: AmenitiesUpdateOneWithoutPlaceInput;
  host?: UserUpdateOneWithoutOwnedPlacesInput;
  pricing?: PricingUpdateOneWithoutPlaceInput;
  views?: ViewsUpdateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsUpdateOneWithoutPlaceInput;
  policies?: PoliciesUpdateOneWithoutPlaceInput;
  houseRules?: HouseRulesUpdateOneInput;
  bookings?: BookingUpdateManyWithoutPlaceInput;
  pictures?: PictureUpdateManyInput;
  popularity?: Int;
}

export interface ExperienceUpdateOneWithoutCategoryInput {
  create?: ExperienceCreateWithoutCategoryInput;
  update?: ExperienceUpdateWithoutCategoryDataInput;
  upsert?: ExperienceUpsertWithoutCategoryInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ExperienceWhereUniqueInput;
}

export interface AmenitiesUpdateOneWithoutPlaceInput {
  create?: AmenitiesCreateWithoutPlaceInput;
  update?: AmenitiesUpdateWithoutPlaceDataInput;
  upsert?: AmenitiesUpsertWithoutPlaceInput;
  delete?: Boolean;
  connect?: AmenitiesWhereUniqueInput;
}

export type PaymentWhereUniqueInput = AtLeastOne<{
  id?: ID_Input;
}>;

export interface AmenitiesUpdateWithoutPlaceDataInput {
  elevator?: Boolean;
  petsAllowed?: Boolean;
  internet?: Boolean;
  kitchen?: Boolean;
  wirelessInternet?: Boolean;
  familyKidFriendly?: Boolean;
  freeParkingOnPremises?: Boolean;
  hotTub?: Boolean;
  pool?: Boolean;
  smokingAllowed?: Boolean;
  wheelchairAccessible?: Boolean;
  breakfast?: Boolean;
  cableTv?: Boolean;
  suitableForEvents?: Boolean;
  dryer?: Boolean;
  washer?: Boolean;
  indoorFireplace?: Boolean;
  tv?: Boolean;
  heating?: Boolean;
  hangers?: Boolean;
  iron?: Boolean;
  hairDryer?: Boolean;
  doorman?: Boolean;
  paidParkingOffPremises?: Boolean;
  freeParkingOnStreet?: Boolean;
  gym?: Boolean;
  airConditioning?: Boolean;
  shampoo?: Boolean;
  essentials?: Boolean;
  laptopFriendlyWorkspace?: Boolean;
  privateEntrance?: Boolean;
  buzzerWirelessIntercom?: Boolean;
  babyBath?: Boolean;
  babyMonitor?: Boolean;
  babysitterRecommendations?: Boolean;
  bathtub?: Boolean;
  changingTable?: Boolean;
  childrensBooksAndToys?: Boolean;
  childrensDinnerware?: Boolean;
  crib?: Boolean;
}

export interface ExperienceCreateOneWithoutCategoryInput {
  create?: ExperienceCreateWithoutCategoryInput;
  connect?: ExperienceWhereUniqueInput;
}

export interface PlaceUpsertWithoutViewsInput {
  update: PlaceUpdateWithoutViewsDataInput;
  create: PlaceCreateWithoutViewsInput;
}

export type PaymentAccountWhereUniqueInput = AtLeastOne<{
  id?: ID_Input;
}>;

export interface UserUpdateOneWithoutOwnedPlacesInput {
  create?: UserCreateWithoutOwnedPlacesInput;
  update?: UserUpdateWithoutOwnedPlacesDataInput;
  upsert?: UserUpsertWithoutOwnedPlacesInput;
  delete?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface ExperienceCreateInput {
  category?: ExperienceCategoryCreateOneWithoutExperienceInput;
  title: String;
  host: UserCreateOneWithoutHostingExperiencesInput;
  location: LocationCreateOneWithoutExperienceInput;
  pricePerPerson: Int;
  reviews?: ReviewCreateManyWithoutExperienceInput;
  preview: PictureCreateOneInput;
  popularity: Int;
}

export interface UserUpdateWithoutOwnedPlacesDataInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  password?: String;
  phone?: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  location?: LocationUpdateOneWithoutUserInput;
  bookings?: BookingUpdateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountUpdateManyWithoutUserInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receivedMessages?: MessageUpdateManyWithoutToInput;
  notifications?: NotificationUpdateManyWithoutUserInput;
  profilePicture?: PictureUpdateOneInput;
  hostingExperiences?: ExperienceUpdateManyWithoutHostInput;
}

export type PaypalInformationWhereUniqueInput = AtLeastOne<{
  id?: ID_Input;
}>;

export interface BookingUpdateManyWithoutBookeeInput {
  create?: BookingCreateWithoutBookeeInput[] | BookingCreateWithoutBookeeInput;
  delete?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  connect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  disconnect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  update?:
    | BookingUpdateWithWhereUniqueWithoutBookeeInput[]
    | BookingUpdateWithWhereUniqueWithoutBookeeInput;
  upsert?:
    | BookingUpsertWithWhereUniqueWithoutBookeeInput[]
    | BookingUpsertWithWhereUniqueWithoutBookeeInput;
}

export interface NeighbourhoodUpdateWithoutCityDataInput {
  locations?: LocationUpdateManyWithoutNeighbourHoodInput;
  name?: String;
  slug?: String;
  homePreview?: PictureUpdateOneInput;
  featured?: Boolean;
  popularity?: Int;
}

export interface BookingUpdateWithWhereUniqueWithoutBookeeInput {
  where: BookingWhereUniqueInput;
  data: BookingUpdateWithoutBookeeDataInput;
}

export interface NeighbourhoodUpdateManyWithoutCityInput {
  create?:
    | NeighbourhoodCreateWithoutCityInput[]
    | NeighbourhoodCreateWithoutCityInput;
  delete?: NeighbourhoodWhereUniqueInput[] | NeighbourhoodWhereUniqueInput;
  connect?: NeighbourhoodWhereUniqueInput[] | NeighbourhoodWhereUniqueInput;
  disconnect?: NeighbourhoodWhereUniqueInput[] | NeighbourhoodWhereUniqueInput;
  update?:
    | NeighbourhoodUpdateWithWhereUniqueWithoutCityInput[]
    | NeighbourhoodUpdateWithWhereUniqueWithoutCityInput;
  upsert?:
    | NeighbourhoodUpsertWithWhereUniqueWithoutCityInput[]
    | NeighbourhoodUpsertWithWhereUniqueWithoutCityInput;
}

export interface BookingUpdateWithoutBookeeDataInput {
  place?: PlaceUpdateOneWithoutBookingsInput;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
  payment?: PaymentUpdateOneWithoutBookingInput;
}

export interface CityUpdateInput {
  name?: String;
  neighbourhoods?: NeighbourhoodUpdateManyWithoutCityInput;
}

export interface PlaceUpdateOneWithoutBookingsInput {
  create?: PlaceCreateWithoutBookingsInput;
  update?: PlaceUpdateWithoutBookingsDataInput;
  upsert?: PlaceUpsertWithoutBookingsInput;
  delete?: Boolean;
  connect?: PlaceWhereUniqueInput;
}

export interface NeighbourhoodCreateManyWithoutCityInput {
  create?:
    | NeighbourhoodCreateWithoutCityInput[]
    | NeighbourhoodCreateWithoutCityInput;
  connect?: NeighbourhoodWhereUniqueInput[] | NeighbourhoodWhereUniqueInput;
}

export interface PlaceUpdateWithoutBookingsDataInput {
  name?: String;
  size?: PLACE_SIZES;
  shortDescription?: String;
  description?: String;
  slug?: String;
  maxGuests?: Int;
  numBedrooms?: Int;
  numBeds?: Int;
  numBaths?: Int;
  reviews?: ReviewUpdateManyWithoutPlaceInput;
  amenities?: AmenitiesUpdateOneWithoutPlaceInput;
  host?: UserUpdateOneWithoutOwnedPlacesInput;
  pricing?: PricingUpdateOneWithoutPlaceInput;
  location?: LocationUpdateOneWithoutPlaceInput;
  views?: ViewsUpdateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsUpdateOneWithoutPlaceInput;
  policies?: PoliciesUpdateOneWithoutPlaceInput;
  houseRules?: HouseRulesUpdateOneInput;
  pictures?: PictureUpdateManyInput;
  popularity?: Int;
}

export type MessageWhereUniqueInput = AtLeastOne<{
  id?: ID_Input;
}>;

export interface PricingUpdateOneWithoutPlaceInput {
  create?: PricingCreateWithoutPlaceInput;
  update?: PricingUpdateWithoutPlaceDataInput;
  upsert?: PricingUpsertWithoutPlaceInput;
  delete?: Boolean;
  connect?: PricingWhereUniqueInput;
}

export interface LocationUpdateWithoutNeighbourHoodDataInput {
  lat?: Float;
  lng?: Float;
  user?: UserUpdateOneWithoutLocationInput;
  place?: PlaceUpdateOneWithoutLocationInput;
  address?: String;
  directions?: String;
  experience?: ExperienceUpdateOneWithoutLocationInput;
  restaurant?: RestaurantUpdateOneWithoutLocationInput;
}

export interface PricingUpdateWithoutPlaceDataInput {
  monthlyDiscount?: Int;
  weeklyDiscount?: Int;
  perNight?: Int;
  smartPricing?: Boolean;
  basePrice?: Int;
  averageWeekly?: Int;
  averageMonthly?: Int;
  cleaningFee?: Int;
  securityDeposit?: Int;
  extraGuests?: Int;
  weekendPricing?: Int;
  currency?: CURRENCY;
}

export type NotificationWhereUniqueInput = AtLeastOne<{
  id?: ID_Input;
}>;

export interface PricingUpsertWithoutPlaceInput {
  update: PricingUpdateWithoutPlaceDataInput;
  create: PricingCreateWithoutPlaceInput;
}

export interface NeighbourhoodUpdateInput {
  locations?: LocationUpdateManyWithoutNeighbourHoodInput;
  name?: String;
  slug?: String;
  homePreview?: PictureUpdateOneInput;
  city?: CityUpdateOneWithoutNeighbourhoodsInput;
  featured?: Boolean;
  popularity?: Int;
}

export interface LocationUpdateOneWithoutPlaceInput {
  create?: LocationCreateWithoutPlaceInput;
  update?: LocationUpdateWithoutPlaceDataInput;
  upsert?: LocationUpsertWithoutPlaceInput;
  delete?: Boolean;
  connect?: LocationWhereUniqueInput;
}

export type RestaurantWhereUniqueInput = AtLeastOne<{
  id?: ID_Input;
}>;

export interface LocationUpdateWithoutPlaceDataInput {
  lat?: Float;
  lng?: Float;
  neighbourHood?: NeighbourhoodUpdateOneWithoutLocationsInput;
  user?: UserUpdateOneWithoutLocationInput;
  address?: String;
  directions?: String;
  experience?: ExperienceUpdateOneWithoutLocationInput;
  restaurant?: RestaurantUpdateOneWithoutLocationInput;
}

export interface NeighbourhoodCreateInput {
  locations?: LocationCreateManyWithoutNeighbourHoodInput;
  name: String;
  slug: String;
  homePreview?: PictureCreateOneInput;
  city: CityCreateOneWithoutNeighbourhoodsInput;
  featured: Boolean;
  popularity: Int;
}

export interface UserUpdateOneWithoutLocationInput {
  create?: UserCreateWithoutLocationInput;
  update?: UserUpdateWithoutLocationDataInput;
  upsert?: UserUpsertWithoutLocationInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface LocationCreateInput {
  lat: Float;
  lng: Float;
  neighbourHood?: NeighbourhoodCreateOneWithoutLocationsInput;
  user?: UserCreateOneWithoutLocationInput;
  place?: PlaceCreateOneWithoutLocationInput;
  address?: String;
  directions?: String;
  experience?: ExperienceCreateOneWithoutLocationInput;
  restaurant?: RestaurantCreateOneWithoutLocationInput;
}

export interface UserUpdateWithoutLocationDataInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  password?: String;
  phone?: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceUpdateManyWithoutHostInput;
  bookings?: BookingUpdateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountUpdateManyWithoutUserInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receivedMessages?: MessageUpdateManyWithoutToInput;
  notifications?: NotificationUpdateManyWithoutUserInput;
  profilePicture?: PictureUpdateOneInput;
  hostingExperiences?: ExperienceUpdateManyWithoutHostInput;
}

export interface UserCreateInput {
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceCreateManyWithoutHostInput;
  location?: LocationCreateOneWithoutUserInput;
  bookings?: BookingCreateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountCreateManyWithoutUserInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receivedMessages?: MessageCreateManyWithoutToInput;
  notifications?: NotificationCreateManyWithoutUserInput;
  profilePicture?: PictureCreateOneInput;
  hostingExperiences?: ExperienceCreateManyWithoutHostInput;
}

export interface ViewsWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  lastWeek?: Int;
  lastWeek_not?: Int;
  lastWeek_in?: Int[] | Int;
  lastWeek_not_in?: Int[] | Int;
  lastWeek_lt?: Int;
  lastWeek_lte?: Int;
  lastWeek_gt?: Int;
  lastWeek_gte?: Int;
  place?: PlaceWhereInput;
  AND?: ViewsWhereInput[] | ViewsWhereInput;
  OR?: ViewsWhereInput[] | ViewsWhereInput;
  NOT?: ViewsWhereInput[] | ViewsWhereInput;
}

export interface PlaceCreateWithoutHostInput {
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  reviews?: ReviewCreateManyWithoutPlaceInput;
  amenities: AmenitiesCreateOneWithoutPlaceInput;
  pricing: PricingCreateOneWithoutPlaceInput;
  location: LocationCreateOneWithoutPlaceInput;
  views: ViewsCreateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsCreateOneWithoutPlaceInput;
  policies?: PoliciesCreateOneWithoutPlaceInput;
  houseRules?: HouseRulesCreateOneInput;
  bookings?: BookingCreateManyWithoutPlaceInput;
  pictures?: PictureCreateManyInput;
  popularity: Int;
}

export interface PoliciesWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  checkInStartTime?: Float;
  checkInStartTime_not?: Float;
  checkInStartTime_in?: Float[] | Float;
  checkInStartTime_not_in?: Float[] | Float;
  checkInStartTime_lt?: Float;
  checkInStartTime_lte?: Float;
  checkInStartTime_gt?: Float;
  checkInStartTime_gte?: Float;
  checkInEndTime?: Float;
  checkInEndTime_not?: Float;
  checkInEndTime_in?: Float[] | Float;
  checkInEndTime_not_in?: Float[] | Float;
  checkInEndTime_lt?: Float;
  checkInEndTime_lte?: Float;
  checkInEndTime_gt?: Float;
  checkInEndTime_gte?: Float;
  checkoutTime?: Float;
  checkoutTime_not?: Float;
  checkoutTime_in?: Float[] | Float;
  checkoutTime_not_in?: Float[] | Float;
  checkoutTime_lt?: Float;
  checkoutTime_lte?: Float;
  checkoutTime_gt?: Float;
  checkoutTime_gte?: Float;
  place?: PlaceWhereInput;
  AND?: PoliciesWhereInput[] | PoliciesWhereInput;
  OR?: PoliciesWhereInput[] | PoliciesWhereInput;
  NOT?: PoliciesWhereInput[] | PoliciesWhereInput;
}

export interface ReviewCreateWithoutPlaceInput {
  text: String;
  stars: Int;
  accuracy: Int;
  location: Int;
  checkIn: Int;
  value: Int;
  cleanliness: Int;
  communication: Int;
  experience?: ExperienceCreateOneWithoutReviewsInput;
}

export interface AmenitiesWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  place?: PlaceWhereInput;
  elevator?: Boolean;
  elevator_not?: Boolean;
  petsAllowed?: Boolean;
  petsAllowed_not?: Boolean;
  internet?: Boolean;
  internet_not?: Boolean;
  kitchen?: Boolean;
  kitchen_not?: Boolean;
  wirelessInternet?: Boolean;
  wirelessInternet_not?: Boolean;
  familyKidFriendly?: Boolean;
  familyKidFriendly_not?: Boolean;
  freeParkingOnPremises?: Boolean;
  freeParkingOnPremises_not?: Boolean;
  hotTub?: Boolean;
  hotTub_not?: Boolean;
  pool?: Boolean;
  pool_not?: Boolean;
  smokingAllowed?: Boolean;
  smokingAllowed_not?: Boolean;
  wheelchairAccessible?: Boolean;
  wheelchairAccessible_not?: Boolean;
  breakfast?: Boolean;
  breakfast_not?: Boolean;
  cableTv?: Boolean;
  cableTv_not?: Boolean;
  suitableForEvents?: Boolean;
  suitableForEvents_not?: Boolean;
  dryer?: Boolean;
  dryer_not?: Boolean;
  washer?: Boolean;
  washer_not?: Boolean;
  indoorFireplace?: Boolean;
  indoorFireplace_not?: Boolean;
  tv?: Boolean;
  tv_not?: Boolean;
  heating?: Boolean;
  heating_not?: Boolean;
  hangers?: Boolean;
  hangers_not?: Boolean;
  iron?: Boolean;
  iron_not?: Boolean;
  hairDryer?: Boolean;
  hairDryer_not?: Boolean;
  doorman?: Boolean;
  doorman_not?: Boolean;
  paidParkingOffPremises?: Boolean;
  paidParkingOffPremises_not?: Boolean;
  freeParkingOnStreet?: Boolean;
  freeParkingOnStreet_not?: Boolean;
  gym?: Boolean;
  gym_not?: Boolean;
  airConditioning?: Boolean;
  airConditioning_not?: Boolean;
  shampoo?: Boolean;
  shampoo_not?: Boolean;
  essentials?: Boolean;
  essentials_not?: Boolean;
  laptopFriendlyWorkspace?: Boolean;
  laptopFriendlyWorkspace_not?: Boolean;
  privateEntrance?: Boolean;
  privateEntrance_not?: Boolean;
  buzzerWirelessIntercom?: Boolean;
  buzzerWirelessIntercom_not?: Boolean;
  babyBath?: Boolean;
  babyBath_not?: Boolean;
  babyMonitor?: Boolean;
  babyMonitor_not?: Boolean;
  babysitterRecommendations?: Boolean;
  babysitterRecommendations_not?: Boolean;
  bathtub?: Boolean;
  bathtub_not?: Boolean;
  changingTable?: Boolean;
  changingTable_not?: Boolean;
  childrensBooksAndToys?: Boolean;
  childrensBooksAndToys_not?: Boolean;
  childrensDinnerware?: Boolean;
  childrensDinnerware_not?: Boolean;
  crib?: Boolean;
  crib_not?: Boolean;
  AND?: AmenitiesWhereInput[] | AmenitiesWhereInput;
  OR?: AmenitiesWhereInput[] | AmenitiesWhereInput;
  NOT?: AmenitiesWhereInput[] | AmenitiesWhereInput;
}

export interface ExperienceCreateWithoutReviewsInput {
  category?: ExperienceCategoryCreateOneWithoutExperienceInput;
  title: String;
  host: UserCreateOneWithoutHostingExperiencesInput;
  location: LocationCreateOneWithoutExperienceInput;
  pricePerPerson: Int;
  preview: PictureCreateOneInput;
  popularity: Int;
}

export interface NotificationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  type?: NOTIFICATION_TYPE;
  type_not?: NOTIFICATION_TYPE;
  type_in?: NOTIFICATION_TYPE[] | NOTIFICATION_TYPE;
  type_not_in?: NOTIFICATION_TYPE[] | NOTIFICATION_TYPE;
  user?: UserWhereInput;
  link?: String;
  link_not?: String;
  link_in?: String[] | String;
  link_not_in?: String[] | String;
  link_lt?: String;
  link_lte?: String;
  link_gt?: String;
  link_gte?: String;
  link_contains?: String;
  link_not_contains?: String;
  link_starts_with?: String;
  link_not_starts_with?: String;
  link_ends_with?: String;
  link_not_ends_with?: String;
  readDate?: DateTimeInput;
  readDate_not?: DateTimeInput;
  readDate_in?: DateTimeInput[] | DateTimeInput;
  readDate_not_in?: DateTimeInput[] | DateTimeInput;
  readDate_lt?: DateTimeInput;
  readDate_lte?: DateTimeInput;
  readDate_gt?: DateTimeInput;
  readDate_gte?: DateTimeInput;
  AND?: NotificationWhereInput[] | NotificationWhereInput;
  OR?: NotificationWhereInput[] | NotificationWhereInput;
  NOT?: NotificationWhereInput[] | NotificationWhereInput;
}

export interface ExperienceCategoryCreateWithoutExperienceInput {
  mainColor?: String;
  name: String;
}

export interface PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput {
  where: PaymentWhereUniqueInput;
  data: PaymentUpdateWithoutPaymentMethodDataInput;
}

export interface UserCreateWithoutHostingExperiencesInput {
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceCreateManyWithoutHostInput;
  location?: LocationCreateOneWithoutUserInput;
  bookings?: BookingCreateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountCreateManyWithoutUserInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receivedMessages?: MessageCreateManyWithoutToInput;
  notifications?: NotificationCreateManyWithoutUserInput;
  profilePicture?: PictureCreateOneInput;
}

export interface PaymentUpdateWithoutPaymentMethodDataInput {
  serviceFee?: Float;
  placePrice?: Float;
  totalPrice?: Float;
  booking?: BookingUpdateOneWithoutPaymentInput;
}

export interface LocationCreateWithoutUserInput {
  lat: Float;
  lng: Float;
  neighbourHood?: NeighbourhoodCreateOneWithoutLocationsInput;
  place?: PlaceCreateOneWithoutLocationInput;
  address?: String;
  directions?: String;
  experience?: ExperienceCreateOneWithoutLocationInput;
  restaurant?: RestaurantCreateOneWithoutLocationInput;
}

export interface BookingUpdateOneWithoutPaymentInput {
  create?: BookingCreateWithoutPaymentInput;
  update?: BookingUpdateWithoutPaymentDataInput;
  upsert?: BookingUpsertWithoutPaymentInput;
  delete?: Boolean;
  connect?: BookingWhereUniqueInput;
}

export interface NeighbourhoodCreateWithoutLocationsInput {
  name: String;
  slug: String;
  homePreview?: PictureCreateOneInput;
  city: CityCreateOneWithoutNeighbourhoodsInput;
  featured: Boolean;
  popularity: Int;
}

export interface BookingUpdateWithoutPaymentDataInput {
  bookee?: UserUpdateOneWithoutBookingsInput;
  place?: PlaceUpdateOneWithoutBookingsInput;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
}

export interface PictureCreateInput {
  url: String;
}

export interface UserUpdateOneWithoutBookingsInput {
  create?: UserCreateWithoutBookingsInput;
  update?: UserUpdateWithoutBookingsDataInput;
  upsert?: UserUpsertWithoutBookingsInput;
  delete?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface CityCreateWithoutNeighbourhoodsInput {
  name: String;
}

export interface UserUpdateWithoutBookingsDataInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  password?: String;
  phone?: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceUpdateManyWithoutHostInput;
  location?: LocationUpdateOneWithoutUserInput;
  paymentAccount?: PaymentAccountUpdateManyWithoutUserInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receivedMessages?: MessageUpdateManyWithoutToInput;
  notifications?: NotificationUpdateManyWithoutUserInput;
  profilePicture?: PictureUpdateOneInput;
  hostingExperiences?: ExperienceUpdateManyWithoutHostInput;
}

export interface PlaceCreateWithoutLocationInput {
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  reviews?: ReviewCreateManyWithoutPlaceInput;
  amenities: AmenitiesCreateOneWithoutPlaceInput;
  host: UserCreateOneWithoutOwnedPlacesInput;
  pricing: PricingCreateOneWithoutPlaceInput;
  views: ViewsCreateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsCreateOneWithoutPlaceInput;
  policies?: PoliciesCreateOneWithoutPlaceInput;
  houseRules?: HouseRulesCreateOneInput;
  bookings?: BookingCreateManyWithoutPlaceInput;
  pictures?: PictureCreateManyInput;
  popularity: Int;
}

export interface MessageUpdateManyWithoutFromInput {
  create?: MessageCreateWithoutFromInput[] | MessageCreateWithoutFromInput;
  delete?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  connect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  disconnect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  update?:
    | MessageUpdateWithWhereUniqueWithoutFromInput[]
    | MessageUpdateWithWhereUniqueWithoutFromInput;
  upsert?:
    | MessageUpsertWithWhereUniqueWithoutFromInput[]
    | MessageUpsertWithWhereUniqueWithoutFromInput;
}

export interface AmenitiesCreateWithoutPlaceInput {
  elevator?: Boolean;
  petsAllowed?: Boolean;
  internet?: Boolean;
  kitchen?: Boolean;
  wirelessInternet?: Boolean;
  familyKidFriendly?: Boolean;
  freeParkingOnPremises?: Boolean;
  hotTub?: Boolean;
  pool?: Boolean;
  smokingAllowed?: Boolean;
  wheelchairAccessible?: Boolean;
  breakfast?: Boolean;
  cableTv?: Boolean;
  suitableForEvents?: Boolean;
  dryer?: Boolean;
  washer?: Boolean;
  indoorFireplace?: Boolean;
  tv?: Boolean;
  heating?: Boolean;
  hangers?: Boolean;
  iron?: Boolean;
  hairDryer?: Boolean;
  doorman?: Boolean;
  paidParkingOffPremises?: Boolean;
  freeParkingOnStreet?: Boolean;
  gym?: Boolean;
  airConditioning?: Boolean;
  shampoo?: Boolean;
  essentials?: Boolean;
  laptopFriendlyWorkspace?: Boolean;
  privateEntrance?: Boolean;
  buzzerWirelessIntercom?: Boolean;
  babyBath?: Boolean;
  babyMonitor?: Boolean;
  babysitterRecommendations?: Boolean;
  bathtub?: Boolean;
  changingTable?: Boolean;
  childrensBooksAndToys?: Boolean;
  childrensDinnerware?: Boolean;
  crib?: Boolean;
}

export interface MessageUpdateWithWhereUniqueWithoutFromInput {
  where: MessageWhereUniqueInput;
  data: MessageUpdateWithoutFromDataInput;
}

export interface UserCreateWithoutOwnedPlacesInput {
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  location?: LocationCreateOneWithoutUserInput;
  bookings?: BookingCreateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountCreateManyWithoutUserInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receivedMessages?: MessageCreateManyWithoutToInput;
  notifications?: NotificationCreateManyWithoutUserInput;
  profilePicture?: PictureCreateOneInput;
  hostingExperiences?: ExperienceCreateManyWithoutHostInput;
}

export interface MessageUpdateWithoutFromDataInput {
  to?: UserUpdateOneWithoutReceivedMessagesInput;
  deliveredAt?: DateTimeInput;
  readAt?: DateTimeInput;
}

export interface BookingCreateWithoutBookeeInput {
  place: PlaceCreateOneWithoutBookingsInput;
  startDate: DateTimeInput;
  endDate: DateTimeInput;
  payment?: PaymentCreateOneWithoutBookingInput;
}

export interface UserUpdateOneWithoutReceivedMessagesInput {
  create?: UserCreateWithoutReceivedMessagesInput;
  update?: UserUpdateWithoutReceivedMessagesDataInput;
  upsert?: UserUpsertWithoutReceivedMessagesInput;
  delete?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface PlaceCreateWithoutBookingsInput {
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  reviews?: ReviewCreateManyWithoutPlaceInput;
  amenities: AmenitiesCreateOneWithoutPlaceInput;
  host: UserCreateOneWithoutOwnedPlacesInput;
  pricing: PricingCreateOneWithoutPlaceInput;
  location: LocationCreateOneWithoutPlaceInput;
  views: ViewsCreateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsCreateOneWithoutPlaceInput;
  policies?: PoliciesCreateOneWithoutPlaceInput;
  houseRules?: HouseRulesCreateOneInput;
  pictures?: PictureCreateManyInput;
  popularity: Int;
}

export interface UserUpdateWithoutReceivedMessagesDataInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  password?: String;
  phone?: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceUpdateManyWithoutHostInput;
  location?: LocationUpdateOneWithoutUserInput;
  bookings?: BookingUpdateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountUpdateManyWithoutUserInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  notifications?: NotificationUpdateManyWithoutUserInput;
  profilePicture?: PictureUpdateOneInput;
  hostingExperiences?: ExperienceUpdateManyWithoutHostInput;
}

export interface PricingCreateWithoutPlaceInput {
  monthlyDiscount?: Int;
  weeklyDiscount?: Int;
  perNight: Int;
  smartPricing?: Boolean;
  basePrice: Int;
  averageWeekly: Int;
  averageMonthly: Int;
  cleaningFee?: Int;
  securityDeposit?: Int;
  extraGuests?: Int;
  weekendPricing?: Int;
  currency?: CURRENCY;
}

export interface NotificationUpdateManyWithoutUserInput {
  create?:
    | NotificationCreateWithoutUserInput[]
    | NotificationCreateWithoutUserInput;
  delete?: NotificationWhereUniqueInput[] | NotificationWhereUniqueInput;
  connect?: NotificationWhereUniqueInput[] | NotificationWhereUniqueInput;
  disconnect?: NotificationWhereUniqueInput[] | NotificationWhereUniqueInput;
  update?:
    | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    | NotificationUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    | NotificationUpsertWithWhereUniqueWithoutUserInput;
}

export interface LocationCreateWithoutPlaceInput {
  lat: Float;
  lng: Float;
  neighbourHood?: NeighbourhoodCreateOneWithoutLocationsInput;
  user?: UserCreateOneWithoutLocationInput;
  address?: String;
  directions?: String;
  experience?: ExperienceCreateOneWithoutLocationInput;
  restaurant?: RestaurantCreateOneWithoutLocationInput;
}

export interface NotificationUpdateWithWhereUniqueWithoutUserInput {
  where: NotificationWhereUniqueInput;
  data: NotificationUpdateWithoutUserDataInput;
}

export interface UserCreateWithoutLocationInput {
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceCreateManyWithoutHostInput;
  bookings?: BookingCreateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountCreateManyWithoutUserInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receivedMessages?: MessageCreateManyWithoutToInput;
  notifications?: NotificationCreateManyWithoutUserInput;
  profilePicture?: PictureCreateOneInput;
  hostingExperiences?: ExperienceCreateManyWithoutHostInput;
}

export interface NotificationUpdateWithoutUserDataInput {
  type?: NOTIFICATION_TYPE;
  link?: String;
  readDate?: DateTimeInput;
}

export interface PaymentAccountCreateWithoutUserInput {
  type?: PAYMENT_PROVIDER;
  payments?: PaymentCreateManyWithoutPaymentMethodInput;
  paypal?: PaypalInformationCreateOneWithoutPaymentAccountInput;
  creditcard?: CreditCardInformationCreateOneWithoutPaymentAccountInput;
}

export interface NotificationUpsertWithWhereUniqueWithoutUserInput {
  where: NotificationWhereUniqueInput;
  update: NotificationUpdateWithoutUserDataInput;
  create: NotificationCreateWithoutUserInput;
}

export interface PaymentCreateWithoutPaymentMethodInput {
  serviceFee: Float;
  placePrice: Float;
  totalPrice: Float;
  booking: BookingCreateOneWithoutPaymentInput;
}

export interface ExperienceUpdateManyWithoutHostInput {
  create?:
    | ExperienceCreateWithoutHostInput[]
    | ExperienceCreateWithoutHostInput;
  delete?: ExperienceWhereUniqueInput[] | ExperienceWhereUniqueInput;
  connect?: ExperienceWhereUniqueInput[] | ExperienceWhereUniqueInput;
  disconnect?: ExperienceWhereUniqueInput[] | ExperienceWhereUniqueInput;
  update?:
    | ExperienceUpdateWithWhereUniqueWithoutHostInput[]
    | ExperienceUpdateWithWhereUniqueWithoutHostInput;
  upsert?:
    | ExperienceUpsertWithWhereUniqueWithoutHostInput[]
    | ExperienceUpsertWithWhereUniqueWithoutHostInput;
}

export interface BookingCreateWithoutPaymentInput {
  bookee: UserCreateOneWithoutBookingsInput;
  place: PlaceCreateOneWithoutBookingsInput;
  startDate: DateTimeInput;
  endDate: DateTimeInput;
}

export interface ExperienceUpdateWithWhereUniqueWithoutHostInput {
  where: ExperienceWhereUniqueInput;
  data: ExperienceUpdateWithoutHostDataInput;
}

export interface UserCreateWithoutBookingsInput {
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceCreateManyWithoutHostInput;
  location?: LocationCreateOneWithoutUserInput;
  paymentAccount?: PaymentAccountCreateManyWithoutUserInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receivedMessages?: MessageCreateManyWithoutToInput;
  notifications?: NotificationCreateManyWithoutUserInput;
  profilePicture?: PictureCreateOneInput;
  hostingExperiences?: ExperienceCreateManyWithoutHostInput;
}

export interface ExperienceUpdateWithoutHostDataInput {
  category?: ExperienceCategoryUpdateOneWithoutExperienceInput;
  title?: String;
  location?: LocationUpdateOneWithoutExperienceInput;
  pricePerPerson?: Int;
  reviews?: ReviewUpdateManyWithoutExperienceInput;
  preview?: PictureUpdateOneInput;
  popularity?: Int;
}

export interface MessageCreateWithoutFromInput {
  to: UserCreateOneWithoutReceivedMessagesInput;
  deliveredAt: DateTimeInput;
  readAt: DateTimeInput;
}

export interface LocationUpdateOneWithoutExperienceInput {
  create?: LocationCreateWithoutExperienceInput;
  update?: LocationUpdateWithoutExperienceDataInput;
  upsert?: LocationUpsertWithoutExperienceInput;
  delete?: Boolean;
  connect?: LocationWhereUniqueInput;
}

export interface UserCreateWithoutReceivedMessagesInput {
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceCreateManyWithoutHostInput;
  location?: LocationCreateOneWithoutUserInput;
  bookings?: BookingCreateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountCreateManyWithoutUserInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  notifications?: NotificationCreateManyWithoutUserInput;
  profilePicture?: PictureCreateOneInput;
  hostingExperiences?: ExperienceCreateManyWithoutHostInput;
}

export interface LocationUpdateWithoutExperienceDataInput {
  lat?: Float;
  lng?: Float;
  neighbourHood?: NeighbourhoodUpdateOneWithoutLocationsInput;
  user?: UserUpdateOneWithoutLocationInput;
  place?: PlaceUpdateOneWithoutLocationInput;
  address?: String;
  directions?: String;
  restaurant?: RestaurantUpdateOneWithoutLocationInput;
}

export interface NotificationCreateWithoutUserInput {
  type?: NOTIFICATION_TYPE;
  link: String;
  readDate: DateTimeInput;
}

export interface RestaurantUpdateOneWithoutLocationInput {
  create?: RestaurantCreateWithoutLocationInput;
  update?: RestaurantUpdateWithoutLocationDataInput;
  upsert?: RestaurantUpsertWithoutLocationInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: RestaurantWhereUniqueInput;
}

export interface ExperienceCreateWithoutHostInput {
  category?: ExperienceCategoryCreateOneWithoutExperienceInput;
  title: String;
  location: LocationCreateOneWithoutExperienceInput;
  pricePerPerson: Int;
  reviews?: ReviewCreateManyWithoutExperienceInput;
  preview: PictureCreateOneInput;
  popularity: Int;
}

export interface RestaurantUpdateWithoutLocationDataInput {
  title?: String;
  avgPricePerPerson?: Int;
  pictures?: PictureUpdateManyInput;
  isCurated?: Boolean;
  slug?: String;
  popularity?: Int;
}

export interface LocationCreateWithoutExperienceInput {
  lat: Float;
  lng: Float;
  neighbourHood?: NeighbourhoodCreateOneWithoutLocationsInput;
  user?: UserCreateOneWithoutLocationInput;
  place?: PlaceCreateOneWithoutLocationInput;
  address?: String;
  directions?: String;
  restaurant?: RestaurantCreateOneWithoutLocationInput;
}

export interface PictureUpdateManyInput {
  create?: PictureCreateInput[] | PictureCreateInput;
  delete?: PictureWhereUniqueInput[] | PictureWhereUniqueInput;
  connect?: PictureWhereUniqueInput[] | PictureWhereUniqueInput;
  disconnect?: PictureWhereUniqueInput[] | PictureWhereUniqueInput;
  update?:
    | PictureUpdateWithWhereUniqueNestedInput[]
    | PictureUpdateWithWhereUniqueNestedInput;
  upsert?:
    | PictureUpsertWithWhereUniqueNestedInput[]
    | PictureUpsertWithWhereUniqueNestedInput;
}

export interface RestaurantCreateWithoutLocationInput {
  title: String;
  avgPricePerPerson: Int;
  pictures?: PictureCreateManyInput;
  isCurated?: Boolean;
  slug: String;
  popularity: Int;
}

export interface PictureUpdateWithWhereUniqueNestedInput {
  where: PictureWhereUniqueInput;
  data: PictureUpdateDataInput;
}

export interface ReviewCreateManyWithoutExperienceInput {
  create?:
    | ReviewCreateWithoutExperienceInput[]
    | ReviewCreateWithoutExperienceInput;
  connect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
}

export interface PictureUpsertWithWhereUniqueNestedInput {
  where: PictureWhereUniqueInput;
  update: PictureUpdateDataInput;
  create: PictureCreateInput;
}

export interface PlaceCreateOneWithoutReviewsInput {
  create?: PlaceCreateWithoutReviewsInput;
  connect?: PlaceWhereUniqueInput;
}

export interface RestaurantUpsertWithoutLocationInput {
  update: RestaurantUpdateWithoutLocationDataInput;
  create: RestaurantCreateWithoutLocationInput;
}

export interface RestaurantSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RestaurantWhereInput;
  AND?: RestaurantSubscriptionWhereInput[] | RestaurantSubscriptionWhereInput;
  OR?: RestaurantSubscriptionWhereInput[] | RestaurantSubscriptionWhereInput;
  NOT?: RestaurantSubscriptionWhereInput[] | RestaurantSubscriptionWhereInput;
}

export interface LocationUpsertWithoutExperienceInput {
  update: LocationUpdateWithoutExperienceDataInput;
  create: LocationCreateWithoutExperienceInput;
}

export interface PaypalInformationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PaypalInformationWhereInput;
  AND?:
    | PaypalInformationSubscriptionWhereInput[]
    | PaypalInformationSubscriptionWhereInput;
  OR?:
    | PaypalInformationSubscriptionWhereInput[]
    | PaypalInformationSubscriptionWhereInput;
  NOT?:
    | PaypalInformationSubscriptionWhereInput[]
    | PaypalInformationSubscriptionWhereInput;
}

export interface ReviewUpdateManyWithoutExperienceInput {
  create?:
    | ReviewCreateWithoutExperienceInput[]
    | ReviewCreateWithoutExperienceInput;
  delete?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  connect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  disconnect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  update?:
    | ReviewUpdateWithWhereUniqueWithoutExperienceInput[]
    | ReviewUpdateWithWhereUniqueWithoutExperienceInput;
  upsert?:
    | ReviewUpsertWithWhereUniqueWithoutExperienceInput[]
    | ReviewUpsertWithWhereUniqueWithoutExperienceInput;
}

export interface CreditCardInformationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  cardNumber?: String;
  cardNumber_not?: String;
  cardNumber_in?: String[] | String;
  cardNumber_not_in?: String[] | String;
  cardNumber_lt?: String;
  cardNumber_lte?: String;
  cardNumber_gt?: String;
  cardNumber_gte?: String;
  cardNumber_contains?: String;
  cardNumber_not_contains?: String;
  cardNumber_starts_with?: String;
  cardNumber_not_starts_with?: String;
  cardNumber_ends_with?: String;
  cardNumber_not_ends_with?: String;
  expiresOnMonth?: Int;
  expiresOnMonth_not?: Int;
  expiresOnMonth_in?: Int[] | Int;
  expiresOnMonth_not_in?: Int[] | Int;
  expiresOnMonth_lt?: Int;
  expiresOnMonth_lte?: Int;
  expiresOnMonth_gt?: Int;
  expiresOnMonth_gte?: Int;
  expiresOnYear?: Int;
  expiresOnYear_not?: Int;
  expiresOnYear_in?: Int[] | Int;
  expiresOnYear_not_in?: Int[] | Int;
  expiresOnYear_lt?: Int;
  expiresOnYear_lte?: Int;
  expiresOnYear_gt?: Int;
  expiresOnYear_gte?: Int;
  securityCode?: String;
  securityCode_not?: String;
  securityCode_in?: String[] | String;
  securityCode_not_in?: String[] | String;
  securityCode_lt?: String;
  securityCode_lte?: String;
  securityCode_gt?: String;
  securityCode_gte?: String;
  securityCode_contains?: String;
  securityCode_not_contains?: String;
  securityCode_starts_with?: String;
  securityCode_not_starts_with?: String;
  securityCode_ends_with?: String;
  securityCode_not_ends_with?: String;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  postalCode?: String;
  postalCode_not?: String;
  postalCode_in?: String[] | String;
  postalCode_not_in?: String[] | String;
  postalCode_lt?: String;
  postalCode_lte?: String;
  postalCode_gt?: String;
  postalCode_gte?: String;
  postalCode_contains?: String;
  postalCode_not_contains?: String;
  postalCode_starts_with?: String;
  postalCode_not_starts_with?: String;
  postalCode_ends_with?: String;
  postalCode_not_ends_with?: String;
  country?: String;
  country_not?: String;
  country_in?: String[] | String;
  country_not_in?: String[] | String;
  country_lt?: String;
  country_lte?: String;
  country_gt?: String;
  country_gte?: String;
  country_contains?: String;
  country_not_contains?: String;
  country_starts_with?: String;
  country_not_starts_with?: String;
  country_ends_with?: String;
  country_not_ends_with?: String;
  paymentAccount?: PaymentAccountWhereInput;
  AND?: CreditCardInformationWhereInput[] | CreditCardInformationWhereInput;
  OR?: CreditCardInformationWhereInput[] | CreditCardInformationWhereInput;
  NOT?: CreditCardInformationWhereInput[] | CreditCardInformationWhereInput;
}

export interface ReviewUpdateWithWhereUniqueWithoutExperienceInput {
  where: ReviewWhereUniqueInput;
  data: ReviewUpdateWithoutExperienceDataInput;
}

export interface AmenitiesSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AmenitiesWhereInput;
  AND?: AmenitiesSubscriptionWhereInput[] | AmenitiesSubscriptionWhereInput;
  OR?: AmenitiesSubscriptionWhereInput[] | AmenitiesSubscriptionWhereInput;
  NOT?: AmenitiesSubscriptionWhereInput[] | AmenitiesSubscriptionWhereInput;
}

export interface ReviewUpdateWithoutExperienceDataInput {
  text?: String;
  stars?: Int;
  accuracy?: Int;
  location?: Int;
  checkIn?: Int;
  value?: Int;
  cleanliness?: Int;
  communication?: Int;
  place?: PlaceUpdateOneWithoutReviewsInput;
}

export interface CitySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CityWhereInput;
  AND?: CitySubscriptionWhereInput[] | CitySubscriptionWhereInput;
  OR?: CitySubscriptionWhereInput[] | CitySubscriptionWhereInput;
  NOT?: CitySubscriptionWhereInput[] | CitySubscriptionWhereInput;
}

export interface PlaceUpdateOneWithoutReviewsInput {
  create?: PlaceCreateWithoutReviewsInput;
  update?: PlaceUpdateWithoutReviewsDataInput;
  upsert?: PlaceUpsertWithoutReviewsInput;
  delete?: Boolean;
  connect?: PlaceWhereUniqueInput;
}

export interface ViewsSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ViewsWhereInput;
  AND?: ViewsSubscriptionWhereInput[] | ViewsSubscriptionWhereInput;
  OR?: ViewsSubscriptionWhereInput[] | ViewsSubscriptionWhereInput;
  NOT?: ViewsSubscriptionWhereInput[] | ViewsSubscriptionWhereInput;
}

export interface PlaceUpdateWithoutReviewsDataInput {
  name?: String;
  size?: PLACE_SIZES;
  shortDescription?: String;
  description?: String;
  slug?: String;
  maxGuests?: Int;
  numBedrooms?: Int;
  numBeds?: Int;
  numBaths?: Int;
  amenities?: AmenitiesUpdateOneWithoutPlaceInput;
  host?: UserUpdateOneWithoutOwnedPlacesInput;
  pricing?: PricingUpdateOneWithoutPlaceInput;
  location?: LocationUpdateOneWithoutPlaceInput;
  views?: ViewsUpdateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsUpdateOneWithoutPlaceInput;
  policies?: PoliciesUpdateOneWithoutPlaceInput;
  houseRules?: HouseRulesUpdateOneInput;
  bookings?: BookingUpdateManyWithoutPlaceInput;
  pictures?: PictureUpdateManyInput;
  popularity?: Int;
}

export interface BookingWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  bookee?: UserWhereInput;
  place?: PlaceWhereInput;
  startDate?: DateTimeInput;
  startDate_not?: DateTimeInput;
  startDate_in?: DateTimeInput[] | DateTimeInput;
  startDate_not_in?: DateTimeInput[] | DateTimeInput;
  startDate_lt?: DateTimeInput;
  startDate_lte?: DateTimeInput;
  startDate_gt?: DateTimeInput;
  startDate_gte?: DateTimeInput;
  endDate?: DateTimeInput;
  endDate_not?: DateTimeInput;
  endDate_in?: DateTimeInput[] | DateTimeInput;
  endDate_not_in?: DateTimeInput[] | DateTimeInput;
  endDate_lt?: DateTimeInput;
  endDate_lte?: DateTimeInput;
  endDate_gt?: DateTimeInput;
  endDate_gte?: DateTimeInput;
  payment?: PaymentWhereInput;
  AND?: BookingWhereInput[] | BookingWhereInput;
  OR?: BookingWhereInput[] | BookingWhereInput;
  NOT?: BookingWhereInput[] | BookingWhereInput;
}

export interface ViewsUpdateOneWithoutPlaceInput {
  create?: ViewsCreateWithoutPlaceInput;
  update?: ViewsUpdateWithoutPlaceDataInput;
  upsert?: ViewsUpsertWithoutPlaceInput;
  delete?: Boolean;
  connect?: ViewsWhereUniqueInput;
}

export interface PricingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PricingWhereInput;
  AND?: PricingSubscriptionWhereInput[] | PricingSubscriptionWhereInput;
  OR?: PricingSubscriptionWhereInput[] | PricingSubscriptionWhereInput;
  NOT?: PricingSubscriptionWhereInput[] | PricingSubscriptionWhereInput;
}

export interface ViewsUpdateWithoutPlaceDataInput {
  lastWeek?: Int;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface ViewsUpsertWithoutPlaceInput {
  update: ViewsUpdateWithoutPlaceDataInput;
  create: ViewsCreateWithoutPlaceInput;
}

export interface LocationUpdateOneWithoutRestaurantInput {
  create?: LocationCreateWithoutRestaurantInput;
  update?: LocationUpdateWithoutRestaurantDataInput;
  upsert?: LocationUpsertWithoutRestaurantInput;
  delete?: Boolean;
  connect?: LocationWhereUniqueInput;
}

export interface GuestRequirementsUpdateOneWithoutPlaceInput {
  create?: GuestRequirementsCreateWithoutPlaceInput;
  update?: GuestRequirementsUpdateWithoutPlaceDataInput;
  upsert?: GuestRequirementsUpsertWithoutPlaceInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: GuestRequirementsWhereUniqueInput;
}

export interface LocationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  lat?: Float;
  lat_not?: Float;
  lat_in?: Float[] | Float;
  lat_not_in?: Float[] | Float;
  lat_lt?: Float;
  lat_lte?: Float;
  lat_gt?: Float;
  lat_gte?: Float;
  lng?: Float;
  lng_not?: Float;
  lng_in?: Float[] | Float;
  lng_not_in?: Float[] | Float;
  lng_lt?: Float;
  lng_lte?: Float;
  lng_gt?: Float;
  lng_gte?: Float;
  neighbourHood?: NeighbourhoodWhereInput;
  user?: UserWhereInput;
  place?: PlaceWhereInput;
  address?: String;
  address_not?: String;
  address_in?: String[] | String;
  address_not_in?: String[] | String;
  address_lt?: String;
  address_lte?: String;
  address_gt?: String;
  address_gte?: String;
  address_contains?: String;
  address_not_contains?: String;
  address_starts_with?: String;
  address_not_starts_with?: String;
  address_ends_with?: String;
  address_not_ends_with?: String;
  directions?: String;
  directions_not?: String;
  directions_in?: String[] | String;
  directions_not_in?: String[] | String;
  directions_lt?: String;
  directions_lte?: String;
  directions_gt?: String;
  directions_gte?: String;
  directions_contains?: String;
  directions_not_contains?: String;
  directions_starts_with?: String;
  directions_not_starts_with?: String;
  directions_ends_with?: String;
  directions_not_ends_with?: String;
  experience?: ExperienceWhereInput;
  restaurant?: RestaurantWhereInput;
  AND?: LocationWhereInput[] | LocationWhereInput;
  OR?: LocationWhereInput[] | LocationWhereInput;
  NOT?: LocationWhereInput[] | LocationWhereInput;
}

export interface GuestRequirementsUpdateWithoutPlaceDataInput {
  govIssuedId?: Boolean;
  recommendationsFromOtherHosts?: Boolean;
  guestTripInformation?: Boolean;
}

export type GuestRequirementsWhereUniqueInput = AtLeastOne<{
  id?: ID_Input;
}>;

export interface GuestRequirementsUpsertWithoutPlaceInput {
  update: GuestRequirementsUpdateWithoutPlaceDataInput;
  create: GuestRequirementsCreateWithoutPlaceInput;
}

export interface NotificationUpdateInput {
  type?: NOTIFICATION_TYPE;
  user?: UserUpdateOneWithoutNotificationsInput;
  link?: String;
  readDate?: DateTimeInput;
}

export interface PoliciesUpdateOneWithoutPlaceInput {
  create?: PoliciesCreateWithoutPlaceInput;
  update?: PoliciesUpdateWithoutPlaceDataInput;
  upsert?: PoliciesUpsertWithoutPlaceInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PoliciesWhereUniqueInput;
}

export interface UserCreateOneWithoutNotificationsInput {
  create?: UserCreateWithoutNotificationsInput;
  connect?: UserWhereUniqueInput;
}

export interface PoliciesUpdateWithoutPlaceDataInput {
  checkInStartTime?: Float;
  checkInEndTime?: Float;
  checkoutTime?: Float;
}

export interface MessageUpdateInput {
  from?: UserUpdateOneWithoutSentMessagesInput;
  to?: UserUpdateOneWithoutReceivedMessagesInput;
  deliveredAt?: DateTimeInput;
  readAt?: DateTimeInput;
}

export interface PoliciesUpsertWithoutPlaceInput {
  update: PoliciesUpdateWithoutPlaceDataInput;
  create: PoliciesCreateWithoutPlaceInput;
}

export interface ReviewWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  stars?: Int;
  stars_not?: Int;
  stars_in?: Int[] | Int;
  stars_not_in?: Int[] | Int;
  stars_lt?: Int;
  stars_lte?: Int;
  stars_gt?: Int;
  stars_gte?: Int;
  accuracy?: Int;
  accuracy_not?: Int;
  accuracy_in?: Int[] | Int;
  accuracy_not_in?: Int[] | Int;
  accuracy_lt?: Int;
  accuracy_lte?: Int;
  accuracy_gt?: Int;
  accuracy_gte?: Int;
  location?: Int;
  location_not?: Int;
  location_in?: Int[] | Int;
  location_not_in?: Int[] | Int;
  location_lt?: Int;
  location_lte?: Int;
  location_gt?: Int;
  location_gte?: Int;
  checkIn?: Int;
  checkIn_not?: Int;
  checkIn_in?: Int[] | Int;
  checkIn_not_in?: Int[] | Int;
  checkIn_lt?: Int;
  checkIn_lte?: Int;
  checkIn_gt?: Int;
  checkIn_gte?: Int;
  value?: Int;
  value_not?: Int;
  value_in?: Int[] | Int;
  value_not_in?: Int[] | Int;
  value_lt?: Int;
  value_lte?: Int;
  value_gt?: Int;
  value_gte?: Int;
  cleanliness?: Int;
  cleanliness_not?: Int;
  cleanliness_in?: Int[] | Int;
  cleanliness_not_in?: Int[] | Int;
  cleanliness_lt?: Int;
  cleanliness_lte?: Int;
  cleanliness_gt?: Int;
  cleanliness_gte?: Int;
  communication?: Int;
  communication_not?: Int;
  communication_in?: Int[] | Int;
  communication_not_in?: Int[] | Int;
  communication_lt?: Int;
  communication_lte?: Int;
  communication_gt?: Int;
  communication_gte?: Int;
  place?: PlaceWhereInput;
  experience?: ExperienceWhereInput;
  AND?: ReviewWhereInput[] | ReviewWhereInput;
  OR?: ReviewWhereInput[] | ReviewWhereInput;
  NOT?: ReviewWhereInput[] | ReviewWhereInput;
}

export interface HouseRulesUpdateOneInput {
  create?: HouseRulesCreateInput;
  update?: HouseRulesUpdateDataInput;
  upsert?: HouseRulesUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: HouseRulesWhereUniqueInput;
}

export type LocationWhereUniqueInput = AtLeastOne<{
  id?: ID_Input;
}>;

export interface HouseRulesUpdateDataInput {
  suitableForChildren?: Boolean;
  suitableForInfants?: Boolean;
  petsAllowed?: Boolean;
  smokingAllowed?: Boolean;
  partiesAndEventsAllowed?: Boolean;
  additionalRules?: String;
}

export type NeighbourhoodWhereUniqueInput = AtLeastOne<{
  id?: ID_Input;
}>;

export interface HouseRulesUpsertNestedInput {
  update: HouseRulesUpdateDataInput;
  create: HouseRulesCreateInput;
}

export type CityWhereUniqueInput = AtLeastOne<{
  id?: ID_Input;
}>;

export interface BookingUpdateManyWithoutPlaceInput {
  create?: BookingCreateWithoutPlaceInput[] | BookingCreateWithoutPlaceInput;
  delete?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  connect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  disconnect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  update?:
    | BookingUpdateWithWhereUniqueWithoutPlaceInput[]
    | BookingUpdateWithWhereUniqueWithoutPlaceInput;
  upsert?:
    | BookingUpsertWithWhereUniqueWithoutPlaceInput[]
    | BookingUpsertWithWhereUniqueWithoutPlaceInput;
}

export interface PaymentAccountCreateOneWithoutPaypalInput {
  create?: PaymentAccountCreateWithoutPaypalInput;
  connect?: PaymentAccountWhereUniqueInput;
}

export interface BookingUpdateWithWhereUniqueWithoutPlaceInput {
  where: BookingWhereUniqueInput;
  data: BookingUpdateWithoutPlaceDataInput;
}

export interface PaymentAccountCreateInput {
  type?: PAYMENT_PROVIDER;
  user: UserCreateOneWithoutPaymentAccountInput;
  payments?: PaymentCreateManyWithoutPaymentMethodInput;
  paypal?: PaypalInformationCreateOneWithoutPaymentAccountInput;
  creditcard?: CreditCardInformationCreateOneWithoutPaymentAccountInput;
}

export interface BookingUpdateWithoutPlaceDataInput {
  bookee?: UserUpdateOneWithoutBookingsInput;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
  payment?: PaymentUpdateOneWithoutBookingInput;
}

export interface BookingUpdateInput {
  bookee?: UserUpdateOneWithoutBookingsInput;
  place?: PlaceUpdateOneWithoutBookingsInput;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
  payment?: PaymentUpdateOneWithoutBookingInput;
}

export interface PaymentUpdateOneWithoutBookingInput {
  create?: PaymentCreateWithoutBookingInput;
  update?: PaymentUpdateWithoutBookingDataInput;
  upsert?: PaymentUpsertWithoutBookingInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PaymentWhereUniqueInput;
}

export interface ReviewCreateInput {
  text: String;
  stars: Int;
  accuracy: Int;
  location: Int;
  checkIn: Int;
  value: Int;
  cleanliness: Int;
  communication: Int;
  place: PlaceCreateOneWithoutReviewsInput;
  experience?: ExperienceCreateOneWithoutReviewsInput;
}

export interface PaymentUpdateWithoutBookingDataInput {
  serviceFee?: Float;
  placePrice?: Float;
  totalPrice?: Float;
  paymentMethod?: PaymentAccountUpdateOneWithoutPaymentsInput;
}

export interface PlaceUpdateOneWithoutAmenitiesInput {
  create?: PlaceCreateWithoutAmenitiesInput;
  update?: PlaceUpdateWithoutAmenitiesDataInput;
  upsert?: PlaceUpsertWithoutAmenitiesInput;
  delete?: Boolean;
  connect?: PlaceWhereUniqueInput;
}

export interface PaymentAccountUpdateOneWithoutPaymentsInput {
  create?: PaymentAccountCreateWithoutPaymentsInput;
  update?: PaymentAccountUpdateWithoutPaymentsDataInput;
  upsert?: PaymentAccountUpsertWithoutPaymentsInput;
  delete?: Boolean;
  connect?: PaymentAccountWhereUniqueInput;
}

export interface PlaceCreateOneWithoutAmenitiesInput {
  create?: PlaceCreateWithoutAmenitiesInput;
  connect?: PlaceWhereUniqueInput;
}

export interface PaymentAccountUpdateWithoutPaymentsDataInput {
  type?: PAYMENT_PROVIDER;
  user?: UserUpdateOneWithoutPaymentAccountInput;
  paypal?: PaypalInformationUpdateOneWithoutPaymentAccountInput;
  creditcard?: CreditCardInformationUpdateOneWithoutPaymentAccountInput;
}

export interface ExperienceUpdateWithoutCategoryDataInput {
  title?: String;
  host?: UserUpdateOneWithoutHostingExperiencesInput;
  location?: LocationUpdateOneWithoutExperienceInput;
  pricePerPerson?: Int;
  reviews?: ReviewUpdateManyWithoutExperienceInput;
  preview?: PictureUpdateOneInput;
  popularity?: Int;
}

export interface UserUpdateOneWithoutPaymentAccountInput {
  create?: UserCreateWithoutPaymentAccountInput;
  update?: UserUpdateWithoutPaymentAccountDataInput;
  upsert?: UserUpsertWithoutPaymentAccountInput;
  delete?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface ExperienceCreateWithoutCategoryInput {
  title: String;
  host: UserCreateOneWithoutHostingExperiencesInput;
  location: LocationCreateOneWithoutExperienceInput;
  pricePerPerson: Int;
  reviews?: ReviewCreateManyWithoutExperienceInput;
  preview: PictureCreateOneInput;
  popularity: Int;
}

export interface UserUpdateWithoutPaymentAccountDataInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  password?: String;
  phone?: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceUpdateManyWithoutHostInput;
  location?: LocationUpdateOneWithoutUserInput;
  bookings?: BookingUpdateManyWithoutBookeeInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receivedMessages?: MessageUpdateManyWithoutToInput;
  notifications?: NotificationUpdateManyWithoutUserInput;
  profilePicture?: PictureUpdateOneInput;
  hostingExperiences?: ExperienceUpdateManyWithoutHostInput;
}

export interface ExperienceUpdateInput {
  category?: ExperienceCategoryUpdateOneWithoutExperienceInput;
  title?: String;
  host?: UserUpdateOneWithoutHostingExperiencesInput;
  location?: LocationUpdateOneWithoutExperienceInput;
  pricePerPerson?: Int;
  reviews?: ReviewUpdateManyWithoutExperienceInput;
  preview?: PictureUpdateOneInput;
  popularity?: Int;
}

export interface MessageUpdateManyWithoutToInput {
  create?: MessageCreateWithoutToInput[] | MessageCreateWithoutToInput;
  delete?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  connect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  disconnect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  update?:
    | MessageUpdateWithWhereUniqueWithoutToInput[]
    | MessageUpdateWithWhereUniqueWithoutToInput;
  upsert?:
    | MessageUpsertWithWhereUniqueWithoutToInput[]
    | MessageUpsertWithWhereUniqueWithoutToInput;
}

export interface NeighbourhoodUpsertWithWhereUniqueWithoutCityInput {
  where: NeighbourhoodWhereUniqueInput;
  update: NeighbourhoodUpdateWithoutCityDataInput;
  create: NeighbourhoodCreateWithoutCityInput;
}

export interface MessageUpdateWithWhereUniqueWithoutToInput {
  where: MessageWhereUniqueInput;
  data: MessageUpdateWithoutToDataInput;
}

export type CreditCardInformationWhereUniqueInput = AtLeastOne<{
  id?: ID_Input;
}>;

export interface MessageUpdateWithoutToDataInput {
  from?: UserUpdateOneWithoutSentMessagesInput;
  deliveredAt?: DateTimeInput;
  readAt?: DateTimeInput;
}

export interface CityCreateInput {
  name: String;
  neighbourhoods?: NeighbourhoodCreateManyWithoutCityInput;
}

export interface UserUpdateOneWithoutSentMessagesInput {
  create?: UserCreateWithoutSentMessagesInput;
  update?: UserUpdateWithoutSentMessagesDataInput;
  upsert?: UserUpsertWithoutSentMessagesInput;
  delete?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface LocationUpdateWithWhereUniqueWithoutNeighbourHoodInput {
  where: LocationWhereUniqueInput;
  data: LocationUpdateWithoutNeighbourHoodDataInput;
}

export interface UserUpdateWithoutSentMessagesDataInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  password?: String;
  phone?: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceUpdateManyWithoutHostInput;
  location?: LocationUpdateOneWithoutUserInput;
  bookings?: BookingUpdateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountUpdateManyWithoutUserInput;
  receivedMessages?: MessageUpdateManyWithoutToInput;
  notifications?: NotificationUpdateManyWithoutUserInput;
  profilePicture?: PictureUpdateOneInput;
  hostingExperiences?: ExperienceUpdateManyWithoutHostInput;
}

export interface LocationCreateWithoutNeighbourHoodInput {
  lat: Float;
  lng: Float;
  user?: UserCreateOneWithoutLocationInput;
  place?: PlaceCreateOneWithoutLocationInput;
  address?: String;
  directions?: String;
  experience?: ExperienceCreateOneWithoutLocationInput;
  restaurant?: RestaurantCreateOneWithoutLocationInput;
}

export interface UserUpsertWithoutSentMessagesInput {
  update: UserUpdateWithoutSentMessagesDataInput;
  create: UserCreateWithoutSentMessagesInput;
}

export interface LocationUpdateInput {
  lat?: Float;
  lng?: Float;
  neighbourHood?: NeighbourhoodUpdateOneWithoutLocationsInput;
  user?: UserUpdateOneWithoutLocationInput;
  place?: PlaceUpdateOneWithoutLocationInput;
  address?: String;
  directions?: String;
  experience?: ExperienceUpdateOneWithoutLocationInput;
  restaurant?: RestaurantUpdateOneWithoutLocationInput;
}

export interface MessageUpsertWithWhereUniqueWithoutToInput {
  where: MessageWhereUniqueInput;
  update: MessageUpdateWithoutToDataInput;
  create: MessageCreateWithoutToInput;
}

export interface PlaceCreateManyWithoutHostInput {
  create?: PlaceCreateWithoutHostInput[] | PlaceCreateWithoutHostInput;
  connect?: PlaceWhereUniqueInput[] | PlaceWhereUniqueInput;
}

export interface UserUpsertWithoutPaymentAccountInput {
  update: UserUpdateWithoutPaymentAccountDataInput;
  create: UserCreateWithoutPaymentAccountInput;
}

export interface ExperienceCreateOneWithoutReviewsInput {
  create?: ExperienceCreateWithoutReviewsInput;
  connect?: ExperienceWhereUniqueInput;
}

export interface PaypalInformationUpdateOneWithoutPaymentAccountInput {
  create?: PaypalInformationCreateWithoutPaymentAccountInput;
  update?: PaypalInformationUpdateWithoutPaymentAccountDataInput;
  upsert?: PaypalInformationUpsertWithoutPaymentAccountInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PaypalInformationWhereUniqueInput;
}

export interface UserCreateOneWithoutHostingExperiencesInput {
  create?: UserCreateWithoutHostingExperiencesInput;
  connect?: UserWhereUniqueInput;
}

export interface PaypalInformationUpdateWithoutPaymentAccountDataInput {
  email?: String;
}

export interface NeighbourhoodCreateOneWithoutLocationsInput {
  create?: NeighbourhoodCreateWithoutLocationsInput;
  connect?: NeighbourhoodWhereUniqueInput;
}

export interface PaypalInformationUpsertWithoutPaymentAccountInput {
  update: PaypalInformationUpdateWithoutPaymentAccountDataInput;
  create: PaypalInformationCreateWithoutPaymentAccountInput;
}

export interface CityCreateOneWithoutNeighbourhoodsInput {
  create?: CityCreateWithoutNeighbourhoodsInput;
  connect?: CityWhereUniqueInput;
}

export interface CreditCardInformationUpdateOneWithoutPaymentAccountInput {
  create?: CreditCardInformationCreateWithoutPaymentAccountInput;
  update?: CreditCardInformationUpdateWithoutPaymentAccountDataInput;
  upsert?: CreditCardInformationUpsertWithoutPaymentAccountInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CreditCardInformationWhereUniqueInput;
}

export interface AmenitiesCreateOneWithoutPlaceInput {
  create?: AmenitiesCreateWithoutPlaceInput;
  connect?: AmenitiesWhereUniqueInput;
}

export interface CreditCardInformationUpdateWithoutPaymentAccountDataInput {
  cardNumber?: String;
  expiresOnMonth?: Int;
  expiresOnYear?: Int;
  securityCode?: String;
  firstName?: String;
  lastName?: String;
  postalCode?: String;
  country?: String;
}

export interface BookingCreateManyWithoutBookeeInput {
  create?: BookingCreateWithoutBookeeInput[] | BookingCreateWithoutBookeeInput;
  connect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
}

export interface CreditCardInformationUpsertWithoutPaymentAccountInput {
  update: CreditCardInformationUpdateWithoutPaymentAccountDataInput;
  create: CreditCardInformationCreateWithoutPaymentAccountInput;
}

export interface PricingCreateOneWithoutPlaceInput {
  create?: PricingCreateWithoutPlaceInput;
  connect?: PricingWhereUniqueInput;
}

export interface PaymentAccountUpsertWithoutPaymentsInput {
  update: PaymentAccountUpdateWithoutPaymentsDataInput;
  create: PaymentAccountCreateWithoutPaymentsInput;
}

export interface UserCreateOneWithoutLocationInput {
  create?: UserCreateWithoutLocationInput;
  connect?: UserWhereUniqueInput;
}

export interface PaymentUpsertWithoutBookingInput {
  update: PaymentUpdateWithoutBookingDataInput;
  create: PaymentCreateWithoutBookingInput;
}

export interface PaymentCreateManyWithoutPaymentMethodInput {
  create?:
    | PaymentCreateWithoutPaymentMethodInput[]
    | PaymentCreateWithoutPaymentMethodInput;
  connect?: PaymentWhereUniqueInput[] | PaymentWhereUniqueInput;
}

export interface BookingUpsertWithWhereUniqueWithoutPlaceInput {
  where: BookingWhereUniqueInput;
  update: BookingUpdateWithoutPlaceDataInput;
  create: BookingCreateWithoutPlaceInput;
}

export interface UserCreateOneWithoutBookingsInput {
  create?: UserCreateWithoutBookingsInput;
  connect?: UserWhereUniqueInput;
}

export interface PlaceUpsertWithoutReviewsInput {
  update: PlaceUpdateWithoutReviewsDataInput;
  create: PlaceCreateWithoutReviewsInput;
}

export interface UserCreateOneWithoutReceivedMessagesInput {
  create?: UserCreateWithoutReceivedMessagesInput;
  connect?: UserWhereUniqueInput;
}

export interface ReviewUpsertWithWhereUniqueWithoutExperienceInput {
  where: ReviewWhereUniqueInput;
  update: ReviewUpdateWithoutExperienceDataInput;
  create: ReviewCreateWithoutExperienceInput;
}

export interface ExperienceCreateManyWithoutHostInput {
  create?:
    | ExperienceCreateWithoutHostInput[]
    | ExperienceCreateWithoutHostInput;
  connect?: ExperienceWhereUniqueInput[] | ExperienceWhereUniqueInput;
}

export interface ExperienceUpsertWithWhereUniqueWithoutHostInput {
  where: ExperienceWhereUniqueInput;
  update: ExperienceUpdateWithoutHostDataInput;
  create: ExperienceCreateWithoutHostInput;
}

export interface RestaurantCreateOneWithoutLocationInput {
  create?: RestaurantCreateWithoutLocationInput;
  connect?: RestaurantWhereUniqueInput;
}

export interface UserUpsertWithoutReceivedMessagesInput {
  update: UserUpdateWithoutReceivedMessagesDataInput;
  create: UserCreateWithoutReceivedMessagesInput;
}

export interface ReviewCreateWithoutExperienceInput {
  text: String;
  stars: Int;
  accuracy: Int;
  location: Int;
  checkIn: Int;
  value: Int;
  cleanliness: Int;
  communication: Int;
  place: PlaceCreateOneWithoutReviewsInput;
}

export interface MessageUpsertWithWhereUniqueWithoutFromInput {
  where: MessageWhereUniqueInput;
  update: MessageUpdateWithoutFromDataInput;
  create: MessageCreateWithoutFromInput;
}

export interface MessageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MessageWhereInput;
  AND?: MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput;
  OR?: MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput;
  NOT?: MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput;
}

export interface UserUpsertWithoutBookingsInput {
  update: UserUpdateWithoutBookingsDataInput;
  create: UserCreateWithoutBookingsInput;
}

export interface PaypalInformationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  paymentAccount?: PaymentAccountWhereInput;
  AND?: PaypalInformationWhereInput[] | PaypalInformationWhereInput;
  OR?: PaypalInformationWhereInput[] | PaypalInformationWhereInput;
  NOT?: PaypalInformationWhereInput[] | PaypalInformationWhereInput;
}

export interface BookingUpsertWithoutPaymentInput {
  update: BookingUpdateWithoutPaymentDataInput;
  create: BookingCreateWithoutPaymentInput;
}

export interface NeighbourhoodSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: NeighbourhoodWhereInput;
  AND?:
    | NeighbourhoodSubscriptionWhereInput[]
    | NeighbourhoodSubscriptionWhereInput;
  OR?:
    | NeighbourhoodSubscriptionWhereInput[]
    | NeighbourhoodSubscriptionWhereInput;
  NOT?:
    | NeighbourhoodSubscriptionWhereInput[]
    | NeighbourhoodSubscriptionWhereInput;
}

export interface PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput {
  where: PaymentWhereUniqueInput;
  update: PaymentUpdateWithoutPaymentMethodDataInput;
  create: PaymentCreateWithoutPaymentMethodInput;
}

export interface GuestRequirementsSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GuestRequirementsWhereInput;
  AND?:
    | GuestRequirementsSubscriptionWhereInput[]
    | GuestRequirementsSubscriptionWhereInput;
  OR?:
    | GuestRequirementsSubscriptionWhereInput[]
    | GuestRequirementsSubscriptionWhereInput;
  NOT?:
    | GuestRequirementsSubscriptionWhereInput[]
    | GuestRequirementsSubscriptionWhereInput;
}

export interface PaymentAccountUpsertWithWhereUniqueWithoutUserInput {
  where: PaymentAccountWhereUniqueInput;
  update: PaymentAccountUpdateWithoutUserDataInput;
  create: PaymentAccountCreateWithoutUserInput;
}

export interface LocationUpdateWithoutRestaurantDataInput {
  lat?: Float;
  lng?: Float;
  neighbourHood?: NeighbourhoodUpdateOneWithoutLocationsInput;
  user?: UserUpdateOneWithoutLocationInput;
  place?: PlaceUpdateOneWithoutLocationInput;
  address?: String;
  directions?: String;
  experience?: ExperienceUpdateOneWithoutLocationInput;
}

export interface UserUpsertWithoutLocationInput {
  update: UserUpdateWithoutLocationDataInput;
  create: UserCreateWithoutLocationInput;
}

export interface RestaurantCreateInput {
  title: String;
  avgPricePerPerson: Int;
  pictures?: PictureCreateManyInput;
  location: LocationCreateOneWithoutRestaurantInput;
  isCurated?: Boolean;
  slug: String;
  popularity: Int;
}

export interface ExperienceUpdateOneWithoutLocationInput {
  create?: ExperienceCreateWithoutLocationInput;
  update?: ExperienceUpdateWithoutLocationDataInput;
  upsert?: ExperienceUpsertWithoutLocationInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ExperienceWhereUniqueInput;
}

export interface ExperienceCategoryWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  mainColor?: String;
  mainColor_not?: String;
  mainColor_in?: String[] | String;
  mainColor_not_in?: String[] | String;
  mainColor_lt?: String;
  mainColor_lte?: String;
  mainColor_gt?: String;
  mainColor_gte?: String;
  mainColor_contains?: String;
  mainColor_not_contains?: String;
  mainColor_starts_with?: String;
  mainColor_not_starts_with?: String;
  mainColor_ends_with?: String;
  mainColor_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  experience?: ExperienceWhereInput;
  AND?: ExperienceCategoryWhereInput[] | ExperienceCategoryWhereInput;
  OR?: ExperienceCategoryWhereInput[] | ExperienceCategoryWhereInput;
  NOT?: ExperienceCategoryWhereInput[] | ExperienceCategoryWhereInput;
}

export interface ExperienceUpdateWithoutLocationDataInput {
  category?: ExperienceCategoryUpdateOneWithoutExperienceInput;
  title?: String;
  host?: UserUpdateOneWithoutHostingExperiencesInput;
  pricePerPerson?: Int;
  reviews?: ReviewUpdateManyWithoutExperienceInput;
  preview?: PictureUpdateOneInput;
  popularity?: Int;
}

export interface PaymentAccountUpsertWithoutCreditcardInput {
  update: PaymentAccountUpdateWithoutCreditcardDataInput;
  create: PaymentAccountCreateWithoutCreditcardInput;
}

export interface ExperienceUpsertWithoutLocationInput {
  update: ExperienceUpdateWithoutLocationDataInput;
  create: ExperienceCreateWithoutLocationInput;
}

export interface PaymentAccountCreateOneWithoutCreditcardInput {
  create?: PaymentAccountCreateWithoutCreditcardInput;
  connect?: PaymentAccountWhereUniqueInput;
}

export interface LocationUpsertWithoutPlaceInput {
  update: LocationUpdateWithoutPlaceDataInput;
  create: LocationCreateWithoutPlaceInput;
}

export interface PaypalInformationUpdateInput {
  email?: String;
  paymentAccount?: PaymentAccountUpdateOneWithoutPaypalInput;
}

export interface PlaceUpsertWithoutBookingsInput {
  update: PlaceUpdateWithoutBookingsDataInput;
  create: PlaceCreateWithoutBookingsInput;
}

export interface PaymentUpdateInput {
  serviceFee?: Float;
  placePrice?: Float;
  totalPrice?: Float;
  booking?: BookingUpdateOneWithoutPaymentInput;
  paymentMethod?: PaymentAccountUpdateOneWithoutPaymentsInput;
}

export interface BookingUpsertWithWhereUniqueWithoutBookeeInput {
  where: BookingWhereUniqueInput;
  update: BookingUpdateWithoutBookeeDataInput;
  create: BookingCreateWithoutBookeeInput;
}

export type AmenitiesWhereUniqueInput = AtLeastOne<{
  id?: ID_Input;
}>;

export interface UserUpsertWithoutOwnedPlacesInput {
  update: UserUpdateWithoutOwnedPlacesDataInput;
  create: UserCreateWithoutOwnedPlacesInput;
}

export interface ExperienceUpsertWithoutCategoryInput {
  update: ExperienceUpdateWithoutCategoryDataInput;
  create: ExperienceCreateWithoutCategoryInput;
}

export interface PlaceUpsertWithoutLocationInput {
  update: PlaceUpdateWithoutLocationDataInput;
  create: PlaceCreateWithoutLocationInput;
}

export interface ExperienceCategoryCreateInput {
  mainColor?: String;
  name: String;
  experience?: ExperienceCreateOneWithoutCategoryInput;
}

export interface LocationUpsertWithoutUserInput {
  update: LocationUpdateWithoutUserDataInput;
  create: LocationCreateWithoutUserInput;
}

export interface NeighbourhoodUpdateWithWhereUniqueWithoutCityInput {
  where: NeighbourhoodWhereUniqueInput;
  data: NeighbourhoodUpdateWithoutCityDataInput;
}

export interface UserUpsertWithoutHostingExperiencesInput {
  update: UserUpdateWithoutHostingExperiencesDataInput;
  create: UserCreateWithoutHostingExperiencesInput;
}

export interface LocationUpsertWithWhereUniqueWithoutNeighbourHoodInput {
  where: LocationWhereUniqueInput;
  update: LocationUpdateWithoutNeighbourHoodDataInput;
  create: LocationCreateWithoutNeighbourHoodInput;
}

export interface ExperienceUpsertWithoutReviewsInput {
  update: ExperienceUpdateWithoutReviewsDataInput;
  create: ExperienceCreateWithoutReviewsInput;
}

export interface LocationCreateManyWithoutNeighbourHoodInput {
  create?:
    | LocationCreateWithoutNeighbourHoodInput[]
    | LocationCreateWithoutNeighbourHoodInput;
  connect?: LocationWhereUniqueInput[] | LocationWhereUniqueInput;
}

export interface ReviewUpsertWithWhereUniqueWithoutPlaceInput {
  where: ReviewWhereUniqueInput;
  update: ReviewUpdateWithoutPlaceDataInput;
  create: ReviewCreateWithoutPlaceInput;
}

export interface ReviewCreateManyWithoutPlaceInput {
  create?: ReviewCreateWithoutPlaceInput[] | ReviewCreateWithoutPlaceInput;
  connect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
}

export interface PlaceUpsertWithWhereUniqueWithoutHostInput {
  where: PlaceWhereUniqueInput;
  update: PlaceUpdateWithoutHostDataInput;
  create: PlaceCreateWithoutHostInput;
}

export interface LocationCreateOneWithoutUserInput {
  create?: LocationCreateWithoutUserInput;
  connect?: LocationWhereUniqueInput;
}

export interface PlaceUpdateWithoutViewsDataInput {
  name?: String;
  size?: PLACE_SIZES;
  shortDescription?: String;
  description?: String;
  slug?: String;
  maxGuests?: Int;
  numBedrooms?: Int;
  numBeds?: Int;
  numBaths?: Int;
  reviews?: ReviewUpdateManyWithoutPlaceInput;
  amenities?: AmenitiesUpdateOneWithoutPlaceInput;
  host?: UserUpdateOneWithoutOwnedPlacesInput;
  pricing?: PricingUpdateOneWithoutPlaceInput;
  location?: LocationUpdateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsUpdateOneWithoutPlaceInput;
  policies?: PoliciesUpdateOneWithoutPlaceInput;
  houseRules?: HouseRulesUpdateOneInput;
  bookings?: BookingUpdateManyWithoutPlaceInput;
  pictures?: PictureUpdateManyInput;
  popularity?: Int;
}

export interface PlaceCreateOneWithoutLocationInput {
  create?: PlaceCreateWithoutLocationInput;
  connect?: PlaceWhereUniqueInput;
}

export interface PlaceUpdateOneWithoutViewsInput {
  create?: PlaceCreateWithoutViewsInput;
  update?: PlaceUpdateWithoutViewsDataInput;
  upsert?: PlaceUpsertWithoutViewsInput;
  delete?: Boolean;
  connect?: PlaceWhereUniqueInput;
}

export interface PlaceCreateOneWithoutBookingsInput {
  create?: PlaceCreateWithoutBookingsInput;
  connect?: PlaceWhereUniqueInput;
}

export interface PlaceCreateInput {
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  reviews?: ReviewCreateManyWithoutPlaceInput;
  amenities: AmenitiesCreateOneWithoutPlaceInput;
  host: UserCreateOneWithoutOwnedPlacesInput;
  pricing: PricingCreateOneWithoutPlaceInput;
  location: LocationCreateOneWithoutPlaceInput;
  views: ViewsCreateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsCreateOneWithoutPlaceInput;
  policies?: PoliciesCreateOneWithoutPlaceInput;
  houseRules?: HouseRulesCreateOneInput;
  bookings?: BookingCreateManyWithoutPlaceInput;
  pictures?: PictureCreateManyInput;
  popularity: Int;
}

export interface PaymentAccountCreateManyWithoutUserInput {
  create?:
    | PaymentAccountCreateWithoutUserInput[]
    | PaymentAccountCreateWithoutUserInput;
  connect?: PaymentAccountWhereUniqueInput[] | PaymentAccountWhereUniqueInput;
}

export interface PlaceUpdateInput {
  name?: String;
  size?: PLACE_SIZES;
  shortDescription?: String;
  description?: String;
  slug?: String;
  maxGuests?: Int;
  numBedrooms?: Int;
  numBeds?: Int;
  numBaths?: Int;
  reviews?: ReviewUpdateManyWithoutPlaceInput;
  amenities?: AmenitiesUpdateOneWithoutPlaceInput;
  host?: UserUpdateOneWithoutOwnedPlacesInput;
  pricing?: PricingUpdateOneWithoutPlaceInput;
  location?: LocationUpdateOneWithoutPlaceInput;
  views?: ViewsUpdateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsUpdateOneWithoutPlaceInput;
  policies?: PoliciesUpdateOneWithoutPlaceInput;
  houseRules?: HouseRulesUpdateOneInput;
  bookings?: BookingUpdateManyWithoutPlaceInput;
  pictures?: PictureUpdateManyInput;
  popularity?: Int;
}

export interface MessageCreateManyWithoutFromInput {
  create?: MessageCreateWithoutFromInput[] | MessageCreateWithoutFromInput;
  connect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
}

export interface PricingCreateInput {
  place: PlaceCreateOneWithoutPricingInput;
  monthlyDiscount?: Int;
  weeklyDiscount?: Int;
  perNight: Int;
  smartPricing?: Boolean;
  basePrice: Int;
  averageWeekly: Int;
  averageMonthly: Int;
  cleaningFee?: Int;
  securityDeposit?: Int;
  extraGuests?: Int;
  weekendPricing?: Int;
  currency?: CURRENCY;
}

export interface LocationCreateOneWithoutExperienceInput {
  create?: LocationCreateWithoutExperienceInput;
  connect?: LocationWhereUniqueInput;
}

export interface PlaceCreateOneWithoutPricingInput {
  create?: PlaceCreateWithoutPricingInput;
  connect?: PlaceWhereUniqueInput;
}

export interface PlaceCreateWithoutReviewsInput {
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  amenities: AmenitiesCreateOneWithoutPlaceInput;
  host: UserCreateOneWithoutOwnedPlacesInput;
  pricing: PricingCreateOneWithoutPlaceInput;
  location: LocationCreateOneWithoutPlaceInput;
  views: ViewsCreateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsCreateOneWithoutPlaceInput;
  policies?: PoliciesCreateOneWithoutPlaceInput;
  houseRules?: HouseRulesCreateOneInput;
  bookings?: BookingCreateManyWithoutPlaceInput;
  pictures?: PictureCreateManyInput;
  popularity: Int;
}

export interface PlaceCreateWithoutPricingInput {
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  reviews?: ReviewCreateManyWithoutPlaceInput;
  amenities: AmenitiesCreateOneWithoutPlaceInput;
  host: UserCreateOneWithoutOwnedPlacesInput;
  location: LocationCreateOneWithoutPlaceInput;
  views: ViewsCreateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsCreateOneWithoutPlaceInput;
  policies?: PoliciesCreateOneWithoutPlaceInput;
  houseRules?: HouseRulesCreateOneInput;
  bookings?: BookingCreateManyWithoutPlaceInput;
  pictures?: PictureCreateManyInput;
  popularity: Int;
}

export interface ExperienceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ExperienceWhereInput;
  AND?: ExperienceSubscriptionWhereInput[] | ExperienceSubscriptionWhereInput;
  OR?: ExperienceSubscriptionWhereInput[] | ExperienceSubscriptionWhereInput;
  NOT?: ExperienceSubscriptionWhereInput[] | ExperienceSubscriptionWhereInput;
}

export interface PricingUpdateInput {
  place?: PlaceUpdateOneWithoutPricingInput;
  monthlyDiscount?: Int;
  weeklyDiscount?: Int;
  perNight?: Int;
  smartPricing?: Boolean;
  basePrice?: Int;
  averageWeekly?: Int;
  averageMonthly?: Int;
  cleaningFee?: Int;
  securityDeposit?: Int;
  extraGuests?: Int;
  weekendPricing?: Int;
  currency?: CURRENCY;
}

export interface NeighbourhoodWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  locations_every?: LocationWhereInput;
  locations_some?: LocationWhereInput;
  locations_none?: LocationWhereInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  homePreview?: PictureWhereInput;
  city?: CityWhereInput;
  featured?: Boolean;
  featured_not?: Boolean;
  popularity?: Int;
  popularity_not?: Int;
  popularity_in?: Int[] | Int;
  popularity_not_in?: Int[] | Int;
  popularity_lt?: Int;
  popularity_lte?: Int;
  popularity_gt?: Int;
  popularity_gte?: Int;
  AND?: NeighbourhoodWhereInput[] | NeighbourhoodWhereInput;
  OR?: NeighbourhoodWhereInput[] | NeighbourhoodWhereInput;
  NOT?: NeighbourhoodWhereInput[] | NeighbourhoodWhereInput;
}

export interface PlaceUpdateOneWithoutPricingInput {
  create?: PlaceCreateWithoutPricingInput;
  update?: PlaceUpdateWithoutPricingDataInput;
  upsert?: PlaceUpsertWithoutPricingInput;
  delete?: Boolean;
  connect?: PlaceWhereUniqueInput;
}

export interface UserUpdateWithoutNotificationsDataInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  password?: String;
  phone?: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceUpdateManyWithoutHostInput;
  location?: LocationUpdateOneWithoutUserInput;
  bookings?: BookingUpdateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountUpdateManyWithoutUserInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receivedMessages?: MessageUpdateManyWithoutToInput;
  profilePicture?: PictureUpdateOneInput;
  hostingExperiences?: ExperienceUpdateManyWithoutHostInput;
}

export interface PlaceUpdateWithoutPricingDataInput {
  name?: String;
  size?: PLACE_SIZES;
  shortDescription?: String;
  description?: String;
  slug?: String;
  maxGuests?: Int;
  numBedrooms?: Int;
  numBeds?: Int;
  numBaths?: Int;
  reviews?: ReviewUpdateManyWithoutPlaceInput;
  amenities?: AmenitiesUpdateOneWithoutPlaceInput;
  host?: UserUpdateOneWithoutOwnedPlacesInput;
  location?: LocationUpdateOneWithoutPlaceInput;
  views?: ViewsUpdateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsUpdateOneWithoutPlaceInput;
  policies?: PoliciesUpdateOneWithoutPlaceInput;
  houseRules?: HouseRulesUpdateOneInput;
  bookings?: BookingUpdateManyWithoutPlaceInput;
  pictures?: PictureUpdateManyInput;
  popularity?: Int;
}

export interface PaymentAccountUpdateOneWithoutCreditcardInput {
  create?: PaymentAccountCreateWithoutCreditcardInput;
  update?: PaymentAccountUpdateWithoutCreditcardDataInput;
  upsert?: PaymentAccountUpsertWithoutCreditcardInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PaymentAccountWhereUniqueInput;
}

export interface PlaceUpsertWithoutPricingInput {
  update: PlaceUpdateWithoutPricingDataInput;
  create: PlaceCreateWithoutPricingInput;
}

export interface PaypalInformationCreateInput {
  email: String;
  paymentAccount: PaymentAccountCreateOneWithoutPaypalInput;
}

export interface GuestRequirementsCreateInput {
  govIssuedId?: Boolean;
  recommendationsFromOtherHosts?: Boolean;
  guestTripInformation?: Boolean;
  place: PlaceCreateOneWithoutGuestRequirementsInput;
}

export interface PlaceCreateWithoutAmenitiesInput {
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  reviews?: ReviewCreateManyWithoutPlaceInput;
  host: UserCreateOneWithoutOwnedPlacesInput;
  pricing: PricingCreateOneWithoutPlaceInput;
  location: LocationCreateOneWithoutPlaceInput;
  views: ViewsCreateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsCreateOneWithoutPlaceInput;
  policies?: PoliciesCreateOneWithoutPlaceInput;
  houseRules?: HouseRulesCreateOneInput;
  bookings?: BookingCreateManyWithoutPlaceInput;
  pictures?: PictureCreateManyInput;
  popularity: Int;
}

export interface PlaceCreateOneWithoutGuestRequirementsInput {
  create?: PlaceCreateWithoutGuestRequirementsInput;
  connect?: PlaceWhereUniqueInput;
}

export interface PictureUpdateInput {
  url?: String;
}

export interface PlaceCreateWithoutGuestRequirementsInput {
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  reviews?: ReviewCreateManyWithoutPlaceInput;
  amenities: AmenitiesCreateOneWithoutPlaceInput;
  host: UserCreateOneWithoutOwnedPlacesInput;
  pricing: PricingCreateOneWithoutPlaceInput;
  location: LocationCreateOneWithoutPlaceInput;
  views: ViewsCreateOneWithoutPlaceInput;
  policies?: PoliciesCreateOneWithoutPlaceInput;
  houseRules?: HouseRulesCreateOneInput;
  bookings?: BookingCreateManyWithoutPlaceInput;
  pictures?: PictureCreateManyInput;
  popularity: Int;
}

export interface LocationUpdateManyWithoutNeighbourHoodInput {
  create?:
    | LocationCreateWithoutNeighbourHoodInput[]
    | LocationCreateWithoutNeighbourHoodInput;
  delete?: LocationWhereUniqueInput[] | LocationWhereUniqueInput;
  connect?: LocationWhereUniqueInput[] | LocationWhereUniqueInput;
  disconnect?: LocationWhereUniqueInput[] | LocationWhereUniqueInput;
  update?:
    | LocationUpdateWithWhereUniqueWithoutNeighbourHoodInput[]
    | LocationUpdateWithWhereUniqueWithoutNeighbourHoodInput;
  upsert?:
    | LocationUpsertWithWhereUniqueWithoutNeighbourHoodInput[]
    | LocationUpsertWithWhereUniqueWithoutNeighbourHoodInput;
}

export interface GuestRequirementsUpdateInput {
  govIssuedId?: Boolean;
  recommendationsFromOtherHosts?: Boolean;
  guestTripInformation?: Boolean;
  place?: PlaceUpdateOneWithoutGuestRequirementsInput;
}

export interface ExperienceCategoryCreateOneWithoutExperienceInput {
  create?: ExperienceCategoryCreateWithoutExperienceInput;
  connect?: ExperienceCategoryWhereUniqueInput;
}

export interface PlaceUpdateOneWithoutGuestRequirementsInput {
  create?: PlaceCreateWithoutGuestRequirementsInput;
  update?: PlaceUpdateWithoutGuestRequirementsDataInput;
  upsert?: PlaceUpsertWithoutGuestRequirementsInput;
  delete?: Boolean;
  connect?: PlaceWhereUniqueInput;
}

export interface UserCreateOneWithoutOwnedPlacesInput {
  create?: UserCreateWithoutOwnedPlacesInput;
  connect?: UserWhereUniqueInput;
}

export interface PlaceUpdateWithoutGuestRequirementsDataInput {
  name?: String;
  size?: PLACE_SIZES;
  shortDescription?: String;
  description?: String;
  slug?: String;
  maxGuests?: Int;
  numBedrooms?: Int;
  numBeds?: Int;
  numBaths?: Int;
  reviews?: ReviewUpdateManyWithoutPlaceInput;
  amenities?: AmenitiesUpdateOneWithoutPlaceInput;
  host?: UserUpdateOneWithoutOwnedPlacesInput;
  pricing?: PricingUpdateOneWithoutPlaceInput;
  location?: LocationUpdateOneWithoutPlaceInput;
  views?: ViewsUpdateOneWithoutPlaceInput;
  policies?: PoliciesUpdateOneWithoutPlaceInput;
  houseRules?: HouseRulesUpdateOneInput;
  bookings?: BookingUpdateManyWithoutPlaceInput;
  pictures?: PictureUpdateManyInput;
  popularity?: Int;
}

export interface BookingCreateOneWithoutPaymentInput {
  create?: BookingCreateWithoutPaymentInput;
  connect?: BookingWhereUniqueInput;
}

export interface PlaceUpsertWithoutGuestRequirementsInput {
  update: PlaceUpdateWithoutGuestRequirementsDataInput;
  create: PlaceCreateWithoutGuestRequirementsInput;
}

export interface PictureCreateManyInput {
  create?: PictureCreateInput[] | PictureCreateInput;
  connect?: PictureWhereUniqueInput[] | PictureWhereUniqueInput;
}

export interface PoliciesCreateInput {
  checkInStartTime: Float;
  checkInEndTime: Float;
  checkoutTime: Float;
  place: PlaceCreateOneWithoutPoliciesInput;
}

export interface HouseRulesSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: HouseRulesWhereInput;
  AND?: HouseRulesSubscriptionWhereInput[] | HouseRulesSubscriptionWhereInput;
  OR?: HouseRulesSubscriptionWhereInput[] | HouseRulesSubscriptionWhereInput;
  NOT?: HouseRulesSubscriptionWhereInput[] | HouseRulesSubscriptionWhereInput;
}

export interface PlaceCreateOneWithoutPoliciesInput {
  create?: PlaceCreateWithoutPoliciesInput;
  connect?: PlaceWhereUniqueInput;
}

export type HouseRulesWhereUniqueInput = AtLeastOne<{
  id?: ID_Input;
}>;

export interface PlaceCreateWithoutPoliciesInput {
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  reviews?: ReviewCreateManyWithoutPlaceInput;
  amenities: AmenitiesCreateOneWithoutPlaceInput;
  host: UserCreateOneWithoutOwnedPlacesInput;
  pricing: PricingCreateOneWithoutPlaceInput;
  location: LocationCreateOneWithoutPlaceInput;
  views: ViewsCreateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsCreateOneWithoutPlaceInput;
  houseRules?: HouseRulesCreateOneInput;
  bookings?: BookingCreateManyWithoutPlaceInput;
  pictures?: PictureCreateManyInput;
  popularity: Int;
}

export interface BookingCreateInput {
  bookee: UserCreateOneWithoutBookingsInput;
  place: PlaceCreateOneWithoutBookingsInput;
  startDate: DateTimeInput;
  endDate: DateTimeInput;
  payment?: PaymentCreateOneWithoutBookingInput;
}

export interface PoliciesUpdateInput {
  checkInStartTime?: Float;
  checkInEndTime?: Float;
  checkoutTime?: Float;
  place?: PlaceUpdateOneWithoutPoliciesInput;
}

export interface NeighbourhoodCreateWithoutCityInput {
  locations?: LocationCreateManyWithoutNeighbourHoodInput;
  name: String;
  slug: String;
  homePreview?: PictureCreateOneInput;
  featured: Boolean;
  popularity: Int;
}

export interface PlaceUpdateOneWithoutPoliciesInput {
  create?: PlaceCreateWithoutPoliciesInput;
  update?: PlaceUpdateWithoutPoliciesDataInput;
  upsert?: PlaceUpsertWithoutPoliciesInput;
  delete?: Boolean;
  connect?: PlaceWhereUniqueInput;
}

export interface PictureCreateOneInput {
  create?: PictureCreateInput;
  connect?: PictureWhereUniqueInput;
}

export interface PlaceUpdateWithoutPoliciesDataInput {
  name?: String;
  size?: PLACE_SIZES;
  shortDescription?: String;
  description?: String;
  slug?: String;
  maxGuests?: Int;
  numBedrooms?: Int;
  numBeds?: Int;
  numBaths?: Int;
  reviews?: ReviewUpdateManyWithoutPlaceInput;
  amenities?: AmenitiesUpdateOneWithoutPlaceInput;
  host?: UserUpdateOneWithoutOwnedPlacesInput;
  pricing?: PricingUpdateOneWithoutPlaceInput;
  location?: LocationUpdateOneWithoutPlaceInput;
  views?: ViewsUpdateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsUpdateOneWithoutPlaceInput;
  houseRules?: HouseRulesUpdateOneInput;
  bookings?: BookingUpdateManyWithoutPlaceInput;
  pictures?: PictureUpdateManyInput;
  popularity?: Int;
}

export interface NotificationCreateManyWithoutUserInput {
  create?:
    | NotificationCreateWithoutUserInput[]
    | NotificationCreateWithoutUserInput;
  connect?: NotificationWhereUniqueInput[] | NotificationWhereUniqueInput;
}

export interface PlaceUpsertWithoutPoliciesInput {
  update: PlaceUpdateWithoutPoliciesDataInput;
  create: PlaceCreateWithoutPoliciesInput;
}

export interface LocationCreateWithoutRestaurantInput {
  lat: Float;
  lng: Float;
  neighbourHood?: NeighbourhoodCreateOneWithoutLocationsInput;
  user?: UserCreateOneWithoutLocationInput;
  place?: PlaceCreateOneWithoutLocationInput;
  address?: String;
  directions?: String;
  experience?: ExperienceCreateOneWithoutLocationInput;
}

export interface ExperienceCategoryUpdateInput {
  mainColor?: String;
  name?: String;
  experience?: ExperienceUpdateOneWithoutCategoryInput;
}

export interface PlaceCreateWithoutViewsInput {
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  reviews?: ReviewCreateManyWithoutPlaceInput;
  amenities: AmenitiesCreateOneWithoutPlaceInput;
  host: UserCreateOneWithoutOwnedPlacesInput;
  pricing: PricingCreateOneWithoutPlaceInput;
  location: LocationCreateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsCreateOneWithoutPlaceInput;
  policies?: PoliciesCreateOneWithoutPlaceInput;
  houseRules?: HouseRulesCreateOneInput;
  bookings?: BookingCreateManyWithoutPlaceInput;
  pictures?: PictureCreateManyInput;
  popularity: Int;
}

export interface PlaceCreateOneWithoutViewsInput {
  create?: PlaceCreateWithoutViewsInput;
  connect?: PlaceWhereUniqueInput;
}

export interface ViewsCreateInput {
  lastWeek: Int;
  place: PlaceCreateOneWithoutViewsInput;
}

export interface HouseRulesUpdateInput {
  suitableForChildren?: Boolean;
  suitableForInfants?: Boolean;
  petsAllowed?: Boolean;
  smokingAllowed?: Boolean;
  partiesAndEventsAllowed?: Boolean;
  additionalRules?: String;
}

export interface PaymentAccountUpdateWithoutPaypalDataInput {
  type?: PAYMENT_PROVIDER;
  user?: UserUpdateOneWithoutPaymentAccountInput;
  payments?: PaymentUpdateManyWithoutPaymentMethodInput;
  creditcard?: CreditCardInformationUpdateOneWithoutPaymentAccountInput;
}

export interface PaymentAccountSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PaymentAccountWhereInput;
  AND?:
    | PaymentAccountSubscriptionWhereInput[]
    | PaymentAccountSubscriptionWhereInput;
  OR?:
    | PaymentAccountSubscriptionWhereInput[]
    | PaymentAccountSubscriptionWhereInput;
  NOT?:
    | PaymentAccountSubscriptionWhereInput[]
    | PaymentAccountSubscriptionWhereInput;
}

export interface LocationCreateOneWithoutPlaceInput {
  create?: LocationCreateWithoutPlaceInput;
  connect?: LocationWhereUniqueInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface RestaurantPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  title: String;
  avgPricePerPerson: Int;
  isCurated: Boolean;
  slug: String;
  popularity: Int;
}

export interface RestaurantPreviousValues
  extends Promise<RestaurantPreviousValuesNode> {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  avgPricePerPerson: () => Promise<Int>;
  isCurated: () => Promise<Boolean>;
  slug: () => Promise<String>;
  popularity: () => Promise<Int>;
}

export interface RestaurantPreviousValuesSubscription
  extends Promise<AsyncIterator<RestaurantPreviousValuesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  avgPricePerPerson: () => Promise<AsyncIterator<Int>>;
  isCurated: () => Promise<AsyncIterator<Boolean>>;
  slug: () => Promise<AsyncIterator<String>>;
  popularity: () => Promise<AsyncIterator<Int>>;
}

export interface PlaceConnectionNode {}

export interface PlaceConnection extends Promise<PlaceConnectionNode> {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<PlaceEdgeNode>>>() => T;
  aggregate: <T = AggregatePlace>() => T;
}

export interface PlaceConnectionSubscription
  extends Promise<AsyncIterator<PlaceConnectionNode>> {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<PlaceEdgeSubscription>>>>() => T;
  aggregate: <T = AggregatePlaceSubscription>() => T;
}

export interface PlaceNode {
  id: ID_Output;
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  popularity: Int;
}

export interface Place extends Promise<PlaceNode> {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  size: () => Promise<PLACE_SIZES>;
  shortDescription: () => Promise<String>;
  description: () => Promise<String>;
  slug: () => Promise<String>;
  maxGuests: () => Promise<Int>;
  numBedrooms: () => Promise<Int>;
  numBeds: () => Promise<Int>;
  numBaths: () => Promise<Int>;
  reviews: <T = Promise<Array<ReviewNode>>>(
    args?: {
      where?: ReviewWhereInput;
      orderBy?: ReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  amenities: <T = Amenities>(
    args?: { where?: AmenitiesWhereInput },
    fragment?: string | object
  ) => T;
  host: <T = User>(
    args?: { where?: UserWhereInput },
    fragment?: string | object
  ) => T;
  pricing: <T = Pricing>(
    args?: { where?: PricingWhereInput },
    fragment?: string | object
  ) => T;
  location: <T = Location>(
    args?: { where?: LocationWhereInput },
    fragment?: string | object
  ) => T;
  views: <T = Views>(
    args?: { where?: ViewsWhereInput },
    fragment?: string | object
  ) => T;
  guestRequirements: <T = GuestRequirements>(
    args?: { where?: GuestRequirementsWhereInput },
    fragment?: string | object
  ) => T;
  policies: <T = Policies>(
    args?: { where?: PoliciesWhereInput },
    fragment?: string | object
  ) => T;
  houseRules: <T = HouseRules>(
    args?: { where?: HouseRulesWhereInput },
    fragment?: string | object
  ) => T;
  bookings: <T = Promise<Array<BookingNode>>>(
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  pictures: <T = Promise<Array<PictureNode>>>(
    args?: {
      where?: PictureWhereInput;
      orderBy?: PictureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  popularity: () => Promise<Int>;
}

export interface PlaceSubscription extends Promise<AsyncIterator<PlaceNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<PLACE_SIZES>>;
  shortDescription: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  maxGuests: () => Promise<AsyncIterator<Int>>;
  numBedrooms: () => Promise<AsyncIterator<Int>>;
  numBeds: () => Promise<AsyncIterator<Int>>;
  numBaths: () => Promise<AsyncIterator<Int>>;
  reviews: <T = Promise<AsyncIterator<Array<ReviewSubscription>>>>(
    args?: {
      where?: ReviewWhereInput;
      orderBy?: ReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  amenities: <T = AmenitiesSubscription>(
    args?: { where?: AmenitiesWhereInput },
    fragment?: string | object
  ) => T;
  host: <T = UserSubscription>(
    args?: { where?: UserWhereInput },
    fragment?: string | object
  ) => T;
  pricing: <T = PricingSubscription>(
    args?: { where?: PricingWhereInput },
    fragment?: string | object
  ) => T;
  location: <T = LocationSubscription>(
    args?: { where?: LocationWhereInput },
    fragment?: string | object
  ) => T;
  views: <T = ViewsSubscription>(
    args?: { where?: ViewsWhereInput },
    fragment?: string | object
  ) => T;
  guestRequirements: <T = GuestRequirementsSubscription>(
    args?: { where?: GuestRequirementsWhereInput },
    fragment?: string | object
  ) => T;
  policies: <T = PoliciesSubscription>(
    args?: { where?: PoliciesWhereInput },
    fragment?: string | object
  ) => T;
  houseRules: <T = HouseRulesSubscription>(
    args?: { where?: HouseRulesWhereInput },
    fragment?: string | object
  ) => T;
  bookings: <T = Promise<AsyncIterator<Array<BookingSubscription>>>>(
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  pictures: <T = Promise<AsyncIterator<Array<PictureSubscription>>>>(
    args?: {
      where?: PictureWhereInput;
      orderBy?: PictureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  popularity: () => Promise<AsyncIterator<Int>>;
}

export interface AggregatePlaceNode {
  count: Int;
}

export interface AggregatePlace extends Promise<AggregatePlaceNode> {
  count: () => Promise<Int>;
}

export interface AggregatePlaceSubscription
  extends Promise<AsyncIterator<AggregatePlaceNode>> {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MessagePreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  deliveredAt: DateTimeOutput;
  readAt: DateTimeOutput;
}

export interface MessagePreviousValues
  extends Promise<MessagePreviousValuesNode> {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  deliveredAt: () => Promise<DateTimeOutput>;
  readAt: () => Promise<DateTimeOutput>;
}

export interface MessagePreviousValuesSubscription
  extends Promise<AsyncIterator<MessagePreviousValuesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deliveredAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  readAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PlaceEdgeNode {
  cursor: String;
}

export interface PlaceEdge extends Promise<PlaceEdgeNode> {
  node: <T = Place>() => T;
  cursor: () => Promise<String>;
}

export interface PlaceEdgeSubscription
  extends Promise<AsyncIterator<PlaceEdgeNode>> {
  node: <T = PlaceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserNode {
  count: Int;
}

export interface AggregateUser extends Promise<AggregateUserNode> {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUserNode>> {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayloadNode {
  count: Long;
}

export interface BatchPayload extends Promise<BatchPayloadNode> {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayloadNode>> {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface RestaurantConnectionNode {}

export interface RestaurantConnection
  extends Promise<RestaurantConnectionNode> {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<RestaurantEdgeNode>>>() => T;
  aggregate: <T = AggregateRestaurant>() => T;
}

export interface RestaurantConnectionSubscription
  extends Promise<AsyncIterator<RestaurantConnectionNode>> {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<RestaurantEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateRestaurantSubscription>() => T;
}

export interface AggregateRestaurantNode {
  count: Int;
}

export interface AggregateRestaurant extends Promise<AggregateRestaurantNode> {
  count: () => Promise<Int>;
}

export interface AggregateRestaurantSubscription
  extends Promise<AsyncIterator<AggregateRestaurantNode>> {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateNotificationNode {
  count: Int;
}

export interface AggregateNotification
  extends Promise<AggregateNotificationNode> {
  count: () => Promise<Int>;
}

export interface AggregateNotificationSubscription
  extends Promise<AsyncIterator<AggregateNotificationNode>> {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserEdgeNode {
  cursor: String;
}

export interface UserEdge extends Promise<UserEdgeNode> {
  node: <T = User>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdgeNode>> {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface NotificationConnectionNode {}

export interface NotificationConnection
  extends Promise<NotificationConnectionNode> {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<NotificationEdgeNode>>>() => T;
  aggregate: <T = AggregateNotification>() => T;
}

export interface NotificationConnectionSubscription
  extends Promise<AsyncIterator<NotificationConnectionNode>> {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<Array<NotificationEdgeSubscription>>>
  >() => T;
  aggregate: <T = AggregateNotificationSubscription>() => T;
}

export interface PageInfoNode {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfo extends Promise<PageInfoNode> {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfoNode>> {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface MessageEdgeNode {
  cursor: String;
}

export interface MessageEdge extends Promise<MessageEdgeNode> {
  node: <T = Message>() => T;
  cursor: () => Promise<String>;
}

export interface MessageEdgeSubscription
  extends Promise<AsyncIterator<MessageEdgeNode>> {
  node: <T = MessageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ExperienceNode {
  id: ID_Output;
  title: String;
  pricePerPerson: Int;
  popularity: Int;
}

export interface Experience extends Promise<ExperienceNode> {
  id: () => Promise<ID_Output>;
  category: <T = ExperienceCategory>(
    args?: { where?: ExperienceCategoryWhereInput },
    fragment?: string | object
  ) => T;
  title: () => Promise<String>;
  host: <T = User>(
    args?: { where?: UserWhereInput },
    fragment?: string | object
  ) => T;
  location: <T = Location>(
    args?: { where?: LocationWhereInput },
    fragment?: string | object
  ) => T;
  pricePerPerson: () => Promise<Int>;
  reviews: <T = Promise<Array<ReviewNode>>>(
    args?: {
      where?: ReviewWhereInput;
      orderBy?: ReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  preview: <T = Picture>(
    args?: { where?: PictureWhereInput },
    fragment?: string | object
  ) => T;
  popularity: () => Promise<Int>;
}

export interface ExperienceSubscription
  extends Promise<AsyncIterator<ExperienceNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  category: <T = ExperienceCategorySubscription>(
    args?: { where?: ExperienceCategoryWhereInput },
    fragment?: string | object
  ) => T;
  title: () => Promise<AsyncIterator<String>>;
  host: <T = UserSubscription>(
    args?: { where?: UserWhereInput },
    fragment?: string | object
  ) => T;
  location: <T = LocationSubscription>(
    args?: { where?: LocationWhereInput },
    fragment?: string | object
  ) => T;
  pricePerPerson: () => Promise<AsyncIterator<Int>>;
  reviews: <T = Promise<AsyncIterator<Array<ReviewSubscription>>>>(
    args?: {
      where?: ReviewWhereInput;
      orderBy?: ReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  preview: <T = PictureSubscription>(
    args?: { where?: PictureWhereInput },
    fragment?: string | object
  ) => T;
  popularity: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateCreditCardInformationNode {
  count: Int;
}

export interface AggregateCreditCardInformation
  extends Promise<AggregateCreditCardInformationNode> {
  count: () => Promise<Int>;
}

export interface AggregateCreditCardInformationSubscription
  extends Promise<AsyncIterator<AggregateCreditCardInformationNode>> {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserSubscriptionPayload
  extends Promise<UserSubscriptionPayloadNode> {
  mutation: () => Promise<MutationType>;
  node: <T = User>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValues>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayloadNode>> {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface CreditCardInformationConnectionNode {}

export interface CreditCardInformationConnection
  extends Promise<CreditCardInformationConnectionNode> {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<CreditCardInformationEdgeNode>>>() => T;
  aggregate: <T = AggregateCreditCardInformation>() => T;
}

export interface CreditCardInformationConnectionSubscription
  extends Promise<AsyncIterator<CreditCardInformationConnectionNode>> {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<Array<CreditCardInformationEdgeSubscription>>>
  >() => T;
  aggregate: <T = AggregateCreditCardInformationSubscription>() => T;
}

export interface UserPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost: Boolean;
}

export interface UserPreviousValues extends Promise<UserPreviousValuesNode> {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  responseRate: () => Promise<Float>;
  responseTime: () => Promise<Int>;
  isSuperHost: () => Promise<Boolean>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValuesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  responseRate: () => Promise<AsyncIterator<Float>>;
  responseTime: () => Promise<AsyncIterator<Int>>;
  isSuperHost: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregatePaypalInformationNode {
  count: Int;
}

export interface AggregatePaypalInformation
  extends Promise<AggregatePaypalInformationNode> {
  count: () => Promise<Int>;
}

export interface AggregatePaypalInformationSubscription
  extends Promise<AsyncIterator<AggregatePaypalInformationNode>> {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnectionNode {}

export interface UserConnection extends Promise<UserConnectionNode> {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<UserEdgeNode>>>() => T;
  aggregate: <T = AggregateUser>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnectionNode>> {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<UserEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface PaypalInformationConnectionNode {}

export interface PaypalInformationConnection
  extends Promise<PaypalInformationConnectionNode> {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<PaypalInformationEdgeNode>>>() => T;
  aggregate: <T = AggregatePaypalInformation>() => T;
}

export interface PaypalInformationConnectionSubscription
  extends Promise<AsyncIterator<PaypalInformationConnectionNode>> {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<Array<PaypalInformationEdgeSubscription>>>
  >() => T;
  aggregate: <T = AggregatePaypalInformationSubscription>() => T;
}

export interface PlaceSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PlaceSubscriptionPayload
  extends Promise<PlaceSubscriptionPayloadNode> {
  mutation: () => Promise<MutationType>;
  node: <T = Place>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PlacePreviousValues>() => T;
}

export interface PlaceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PlaceSubscriptionPayloadNode>> {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PlaceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PlacePreviousValuesSubscription>() => T;
}

export interface AggregatePaymentAccountNode {
  count: Int;
}

export interface AggregatePaymentAccount
  extends Promise<AggregatePaymentAccountNode> {
  count: () => Promise<Int>;
}

export interface AggregatePaymentAccountSubscription
  extends Promise<AsyncIterator<AggregatePaymentAccountNode>> {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PlacePreviousValuesNode {
  id: ID_Output;
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  popularity: Int;
}

export interface PlacePreviousValues extends Promise<PlacePreviousValuesNode> {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  size: () => Promise<PLACE_SIZES>;
  shortDescription: () => Promise<String>;
  description: () => Promise<String>;
  slug: () => Promise<String>;
  maxGuests: () => Promise<Int>;
  numBedrooms: () => Promise<Int>;
  numBeds: () => Promise<Int>;
  numBaths: () => Promise<Int>;
  popularity: () => Promise<Int>;
}

export interface PlacePreviousValuesSubscription
  extends Promise<AsyncIterator<PlacePreviousValuesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<PLACE_SIZES>>;
  shortDescription: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  maxGuests: () => Promise<AsyncIterator<Int>>;
  numBedrooms: () => Promise<AsyncIterator<Int>>;
  numBeds: () => Promise<AsyncIterator<Int>>;
  numBaths: () => Promise<AsyncIterator<Int>>;
  popularity: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentAccountConnectionNode {}

export interface PaymentAccountConnection
  extends Promise<PaymentAccountConnectionNode> {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<PaymentAccountEdgeNode>>>() => T;
  aggregate: <T = AggregatePaymentAccount>() => T;
}

export interface PaymentAccountConnectionSubscription
  extends Promise<AsyncIterator<PaymentAccountConnectionNode>> {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<Array<PaymentAccountEdgeSubscription>>>
  >() => T;
  aggregate: <T = AggregatePaymentAccountSubscription>() => T;
}

export interface NotificationNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  type?: NOTIFICATION_TYPE;
  link: String;
  readDate: DateTimeOutput;
}

export interface Notification extends Promise<NotificationNode> {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  type: () => Promise<NOTIFICATION_TYPE>;
  user: <T = User>(
    args?: { where?: UserWhereInput },
    fragment?: string | object
  ) => T;
  link: () => Promise<String>;
  readDate: () => Promise<DateTimeOutput>;
}

export interface NotificationSubscription
  extends Promise<AsyncIterator<NotificationNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<NOTIFICATION_TYPE>>;
  user: <T = UserSubscription>(
    args?: { where?: UserWhereInput },
    fragment?: string | object
  ) => T;
  link: () => Promise<AsyncIterator<String>>;
  readDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PaymentEdgeNode {
  cursor: String;
}

export interface PaymentEdge extends Promise<PaymentEdgeNode> {
  node: <T = Payment>() => T;
  cursor: () => Promise<String>;
}

export interface PaymentEdgeSubscription
  extends Promise<AsyncIterator<PaymentEdgeNode>> {
  node: <T = PaymentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PricingSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PricingSubscriptionPayload
  extends Promise<PricingSubscriptionPayloadNode> {
  mutation: () => Promise<MutationType>;
  node: <T = Pricing>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PricingPreviousValues>() => T;
}

export interface PricingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PricingSubscriptionPayloadNode>> {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PricingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PricingPreviousValuesSubscription>() => T;
}

export interface AggregateBookingNode {
  count: Int;
}

export interface AggregateBooking extends Promise<AggregateBookingNode> {
  count: () => Promise<Int>;
}

export interface AggregateBookingSubscription
  extends Promise<AsyncIterator<AggregateBookingNode>> {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PricingPreviousValuesNode {
  id: ID_Output;
  monthlyDiscount?: Int;
  weeklyDiscount?: Int;
  perNight: Int;
  smartPricing: Boolean;
  basePrice: Int;
  averageWeekly: Int;
  averageMonthly: Int;
  cleaningFee?: Int;
  securityDeposit?: Int;
  extraGuests?: Int;
  weekendPricing?: Int;
  currency?: CURRENCY;
}

export interface PricingPreviousValues
  extends Promise<PricingPreviousValuesNode> {
  id: () => Promise<ID_Output>;
  monthlyDiscount: () => Promise<Int>;
  weeklyDiscount: () => Promise<Int>;
  perNight: () => Promise<Int>;
  smartPricing: () => Promise<Boolean>;
  basePrice: () => Promise<Int>;
  averageWeekly: () => Promise<Int>;
  averageMonthly: () => Promise<Int>;
  cleaningFee: () => Promise<Int>;
  securityDeposit: () => Promise<Int>;
  extraGuests: () => Promise<Int>;
  weekendPricing: () => Promise<Int>;
  currency: () => Promise<CURRENCY>;
}

export interface PricingPreviousValuesSubscription
  extends Promise<AsyncIterator<PricingPreviousValuesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  monthlyDiscount: () => Promise<AsyncIterator<Int>>;
  weeklyDiscount: () => Promise<AsyncIterator<Int>>;
  perNight: () => Promise<AsyncIterator<Int>>;
  smartPricing: () => Promise<AsyncIterator<Boolean>>;
  basePrice: () => Promise<AsyncIterator<Int>>;
  averageWeekly: () => Promise<AsyncIterator<Int>>;
  averageMonthly: () => Promise<AsyncIterator<Int>>;
  cleaningFee: () => Promise<AsyncIterator<Int>>;
  securityDeposit: () => Promise<AsyncIterator<Int>>;
  extraGuests: () => Promise<AsyncIterator<Int>>;
  weekendPricing: () => Promise<AsyncIterator<Int>>;
  currency: () => Promise<AsyncIterator<CURRENCY>>;
}

export interface BookingConnectionNode {}

export interface BookingConnection extends Promise<BookingConnectionNode> {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<BookingEdgeNode>>>() => T;
  aggregate: <T = AggregateBooking>() => T;
}

export interface BookingConnectionSubscription
  extends Promise<AsyncIterator<BookingConnectionNode>> {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<BookingEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateBookingSubscription>() => T;
}

export interface MessageNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  deliveredAt: DateTimeOutput;
  readAt: DateTimeOutput;
}

export interface Message extends Promise<MessageNode> {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  from: <T = User>(
    args?: { where?: UserWhereInput },
    fragment?: string | object
  ) => T;
  to: <T = User>(
    args?: { where?: UserWhereInput },
    fragment?: string | object
  ) => T;
  deliveredAt: () => Promise<DateTimeOutput>;
  readAt: () => Promise<DateTimeOutput>;
}

export interface MessageSubscription
  extends Promise<AsyncIterator<MessageNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  from: <T = UserSubscription>(
    args?: { where?: UserWhereInput },
    fragment?: string | object
  ) => T;
  to: <T = UserSubscription>(
    args?: { where?: UserWhereInput },
    fragment?: string | object
  ) => T;
  deliveredAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  readAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReviewEdgeNode {
  cursor: String;
}

export interface ReviewEdge extends Promise<ReviewEdgeNode> {
  node: <T = Review>() => T;
  cursor: () => Promise<String>;
}

export interface ReviewEdgeSubscription
  extends Promise<AsyncIterator<ReviewEdgeNode>> {
  node: <T = ReviewSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GuestRequirementsSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface GuestRequirementsSubscriptionPayload
  extends Promise<GuestRequirementsSubscriptionPayloadNode> {
  mutation: () => Promise<MutationType>;
  node: <T = GuestRequirements>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GuestRequirementsPreviousValues>() => T;
}

export interface GuestRequirementsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GuestRequirementsSubscriptionPayloadNode>> {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GuestRequirementsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GuestRequirementsPreviousValuesSubscription>() => T;
}

export interface AggregateAmenitiesNode {
  count: Int;
}

export interface AggregateAmenities extends Promise<AggregateAmenitiesNode> {
  count: () => Promise<Int>;
}

export interface AggregateAmenitiesSubscription
  extends Promise<AsyncIterator<AggregateAmenitiesNode>> {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GuestRequirementsPreviousValuesNode {
  id: ID_Output;
  govIssuedId: Boolean;
  recommendationsFromOtherHosts: Boolean;
  guestTripInformation: Boolean;
}

export interface GuestRequirementsPreviousValues
  extends Promise<GuestRequirementsPreviousValuesNode> {
  id: () => Promise<ID_Output>;
  govIssuedId: () => Promise<Boolean>;
  recommendationsFromOtherHosts: () => Promise<Boolean>;
  guestTripInformation: () => Promise<Boolean>;
}

export interface GuestRequirementsPreviousValuesSubscription
  extends Promise<AsyncIterator<GuestRequirementsPreviousValuesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  govIssuedId: () => Promise<AsyncIterator<Boolean>>;
  recommendationsFromOtherHosts: () => Promise<AsyncIterator<Boolean>>;
  guestTripInformation: () => Promise<AsyncIterator<Boolean>>;
}

export interface AmenitiesConnectionNode {}

export interface AmenitiesConnection extends Promise<AmenitiesConnectionNode> {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<AmenitiesEdgeNode>>>() => T;
  aggregate: <T = AggregateAmenities>() => T;
}

export interface AmenitiesConnectionSubscription
  extends Promise<AsyncIterator<AmenitiesConnectionNode>> {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<AmenitiesEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateAmenitiesSubscription>() => T;
}

export interface CreditCardInformationNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  cardNumber: String;
  expiresOnMonth: Int;
  expiresOnYear: Int;
  securityCode: String;
  firstName: String;
  lastName: String;
  postalCode: String;
  country: String;
}

export interface CreditCardInformation
  extends Promise<CreditCardInformationNode> {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  cardNumber: () => Promise<String>;
  expiresOnMonth: () => Promise<Int>;
  expiresOnYear: () => Promise<Int>;
  securityCode: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  postalCode: () => Promise<String>;
  country: () => Promise<String>;
  paymentAccount: <T = PaymentAccount>(
    args?: { where?: PaymentAccountWhereInput },
    fragment?: string | object
  ) => T;
}

export interface CreditCardInformationSubscription
  extends Promise<AsyncIterator<CreditCardInformationNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  cardNumber: () => Promise<AsyncIterator<String>>;
  expiresOnMonth: () => Promise<AsyncIterator<Int>>;
  expiresOnYear: () => Promise<AsyncIterator<Int>>;
  securityCode: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  postalCode: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
  paymentAccount: <T = PaymentAccountSubscription>(
    args?: { where?: PaymentAccountWhereInput },
    fragment?: string | object
  ) => T;
}

export interface AggregateExperienceCategoryNode {
  count: Int;
}

export interface AggregateExperienceCategory
  extends Promise<AggregateExperienceCategoryNode> {
  count: () => Promise<Int>;
}

export interface AggregateExperienceCategorySubscription
  extends Promise<AsyncIterator<AggregateExperienceCategoryNode>> {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PoliciesSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PoliciesSubscriptionPayload
  extends Promise<PoliciesSubscriptionPayloadNode> {
  mutation: () => Promise<MutationType>;
  node: <T = Policies>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PoliciesPreviousValues>() => T;
}

export interface PoliciesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PoliciesSubscriptionPayloadNode>> {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PoliciesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PoliciesPreviousValuesSubscription>() => T;
}

export interface ExperienceCategoryConnectionNode {}

export interface ExperienceCategoryConnection
  extends Promise<ExperienceCategoryConnectionNode> {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<ExperienceCategoryEdgeNode>>>() => T;
  aggregate: <T = AggregateExperienceCategory>() => T;
}

export interface ExperienceCategoryConnectionSubscription
  extends Promise<AsyncIterator<ExperienceCategoryConnectionNode>> {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<Array<ExperienceCategoryEdgeSubscription>>>
  >() => T;
  aggregate: <T = AggregateExperienceCategorySubscription>() => T;
}

export interface PoliciesPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  checkInStartTime: Float;
  checkInEndTime: Float;
  checkoutTime: Float;
}

export interface PoliciesPreviousValues
  extends Promise<PoliciesPreviousValuesNode> {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  checkInStartTime: () => Promise<Float>;
  checkInEndTime: () => Promise<Float>;
  checkoutTime: () => Promise<Float>;
}

export interface PoliciesPreviousValuesSubscription
  extends Promise<AsyncIterator<PoliciesPreviousValuesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  checkInStartTime: () => Promise<AsyncIterator<Float>>;
  checkInEndTime: () => Promise<AsyncIterator<Float>>;
  checkoutTime: () => Promise<AsyncIterator<Float>>;
}

export interface AggregateExperienceNode {
  count: Int;
}

export interface AggregateExperience extends Promise<AggregateExperienceNode> {
  count: () => Promise<Int>;
}

export interface AggregateExperienceSubscription
  extends Promise<AsyncIterator<AggregateExperienceNode>> {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PaypalInformationNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  email: String;
}

export interface PaypalInformation extends Promise<PaypalInformationNode> {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  paymentAccount: <T = PaymentAccount>(
    args?: { where?: PaymentAccountWhereInput },
    fragment?: string | object
  ) => T;
}

export interface PaypalInformationSubscription
  extends Promise<AsyncIterator<PaypalInformationNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  paymentAccount: <T = PaymentAccountSubscription>(
    args?: { where?: PaymentAccountWhereInput },
    fragment?: string | object
  ) => T;
}

export interface ExperienceConnectionNode {}

export interface ExperienceConnection
  extends Promise<ExperienceConnectionNode> {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<ExperienceEdgeNode>>>() => T;
  aggregate: <T = AggregateExperience>() => T;
}

export interface ExperienceConnectionSubscription
  extends Promise<AsyncIterator<ExperienceConnectionNode>> {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<ExperienceEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateExperienceSubscription>() => T;
}

export interface HouseRulesSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface HouseRulesSubscriptionPayload
  extends Promise<HouseRulesSubscriptionPayloadNode> {
  mutation: () => Promise<MutationType>;
  node: <T = HouseRules>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HouseRulesPreviousValues>() => T;
}

export interface HouseRulesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HouseRulesSubscriptionPayloadNode>> {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HouseRulesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HouseRulesPreviousValuesSubscription>() => T;
}

export interface PictureEdgeNode {
  cursor: String;
}

export interface PictureEdge extends Promise<PictureEdgeNode> {
  node: <T = Picture>() => T;
  cursor: () => Promise<String>;
}

export interface PictureEdgeSubscription
  extends Promise<AsyncIterator<PictureEdgeNode>> {
  node: <T = PictureSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface HouseRulesPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  suitableForChildren?: Boolean;
  suitableForInfants?: Boolean;
  petsAllowed?: Boolean;
  smokingAllowed?: Boolean;
  partiesAndEventsAllowed?: Boolean;
  additionalRules?: String;
}

export interface HouseRulesPreviousValues
  extends Promise<HouseRulesPreviousValuesNode> {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  suitableForChildren: () => Promise<Boolean>;
  suitableForInfants: () => Promise<Boolean>;
  petsAllowed: () => Promise<Boolean>;
  smokingAllowed: () => Promise<Boolean>;
  partiesAndEventsAllowed: () => Promise<Boolean>;
  additionalRules: () => Promise<String>;
}

export interface HouseRulesPreviousValuesSubscription
  extends Promise<AsyncIterator<HouseRulesPreviousValuesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  suitableForChildren: () => Promise<AsyncIterator<Boolean>>;
  suitableForInfants: () => Promise<AsyncIterator<Boolean>>;
  petsAllowed: () => Promise<AsyncIterator<Boolean>>;
  smokingAllowed: () => Promise<AsyncIterator<Boolean>>;
  partiesAndEventsAllowed: () => Promise<AsyncIterator<Boolean>>;
  additionalRules: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCityNode {
  count: Int;
}

export interface AggregateCity extends Promise<AggregateCityNode> {
  count: () => Promise<Int>;
}

export interface AggregateCitySubscription
  extends Promise<AsyncIterator<AggregateCityNode>> {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentAccountNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  type?: PAYMENT_PROVIDER;
}

export interface PaymentAccount extends Promise<PaymentAccountNode> {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  type: () => Promise<PAYMENT_PROVIDER>;
  user: <T = User>(
    args?: { where?: UserWhereInput },
    fragment?: string | object
  ) => T;
  payments: <T = Promise<Array<PaymentNode>>>(
    args?: {
      where?: PaymentWhereInput;
      orderBy?: PaymentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  paypal: <T = PaypalInformation>(
    args?: { where?: PaypalInformationWhereInput },
    fragment?: string | object
  ) => T;
  creditcard: <T = CreditCardInformation>(
    args?: { where?: CreditCardInformationWhereInput },
    fragment?: string | object
  ) => T;
}

export interface PaymentAccountSubscription
  extends Promise<AsyncIterator<PaymentAccountNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<PAYMENT_PROVIDER>>;
  user: <T = UserSubscription>(
    args?: { where?: UserWhereInput },
    fragment?: string | object
  ) => T;
  payments: <T = Promise<AsyncIterator<Array<PaymentSubscription>>>>(
    args?: {
      where?: PaymentWhereInput;
      orderBy?: PaymentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  paypal: <T = PaypalInformationSubscription>(
    args?: { where?: PaypalInformationWhereInput },
    fragment?: string | object
  ) => T;
  creditcard: <T = CreditCardInformationSubscription>(
    args?: { where?: CreditCardInformationWhereInput },
    fragment?: string | object
  ) => T;
}

export interface CityConnectionNode {}

export interface CityConnection extends Promise<CityConnectionNode> {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<CityEdgeNode>>>() => T;
  aggregate: <T = AggregateCity>() => T;
}

export interface CityConnectionSubscription
  extends Promise<AsyncIterator<CityConnectionNode>> {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<CityEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateCitySubscription>() => T;
}

export interface ViewsSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ViewsSubscriptionPayload
  extends Promise<ViewsSubscriptionPayloadNode> {
  mutation: () => Promise<MutationType>;
  node: <T = Views>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ViewsPreviousValues>() => T;
}

export interface ViewsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ViewsSubscriptionPayloadNode>> {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ViewsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ViewsPreviousValuesSubscription>() => T;
}

export interface NeighbourhoodEdgeNode {
  cursor: String;
}

export interface NeighbourhoodEdge extends Promise<NeighbourhoodEdgeNode> {
  node: <T = Neighbourhood>() => T;
  cursor: () => Promise<String>;
}

export interface NeighbourhoodEdgeSubscription
  extends Promise<AsyncIterator<NeighbourhoodEdgeNode>> {
  node: <T = NeighbourhoodSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ViewsPreviousValuesNode {
  id: ID_Output;
  lastWeek: Int;
}

export interface ViewsPreviousValues extends Promise<ViewsPreviousValuesNode> {
  id: () => Promise<ID_Output>;
  lastWeek: () => Promise<Int>;
}

export interface ViewsPreviousValuesSubscription
  extends Promise<AsyncIterator<ViewsPreviousValuesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  lastWeek: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateLocationNode {
  count: Int;
}

export interface AggregateLocation extends Promise<AggregateLocationNode> {
  count: () => Promise<Int>;
}

export interface AggregateLocationSubscription
  extends Promise<AsyncIterator<AggregateLocationNode>> {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  serviceFee: Float;
  placePrice: Float;
  totalPrice: Float;
}

export interface Payment extends Promise<PaymentNode> {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  serviceFee: () => Promise<Float>;
  placePrice: () => Promise<Float>;
  totalPrice: () => Promise<Float>;
  booking: <T = Booking>(
    args?: { where?: BookingWhereInput },
    fragment?: string | object
  ) => T;
  paymentMethod: <T = PaymentAccount>(
    args?: { where?: PaymentAccountWhereInput },
    fragment?: string | object
  ) => T;
}

export interface PaymentSubscription
  extends Promise<AsyncIterator<PaymentNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  serviceFee: () => Promise<AsyncIterator<Float>>;
  placePrice: () => Promise<AsyncIterator<Float>>;
  totalPrice: () => Promise<AsyncIterator<Float>>;
  booking: <T = BookingSubscription>(
    args?: { where?: BookingWhereInput },
    fragment?: string | object
  ) => T;
  paymentMethod: <T = PaymentAccountSubscription>(
    args?: { where?: PaymentAccountWhereInput },
    fragment?: string | object
  ) => T;
}

export interface LocationConnectionNode {}

export interface LocationConnection extends Promise<LocationConnectionNode> {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<LocationEdgeNode>>>() => T;
  aggregate: <T = AggregateLocation>() => T;
}

export interface LocationConnectionSubscription
  extends Promise<AsyncIterator<LocationConnectionNode>> {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<LocationEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateLocationSubscription>() => T;
}

export interface LocationSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface LocationSubscriptionPayload
  extends Promise<LocationSubscriptionPayloadNode> {
  mutation: () => Promise<MutationType>;
  node: <T = Location>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LocationPreviousValues>() => T;
}

export interface LocationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LocationSubscriptionPayloadNode>> {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LocationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LocationPreviousValuesSubscription>() => T;
}

export interface ViewsEdgeNode {
  cursor: String;
}

export interface ViewsEdge extends Promise<ViewsEdgeNode> {
  node: <T = Views>() => T;
  cursor: () => Promise<String>;
}

export interface ViewsEdgeSubscription
  extends Promise<AsyncIterator<ViewsEdgeNode>> {
  node: <T = ViewsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LocationPreviousValuesNode {
  id: ID_Output;
  lat: Float;
  lng: Float;
  address?: String;
  directions?: String;
}

export interface LocationPreviousValues
  extends Promise<LocationPreviousValuesNode> {
  id: () => Promise<ID_Output>;
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
  address: () => Promise<String>;
  directions: () => Promise<String>;
}

export interface LocationPreviousValuesSubscription
  extends Promise<AsyncIterator<LocationPreviousValuesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  lat: () => Promise<AsyncIterator<Float>>;
  lng: () => Promise<AsyncIterator<Float>>;
  address: () => Promise<AsyncIterator<String>>;
  directions: () => Promise<AsyncIterator<String>>;
}

export interface AggregateHouseRulesNode {
  count: Int;
}

export interface AggregateHouseRules extends Promise<AggregateHouseRulesNode> {
  count: () => Promise<Int>;
}

export interface AggregateHouseRulesSubscription
  extends Promise<AsyncIterator<AggregateHouseRulesNode>> {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BookingNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  startDate: DateTimeOutput;
  endDate: DateTimeOutput;
}

export interface Booking extends Promise<BookingNode> {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  bookee: <T = User>(
    args?: { where?: UserWhereInput },
    fragment?: string | object
  ) => T;
  place: <T = Place>(
    args?: { where?: PlaceWhereInput },
    fragment?: string | object
  ) => T;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  payment: <T = Payment>(
    args?: { where?: PaymentWhereInput },
    fragment?: string | object
  ) => T;
}

export interface BookingSubscription
  extends Promise<AsyncIterator<BookingNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  bookee: <T = UserSubscription>(
    args?: { where?: UserWhereInput },
    fragment?: string | object
  ) => T;
  place: <T = PlaceSubscription>(
    args?: { where?: PlaceWhereInput },
    fragment?: string | object
  ) => T;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  payment: <T = PaymentSubscription>(
    args?: { where?: PaymentWhereInput },
    fragment?: string | object
  ) => T;
}

export interface HouseRulesConnectionNode {}

export interface HouseRulesConnection
  extends Promise<HouseRulesConnectionNode> {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<HouseRulesEdgeNode>>>() => T;
  aggregate: <T = AggregateHouseRules>() => T;
}

export interface HouseRulesConnectionSubscription
  extends Promise<AsyncIterator<HouseRulesConnectionNode>> {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<HouseRulesEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateHouseRulesSubscription>() => T;
}

export interface NeighbourhoodSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface NeighbourhoodSubscriptionPayload
  extends Promise<NeighbourhoodSubscriptionPayloadNode> {
  mutation: () => Promise<MutationType>;
  node: <T = Neighbourhood>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NeighbourhoodPreviousValues>() => T;
}

export interface NeighbourhoodSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NeighbourhoodSubscriptionPayloadNode>> {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NeighbourhoodSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NeighbourhoodPreviousValuesSubscription>() => T;
}

export interface PoliciesEdgeNode {
  cursor: String;
}

export interface PoliciesEdge extends Promise<PoliciesEdgeNode> {
  node: <T = Policies>() => T;
  cursor: () => Promise<String>;
}

export interface PoliciesEdgeSubscription
  extends Promise<AsyncIterator<PoliciesEdgeNode>> {
  node: <T = PoliciesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface NeighbourhoodPreviousValuesNode {
  id: ID_Output;
  name: String;
  slug: String;
  featured: Boolean;
  popularity: Int;
}

export interface NeighbourhoodPreviousValues
  extends Promise<NeighbourhoodPreviousValuesNode> {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  featured: () => Promise<Boolean>;
  popularity: () => Promise<Int>;
}

export interface NeighbourhoodPreviousValuesSubscription
  extends Promise<AsyncIterator<NeighbourhoodPreviousValuesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  featured: () => Promise<AsyncIterator<Boolean>>;
  popularity: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateGuestRequirementsNode {
  count: Int;
}

export interface AggregateGuestRequirements
  extends Promise<AggregateGuestRequirementsNode> {
  count: () => Promise<Int>;
}

export interface AggregateGuestRequirementsSubscription
  extends Promise<AsyncIterator<AggregateGuestRequirementsNode>> {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HouseRulesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  suitableForChildren?: Boolean;
  suitableForInfants?: Boolean;
  petsAllowed?: Boolean;
  smokingAllowed?: Boolean;
  partiesAndEventsAllowed?: Boolean;
  additionalRules?: String;
}

export interface HouseRules extends Promise<HouseRulesNode> {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  suitableForChildren: () => Promise<Boolean>;
  suitableForInfants: () => Promise<Boolean>;
  petsAllowed: () => Promise<Boolean>;
  smokingAllowed: () => Promise<Boolean>;
  partiesAndEventsAllowed: () => Promise<Boolean>;
  additionalRules: () => Promise<String>;
}

export interface HouseRulesSubscription
  extends Promise<AsyncIterator<HouseRulesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  suitableForChildren: () => Promise<AsyncIterator<Boolean>>;
  suitableForInfants: () => Promise<AsyncIterator<Boolean>>;
  petsAllowed: () => Promise<AsyncIterator<Boolean>>;
  smokingAllowed: () => Promise<AsyncIterator<Boolean>>;
  partiesAndEventsAllowed: () => Promise<AsyncIterator<Boolean>>;
  additionalRules: () => Promise<AsyncIterator<String>>;
}

export interface GuestRequirementsConnectionNode {}

export interface GuestRequirementsConnection
  extends Promise<GuestRequirementsConnectionNode> {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<GuestRequirementsEdgeNode>>>() => T;
  aggregate: <T = AggregateGuestRequirements>() => T;
}

export interface GuestRequirementsConnectionSubscription
  extends Promise<AsyncIterator<GuestRequirementsConnectionNode>> {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<Array<GuestRequirementsEdgeSubscription>>>
  >() => T;
  aggregate: <T = AggregateGuestRequirementsSubscription>() => T;
}

export interface CitySubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface CitySubscriptionPayload
  extends Promise<CitySubscriptionPayloadNode> {
  mutation: () => Promise<MutationType>;
  node: <T = City>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CityPreviousValues>() => T;
}

export interface CitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CitySubscriptionPayloadNode>> {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CityPreviousValuesSubscription>() => T;
}

export interface PricingEdgeNode {
  cursor: String;
}

export interface PricingEdge extends Promise<PricingEdgeNode> {
  node: <T = Pricing>() => T;
  cursor: () => Promise<String>;
}

export interface PricingEdgeSubscription
  extends Promise<AsyncIterator<PricingEdgeNode>> {
  node: <T = PricingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CityPreviousValuesNode {
  id: ID_Output;
  name: String;
}

export interface CityPreviousValues extends Promise<CityPreviousValuesNode> {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface CityPreviousValuesSubscription
  extends Promise<AsyncIterator<CityPreviousValuesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface RestaurantEdgeNode {
  cursor: String;
}

export interface RestaurantEdge extends Promise<RestaurantEdgeNode> {
  node: <T = Restaurant>() => T;
  cursor: () => Promise<String>;
}

export interface RestaurantEdgeSubscription
  extends Promise<AsyncIterator<RestaurantEdgeNode>> {
  node: <T = RestaurantSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PoliciesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  checkInStartTime: Float;
  checkInEndTime: Float;
  checkoutTime: Float;
}

export interface Policies extends Promise<PoliciesNode> {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  checkInStartTime: () => Promise<Float>;
  checkInEndTime: () => Promise<Float>;
  checkoutTime: () => Promise<Float>;
  place: <T = Place>(
    args?: { where?: PlaceWhereInput },
    fragment?: string | object
  ) => T;
}

export interface PoliciesSubscription
  extends Promise<AsyncIterator<PoliciesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  checkInStartTime: () => Promise<AsyncIterator<Float>>;
  checkInEndTime: () => Promise<AsyncIterator<Float>>;
  checkoutTime: () => Promise<AsyncIterator<Float>>;
  place: <T = PlaceSubscription>(
    args?: { where?: PlaceWhereInput },
    fragment?: string | object
  ) => T;
}

export interface NotificationEdgeNode {
  cursor: String;
}

export interface NotificationEdge extends Promise<NotificationEdgeNode> {
  node: <T = Notification>() => T;
  cursor: () => Promise<String>;
}

export interface NotificationEdgeSubscription
  extends Promise<AsyncIterator<NotificationEdgeNode>> {
  node: <T = NotificationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PictureSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PictureSubscriptionPayload
  extends Promise<PictureSubscriptionPayloadNode> {
  mutation: () => Promise<MutationType>;
  node: <T = Picture>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PicturePreviousValues>() => T;
}

export interface PictureSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PictureSubscriptionPayloadNode>> {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PictureSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PicturePreviousValuesSubscription>() => T;
}

export interface MessageConnectionNode {}

export interface MessageConnection extends Promise<MessageConnectionNode> {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<MessageEdgeNode>>>() => T;
  aggregate: <T = AggregateMessage>() => T;
}

export interface MessageConnectionSubscription
  extends Promise<AsyncIterator<MessageConnectionNode>> {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<MessageEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateMessageSubscription>() => T;
}

export interface PicturePreviousValuesNode {
  id: ID_Output;
  url: String;
}

export interface PicturePreviousValues
  extends Promise<PicturePreviousValuesNode> {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
}

export interface PicturePreviousValuesSubscription
  extends Promise<AsyncIterator<PicturePreviousValuesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface RestaurantSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface RestaurantSubscriptionPayload
  extends Promise<RestaurantSubscriptionPayloadNode> {
  mutation: () => Promise<MutationType>;
  node: <T = Restaurant>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RestaurantPreviousValues>() => T;
}

export interface RestaurantSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RestaurantSubscriptionPayloadNode>> {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RestaurantSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RestaurantPreviousValuesSubscription>() => T;
}

export interface GuestRequirementsNode {
  id: ID_Output;
  govIssuedId: Boolean;
  recommendationsFromOtherHosts: Boolean;
  guestTripInformation: Boolean;
}

export interface GuestRequirements extends Promise<GuestRequirementsNode> {
  id: () => Promise<ID_Output>;
  govIssuedId: () => Promise<Boolean>;
  recommendationsFromOtherHosts: () => Promise<Boolean>;
  guestTripInformation: () => Promise<Boolean>;
  place: <T = Place>(
    args?: { where?: PlaceWhereInput },
    fragment?: string | object
  ) => T;
}

export interface GuestRequirementsSubscription
  extends Promise<AsyncIterator<GuestRequirementsNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  govIssuedId: () => Promise<AsyncIterator<Boolean>>;
  recommendationsFromOtherHosts: () => Promise<AsyncIterator<Boolean>>;
  guestTripInformation: () => Promise<AsyncIterator<Boolean>>;
  place: <T = PlaceSubscription>(
    args?: { where?: PlaceWhereInput },
    fragment?: string | object
  ) => T;
}

export interface ReviewNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  text: String;
  stars: Int;
  accuracy: Int;
  location: Int;
  checkIn: Int;
  value: Int;
  cleanliness: Int;
  communication: Int;
}

export interface Review extends Promise<ReviewNode> {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  text: () => Promise<String>;
  stars: () => Promise<Int>;
  accuracy: () => Promise<Int>;
  location: () => Promise<Int>;
  checkIn: () => Promise<Int>;
  value: () => Promise<Int>;
  cleanliness: () => Promise<Int>;
  communication: () => Promise<Int>;
  place: <T = Place>(
    args?: { where?: PlaceWhereInput },
    fragment?: string | object
  ) => T;
  experience: <T = Experience>(
    args?: { where?: ExperienceWhereInput },
    fragment?: string | object
  ) => T;
}

export interface ReviewSubscription extends Promise<AsyncIterator<ReviewNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  text: () => Promise<AsyncIterator<String>>;
  stars: () => Promise<AsyncIterator<Int>>;
  accuracy: () => Promise<AsyncIterator<Int>>;
  location: () => Promise<AsyncIterator<Int>>;
  checkIn: () => Promise<AsyncIterator<Int>>;
  value: () => Promise<AsyncIterator<Int>>;
  cleanliness: () => Promise<AsyncIterator<Int>>;
  communication: () => Promise<AsyncIterator<Int>>;
  place: <T = PlaceSubscription>(
    args?: { where?: PlaceWhereInput },
    fragment?: string | object
  ) => T;
  experience: <T = ExperienceSubscription>(
    args?: { where?: ExperienceWhereInput },
    fragment?: string | object
  ) => T;
}

export interface ExperienceSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ExperienceSubscriptionPayload
  extends Promise<ExperienceSubscriptionPayloadNode> {
  mutation: () => Promise<MutationType>;
  node: <T = Experience>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExperiencePreviousValues>() => T;
}

export interface ExperienceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExperienceSubscriptionPayloadNode>> {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExperienceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExperiencePreviousValuesSubscription>() => T;
}

export interface AggregatePaymentNode {
  count: Int;
}

export interface AggregatePayment extends Promise<AggregatePaymentNode> {
  count: () => Promise<Int>;
}

export interface AggregatePaymentSubscription
  extends Promise<AsyncIterator<AggregatePaymentNode>> {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExperiencePreviousValuesNode {
  id: ID_Output;
  title: String;
  pricePerPerson: Int;
  popularity: Int;
}

export interface ExperiencePreviousValues
  extends Promise<ExperiencePreviousValuesNode> {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  pricePerPerson: () => Promise<Int>;
  popularity: () => Promise<Int>;
}

export interface ExperiencePreviousValuesSubscription
  extends Promise<AsyncIterator<ExperiencePreviousValuesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  pricePerPerson: () => Promise<AsyncIterator<Int>>;
  popularity: () => Promise<AsyncIterator<Int>>;
}

export interface BookingEdgeNode {
  cursor: String;
}

export interface BookingEdge extends Promise<BookingEdgeNode> {
  node: <T = Booking>() => T;
  cursor: () => Promise<String>;
}

export interface BookingEdgeSubscription
  extends Promise<AsyncIterator<BookingEdgeNode>> {
  node: <T = BookingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ViewsNode {
  id: ID_Output;
  lastWeek: Int;
}

export interface Views extends Promise<ViewsNode> {
  id: () => Promise<ID_Output>;
  lastWeek: () => Promise<Int>;
  place: <T = Place>(
    args?: { where?: PlaceWhereInput },
    fragment?: string | object
  ) => T;
}

export interface ViewsSubscription extends Promise<AsyncIterator<ViewsNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  lastWeek: () => Promise<AsyncIterator<Int>>;
  place: <T = PlaceSubscription>(
    args?: { where?: PlaceWhereInput },
    fragment?: string | object
  ) => T;
}

export interface ReviewConnectionNode {}

export interface ReviewConnection extends Promise<ReviewConnectionNode> {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<ReviewEdgeNode>>>() => T;
  aggregate: <T = AggregateReview>() => T;
}

export interface ReviewConnectionSubscription
  extends Promise<AsyncIterator<ReviewConnectionNode>> {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<ReviewEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateReviewSubscription>() => T;
}

export interface ExperienceCategorySubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ExperienceCategorySubscriptionPayload
  extends Promise<ExperienceCategorySubscriptionPayloadNode> {
  mutation: () => Promise<MutationType>;
  node: <T = ExperienceCategory>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExperienceCategoryPreviousValues>() => T;
}

export interface ExperienceCategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExperienceCategorySubscriptionPayloadNode>> {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExperienceCategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExperienceCategoryPreviousValuesSubscription>() => T;
}

export interface NotificationPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  type?: NOTIFICATION_TYPE;
  link: String;
  readDate: DateTimeOutput;
}

export interface NotificationPreviousValues
  extends Promise<NotificationPreviousValuesNode> {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  type: () => Promise<NOTIFICATION_TYPE>;
  link: () => Promise<String>;
  readDate: () => Promise<DateTimeOutput>;
}

export interface NotificationPreviousValuesSubscription
  extends Promise<AsyncIterator<NotificationPreviousValuesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<NOTIFICATION_TYPE>>;
  link: () => Promise<AsyncIterator<String>>;
  readDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ExperienceCategoryPreviousValuesNode {
  id: ID_Output;
  mainColor: String;
  name: String;
}

export interface ExperienceCategoryPreviousValues
  extends Promise<ExperienceCategoryPreviousValuesNode> {
  id: () => Promise<ID_Output>;
  mainColor: () => Promise<String>;
  name: () => Promise<String>;
}

export interface ExperienceCategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<ExperienceCategoryPreviousValuesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  mainColor: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface NotificationSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface NotificationSubscriptionPayload
  extends Promise<NotificationSubscriptionPayloadNode> {
  mutation: () => Promise<MutationType>;
  node: <T = Notification>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NotificationPreviousValues>() => T;
}

export interface NotificationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NotificationSubscriptionPayloadNode>> {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NotificationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NotificationPreviousValuesSubscription>() => T;
}

export interface PricingNode {
  id: ID_Output;
  monthlyDiscount?: Int;
  weeklyDiscount?: Int;
  perNight: Int;
  smartPricing: Boolean;
  basePrice: Int;
  averageWeekly: Int;
  averageMonthly: Int;
  cleaningFee?: Int;
  securityDeposit?: Int;
  extraGuests?: Int;
  weekendPricing?: Int;
  currency?: CURRENCY;
}

export interface Pricing extends Promise<PricingNode> {
  id: () => Promise<ID_Output>;
  place: <T = Place>(
    args?: { where?: PlaceWhereInput },
    fragment?: string | object
  ) => T;
  monthlyDiscount: () => Promise<Int>;
  weeklyDiscount: () => Promise<Int>;
  perNight: () => Promise<Int>;
  smartPricing: () => Promise<Boolean>;
  basePrice: () => Promise<Int>;
  averageWeekly: () => Promise<Int>;
  averageMonthly: () => Promise<Int>;
  cleaningFee: () => Promise<Int>;
  securityDeposit: () => Promise<Int>;
  extraGuests: () => Promise<Int>;
  weekendPricing: () => Promise<Int>;
  currency: () => Promise<CURRENCY>;
}

export interface PricingSubscription
  extends Promise<AsyncIterator<PricingNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  place: <T = PlaceSubscription>(
    args?: { where?: PlaceWhereInput },
    fragment?: string | object
  ) => T;
  monthlyDiscount: () => Promise<AsyncIterator<Int>>;
  weeklyDiscount: () => Promise<AsyncIterator<Int>>;
  perNight: () => Promise<AsyncIterator<Int>>;
  smartPricing: () => Promise<AsyncIterator<Boolean>>;
  basePrice: () => Promise<AsyncIterator<Int>>;
  averageWeekly: () => Promise<AsyncIterator<Int>>;
  averageMonthly: () => Promise<AsyncIterator<Int>>;
  cleaningFee: () => Promise<AsyncIterator<Int>>;
  securityDeposit: () => Promise<AsyncIterator<Int>>;
  extraGuests: () => Promise<AsyncIterator<Int>>;
  weekendPricing: () => Promise<AsyncIterator<Int>>;
  currency: () => Promise<AsyncIterator<CURRENCY>>;
}

export interface AggregatePictureNode {
  count: Int;
}

export interface AggregatePicture extends Promise<AggregatePictureNode> {
  count: () => Promise<Int>;
}

export interface AggregatePictureSubscription
  extends Promise<AsyncIterator<AggregatePictureNode>> {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AmenitiesSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface AmenitiesSubscriptionPayload
  extends Promise<AmenitiesSubscriptionPayloadNode> {
  mutation: () => Promise<MutationType>;
  node: <T = Amenities>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AmenitiesPreviousValues>() => T;
}

export interface AmenitiesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AmenitiesSubscriptionPayloadNode>> {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AmenitiesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AmenitiesPreviousValuesSubscription>() => T;
}

export interface CityEdgeNode {
  cursor: String;
}

export interface CityEdge extends Promise<CityEdgeNode> {
  node: <T = City>() => T;
  cursor: () => Promise<String>;
}

export interface CityEdgeSubscription
  extends Promise<AsyncIterator<CityEdgeNode>> {
  node: <T = CitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AmenitiesPreviousValuesNode {
  id: ID_Output;
  elevator: Boolean;
  petsAllowed: Boolean;
  internet: Boolean;
  kitchen: Boolean;
  wirelessInternet: Boolean;
  familyKidFriendly: Boolean;
  freeParkingOnPremises: Boolean;
  hotTub: Boolean;
  pool: Boolean;
  smokingAllowed: Boolean;
  wheelchairAccessible: Boolean;
  breakfast: Boolean;
  cableTv: Boolean;
  suitableForEvents: Boolean;
  dryer: Boolean;
  washer: Boolean;
  indoorFireplace: Boolean;
  tv: Boolean;
  heating: Boolean;
  hangers: Boolean;
  iron: Boolean;
  hairDryer: Boolean;
  doorman: Boolean;
  paidParkingOffPremises: Boolean;
  freeParkingOnStreet: Boolean;
  gym: Boolean;
  airConditioning: Boolean;
  shampoo: Boolean;
  essentials: Boolean;
  laptopFriendlyWorkspace: Boolean;
  privateEntrance: Boolean;
  buzzerWirelessIntercom: Boolean;
  babyBath: Boolean;
  babyMonitor: Boolean;
  babysitterRecommendations: Boolean;
  bathtub: Boolean;
  changingTable: Boolean;
  childrensBooksAndToys: Boolean;
  childrensDinnerware: Boolean;
  crib: Boolean;
}

export interface AmenitiesPreviousValues
  extends Promise<AmenitiesPreviousValuesNode> {
  id: () => Promise<ID_Output>;
  elevator: () => Promise<Boolean>;
  petsAllowed: () => Promise<Boolean>;
  internet: () => Promise<Boolean>;
  kitchen: () => Promise<Boolean>;
  wirelessInternet: () => Promise<Boolean>;
  familyKidFriendly: () => Promise<Boolean>;
  freeParkingOnPremises: () => Promise<Boolean>;
  hotTub: () => Promise<Boolean>;
  pool: () => Promise<Boolean>;
  smokingAllowed: () => Promise<Boolean>;
  wheelchairAccessible: () => Promise<Boolean>;
  breakfast: () => Promise<Boolean>;
  cableTv: () => Promise<Boolean>;
  suitableForEvents: () => Promise<Boolean>;
  dryer: () => Promise<Boolean>;
  washer: () => Promise<Boolean>;
  indoorFireplace: () => Promise<Boolean>;
  tv: () => Promise<Boolean>;
  heating: () => Promise<Boolean>;
  hangers: () => Promise<Boolean>;
  iron: () => Promise<Boolean>;
  hairDryer: () => Promise<Boolean>;
  doorman: () => Promise<Boolean>;
  paidParkingOffPremises: () => Promise<Boolean>;
  freeParkingOnStreet: () => Promise<Boolean>;
  gym: () => Promise<Boolean>;
  airConditioning: () => Promise<Boolean>;
  shampoo: () => Promise<Boolean>;
  essentials: () => Promise<Boolean>;
  laptopFriendlyWorkspace: () => Promise<Boolean>;
  privateEntrance: () => Promise<Boolean>;
  buzzerWirelessIntercom: () => Promise<Boolean>;
  babyBath: () => Promise<Boolean>;
  babyMonitor: () => Promise<Boolean>;
  babysitterRecommendations: () => Promise<Boolean>;
  bathtub: () => Promise<Boolean>;
  changingTable: () => Promise<Boolean>;
  childrensBooksAndToys: () => Promise<Boolean>;
  childrensDinnerware: () => Promise<Boolean>;
  crib: () => Promise<Boolean>;
}

export interface AmenitiesPreviousValuesSubscription
  extends Promise<AsyncIterator<AmenitiesPreviousValuesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  elevator: () => Promise<AsyncIterator<Boolean>>;
  petsAllowed: () => Promise<AsyncIterator<Boolean>>;
  internet: () => Promise<AsyncIterator<Boolean>>;
  kitchen: () => Promise<AsyncIterator<Boolean>>;
  wirelessInternet: () => Promise<AsyncIterator<Boolean>>;
  familyKidFriendly: () => Promise<AsyncIterator<Boolean>>;
  freeParkingOnPremises: () => Promise<AsyncIterator<Boolean>>;
  hotTub: () => Promise<AsyncIterator<Boolean>>;
  pool: () => Promise<AsyncIterator<Boolean>>;
  smokingAllowed: () => Promise<AsyncIterator<Boolean>>;
  wheelchairAccessible: () => Promise<AsyncIterator<Boolean>>;
  breakfast: () => Promise<AsyncIterator<Boolean>>;
  cableTv: () => Promise<AsyncIterator<Boolean>>;
  suitableForEvents: () => Promise<AsyncIterator<Boolean>>;
  dryer: () => Promise<AsyncIterator<Boolean>>;
  washer: () => Promise<AsyncIterator<Boolean>>;
  indoorFireplace: () => Promise<AsyncIterator<Boolean>>;
  tv: () => Promise<AsyncIterator<Boolean>>;
  heating: () => Promise<AsyncIterator<Boolean>>;
  hangers: () => Promise<AsyncIterator<Boolean>>;
  iron: () => Promise<AsyncIterator<Boolean>>;
  hairDryer: () => Promise<AsyncIterator<Boolean>>;
  doorman: () => Promise<AsyncIterator<Boolean>>;
  paidParkingOffPremises: () => Promise<AsyncIterator<Boolean>>;
  freeParkingOnStreet: () => Promise<AsyncIterator<Boolean>>;
  gym: () => Promise<AsyncIterator<Boolean>>;
  airConditioning: () => Promise<AsyncIterator<Boolean>>;
  shampoo: () => Promise<AsyncIterator<Boolean>>;
  essentials: () => Promise<AsyncIterator<Boolean>>;
  laptopFriendlyWorkspace: () => Promise<AsyncIterator<Boolean>>;
  privateEntrance: () => Promise<AsyncIterator<Boolean>>;
  buzzerWirelessIntercom: () => Promise<AsyncIterator<Boolean>>;
  babyBath: () => Promise<AsyncIterator<Boolean>>;
  babyMonitor: () => Promise<AsyncIterator<Boolean>>;
  babysitterRecommendations: () => Promise<AsyncIterator<Boolean>>;
  bathtub: () => Promise<AsyncIterator<Boolean>>;
  changingTable: () => Promise<AsyncIterator<Boolean>>;
  childrensBooksAndToys: () => Promise<AsyncIterator<Boolean>>;
  childrensDinnerware: () => Promise<AsyncIterator<Boolean>>;
  crib: () => Promise<AsyncIterator<Boolean>>;
}

export interface NeighbourhoodConnectionNode {}

export interface NeighbourhoodConnection
  extends Promise<NeighbourhoodConnectionNode> {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<NeighbourhoodEdgeNode>>>() => T;
  aggregate: <T = AggregateNeighbourhood>() => T;
}

export interface NeighbourhoodConnectionSubscription
  extends Promise<AsyncIterator<NeighbourhoodConnectionNode>> {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<Array<NeighbourhoodEdgeSubscription>>>
  >() => T;
  aggregate: <T = AggregateNeighbourhoodSubscription>() => T;
}

export interface AmenitiesNode {
  id: ID_Output;
  elevator: Boolean;
  petsAllowed: Boolean;
  internet: Boolean;
  kitchen: Boolean;
  wirelessInternet: Boolean;
  familyKidFriendly: Boolean;
  freeParkingOnPremises: Boolean;
  hotTub: Boolean;
  pool: Boolean;
  smokingAllowed: Boolean;
  wheelchairAccessible: Boolean;
  breakfast: Boolean;
  cableTv: Boolean;
  suitableForEvents: Boolean;
  dryer: Boolean;
  washer: Boolean;
  indoorFireplace: Boolean;
  tv: Boolean;
  heating: Boolean;
  hangers: Boolean;
  iron: Boolean;
  hairDryer: Boolean;
  doorman: Boolean;
  paidParkingOffPremises: Boolean;
  freeParkingOnStreet: Boolean;
  gym: Boolean;
  airConditioning: Boolean;
  shampoo: Boolean;
  essentials: Boolean;
  laptopFriendlyWorkspace: Boolean;
  privateEntrance: Boolean;
  buzzerWirelessIntercom: Boolean;
  babyBath: Boolean;
  babyMonitor: Boolean;
  babysitterRecommendations: Boolean;
  bathtub: Boolean;
  changingTable: Boolean;
  childrensBooksAndToys: Boolean;
  childrensDinnerware: Boolean;
  crib: Boolean;
}

export interface Amenities extends Promise<AmenitiesNode> {
  id: () => Promise<ID_Output>;
  place: <T = Place>(
    args?: { where?: PlaceWhereInput },
    fragment?: string | object
  ) => T;
  elevator: () => Promise<Boolean>;
  petsAllowed: () => Promise<Boolean>;
  internet: () => Promise<Boolean>;
  kitchen: () => Promise<Boolean>;
  wirelessInternet: () => Promise<Boolean>;
  familyKidFriendly: () => Promise<Boolean>;
  freeParkingOnPremises: () => Promise<Boolean>;
  hotTub: () => Promise<Boolean>;
  pool: () => Promise<Boolean>;
  smokingAllowed: () => Promise<Boolean>;
  wheelchairAccessible: () => Promise<Boolean>;
  breakfast: () => Promise<Boolean>;
  cableTv: () => Promise<Boolean>;
  suitableForEvents: () => Promise<Boolean>;
  dryer: () => Promise<Boolean>;
  washer: () => Promise<Boolean>;
  indoorFireplace: () => Promise<Boolean>;
  tv: () => Promise<Boolean>;
  heating: () => Promise<Boolean>;
  hangers: () => Promise<Boolean>;
  iron: () => Promise<Boolean>;
  hairDryer: () => Promise<Boolean>;
  doorman: () => Promise<Boolean>;
  paidParkingOffPremises: () => Promise<Boolean>;
  freeParkingOnStreet: () => Promise<Boolean>;
  gym: () => Promise<Boolean>;
  airConditioning: () => Promise<Boolean>;
  shampoo: () => Promise<Boolean>;
  essentials: () => Promise<Boolean>;
  laptopFriendlyWorkspace: () => Promise<Boolean>;
  privateEntrance: () => Promise<Boolean>;
  buzzerWirelessIntercom: () => Promise<Boolean>;
  babyBath: () => Promise<Boolean>;
  babyMonitor: () => Promise<Boolean>;
  babysitterRecommendations: () => Promise<Boolean>;
  bathtub: () => Promise<Boolean>;
  changingTable: () => Promise<Boolean>;
  childrensBooksAndToys: () => Promise<Boolean>;
  childrensDinnerware: () => Promise<Boolean>;
  crib: () => Promise<Boolean>;
}

export interface AmenitiesSubscription
  extends Promise<AsyncIterator<AmenitiesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  place: <T = PlaceSubscription>(
    args?: { where?: PlaceWhereInput },
    fragment?: string | object
  ) => T;
  elevator: () => Promise<AsyncIterator<Boolean>>;
  petsAllowed: () => Promise<AsyncIterator<Boolean>>;
  internet: () => Promise<AsyncIterator<Boolean>>;
  kitchen: () => Promise<AsyncIterator<Boolean>>;
  wirelessInternet: () => Promise<AsyncIterator<Boolean>>;
  familyKidFriendly: () => Promise<AsyncIterator<Boolean>>;
  freeParkingOnPremises: () => Promise<AsyncIterator<Boolean>>;
  hotTub: () => Promise<AsyncIterator<Boolean>>;
  pool: () => Promise<AsyncIterator<Boolean>>;
  smokingAllowed: () => Promise<AsyncIterator<Boolean>>;
  wheelchairAccessible: () => Promise<AsyncIterator<Boolean>>;
  breakfast: () => Promise<AsyncIterator<Boolean>>;
  cableTv: () => Promise<AsyncIterator<Boolean>>;
  suitableForEvents: () => Promise<AsyncIterator<Boolean>>;
  dryer: () => Promise<AsyncIterator<Boolean>>;
  washer: () => Promise<AsyncIterator<Boolean>>;
  indoorFireplace: () => Promise<AsyncIterator<Boolean>>;
  tv: () => Promise<AsyncIterator<Boolean>>;
  heating: () => Promise<AsyncIterator<Boolean>>;
  hangers: () => Promise<AsyncIterator<Boolean>>;
  iron: () => Promise<AsyncIterator<Boolean>>;
  hairDryer: () => Promise<AsyncIterator<Boolean>>;
  doorman: () => Promise<AsyncIterator<Boolean>>;
  paidParkingOffPremises: () => Promise<AsyncIterator<Boolean>>;
  freeParkingOnStreet: () => Promise<AsyncIterator<Boolean>>;
  gym: () => Promise<AsyncIterator<Boolean>>;
  airConditioning: () => Promise<AsyncIterator<Boolean>>;
  shampoo: () => Promise<AsyncIterator<Boolean>>;
  essentials: () => Promise<AsyncIterator<Boolean>>;
  laptopFriendlyWorkspace: () => Promise<AsyncIterator<Boolean>>;
  privateEntrance: () => Promise<AsyncIterator<Boolean>>;
  buzzerWirelessIntercom: () => Promise<AsyncIterator<Boolean>>;
  babyBath: () => Promise<AsyncIterator<Boolean>>;
  babyMonitor: () => Promise<AsyncIterator<Boolean>>;
  babysitterRecommendations: () => Promise<AsyncIterator<Boolean>>;
  bathtub: () => Promise<AsyncIterator<Boolean>>;
  changingTable: () => Promise<AsyncIterator<Boolean>>;
  childrensBooksAndToys: () => Promise<AsyncIterator<Boolean>>;
  childrensDinnerware: () => Promise<AsyncIterator<Boolean>>;
  crib: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregateViewsNode {
  count: Int;
}

export interface AggregateViews extends Promise<AggregateViewsNode> {
  count: () => Promise<Int>;
}

export interface AggregateViewsSubscription
  extends Promise<AsyncIterator<AggregateViewsNode>> {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ReviewSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ReviewSubscriptionPayload
  extends Promise<ReviewSubscriptionPayloadNode> {
  mutation: () => Promise<MutationType>;
  node: <T = Review>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReviewPreviousValues>() => T;
}

export interface ReviewSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReviewSubscriptionPayloadNode>> {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReviewSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReviewPreviousValuesSubscription>() => T;
}

export interface HouseRulesEdgeNode {
  cursor: String;
}

export interface HouseRulesEdge extends Promise<HouseRulesEdgeNode> {
  node: <T = HouseRules>() => T;
  cursor: () => Promise<String>;
}

export interface HouseRulesEdgeSubscription
  extends Promise<AsyncIterator<HouseRulesEdgeNode>> {
  node: <T = HouseRulesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ReviewPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  text: String;
  stars: Int;
  accuracy: Int;
  location: Int;
  checkIn: Int;
  value: Int;
  cleanliness: Int;
  communication: Int;
}

export interface ReviewPreviousValues
  extends Promise<ReviewPreviousValuesNode> {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  text: () => Promise<String>;
  stars: () => Promise<Int>;
  accuracy: () => Promise<Int>;
  location: () => Promise<Int>;
  checkIn: () => Promise<Int>;
  value: () => Promise<Int>;
  cleanliness: () => Promise<Int>;
  communication: () => Promise<Int>;
}

export interface ReviewPreviousValuesSubscription
  extends Promise<AsyncIterator<ReviewPreviousValuesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  text: () => Promise<AsyncIterator<String>>;
  stars: () => Promise<AsyncIterator<Int>>;
  accuracy: () => Promise<AsyncIterator<Int>>;
  location: () => Promise<AsyncIterator<Int>>;
  checkIn: () => Promise<AsyncIterator<Int>>;
  value: () => Promise<AsyncIterator<Int>>;
  cleanliness: () => Promise<AsyncIterator<Int>>;
  communication: () => Promise<AsyncIterator<Int>>;
}

export interface PoliciesConnectionNode {}

export interface PoliciesConnection extends Promise<PoliciesConnectionNode> {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<PoliciesEdgeNode>>>() => T;
  aggregate: <T = AggregatePolicies>() => T;
}

export interface PoliciesConnectionSubscription
  extends Promise<AsyncIterator<PoliciesConnectionNode>> {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<PoliciesEdgeSubscription>>>>() => T;
  aggregate: <T = AggregatePoliciesSubscription>() => T;
}

export interface RestaurantNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  title: String;
  avgPricePerPerson: Int;
  isCurated: Boolean;
  slug: String;
  popularity: Int;
}

export interface Restaurant extends Promise<RestaurantNode> {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  avgPricePerPerson: () => Promise<Int>;
  pictures: <T = Promise<Array<PictureNode>>>(
    args?: {
      where?: PictureWhereInput;
      orderBy?: PictureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  location: <T = Location>(
    args?: { where?: LocationWhereInput },
    fragment?: string | object
  ) => T;
  isCurated: () => Promise<Boolean>;
  slug: () => Promise<String>;
  popularity: () => Promise<Int>;
}

export interface RestaurantSubscription
  extends Promise<AsyncIterator<RestaurantNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  avgPricePerPerson: () => Promise<AsyncIterator<Int>>;
  pictures: <T = Promise<AsyncIterator<Array<PictureSubscription>>>>(
    args?: {
      where?: PictureWhereInput;
      orderBy?: PictureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  location: <T = LocationSubscription>(
    args?: { where?: LocationWhereInput },
    fragment?: string | object
  ) => T;
  isCurated: () => Promise<AsyncIterator<Boolean>>;
  slug: () => Promise<AsyncIterator<String>>;
  popularity: () => Promise<AsyncIterator<Int>>;
}

export interface AggregatePricingNode {
  count: Int;
}

export interface AggregatePricing extends Promise<AggregatePricingNode> {
  count: () => Promise<Int>;
}

export interface AggregatePricingSubscription
  extends Promise<AsyncIterator<AggregatePricingNode>> {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BookingSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface BookingSubscriptionPayload
  extends Promise<BookingSubscriptionPayloadNode> {
  mutation: () => Promise<MutationType>;
  node: <T = Booking>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BookingPreviousValues>() => T;
}

export interface BookingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BookingSubscriptionPayloadNode>> {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BookingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BookingPreviousValuesSubscription>() => T;
}

export interface UserNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost: Boolean;
}

export interface User extends Promise<UserNode> {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  responseRate: () => Promise<Float>;
  responseTime: () => Promise<Int>;
  isSuperHost: () => Promise<Boolean>;
  ownedPlaces: <T = Promise<Array<PlaceNode>>>(
    args?: {
      where?: PlaceWhereInput;
      orderBy?: PlaceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  location: <T = Location>(
    args?: { where?: LocationWhereInput },
    fragment?: string | object
  ) => T;
  bookings: <T = Promise<Array<BookingNode>>>(
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  paymentAccount: <T = Promise<Array<PaymentAccountNode>>>(
    args?: {
      where?: PaymentAccountWhereInput;
      orderBy?: PaymentAccountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  sentMessages: <T = Promise<Array<MessageNode>>>(
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  receivedMessages: <T = Promise<Array<MessageNode>>>(
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  notifications: <T = Promise<Array<NotificationNode>>>(
    args?: {
      where?: NotificationWhereInput;
      orderBy?: NotificationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  profilePicture: <T = Picture>(
    args?: { where?: PictureWhereInput },
    fragment?: string | object
  ) => T;
  hostingExperiences: <T = Promise<Array<ExperienceNode>>>(
    args?: {
      where?: ExperienceWhereInput;
      orderBy?: ExperienceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
}

export interface UserSubscription extends Promise<AsyncIterator<UserNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  responseRate: () => Promise<AsyncIterator<Float>>;
  responseTime: () => Promise<AsyncIterator<Int>>;
  isSuperHost: () => Promise<AsyncIterator<Boolean>>;
  ownedPlaces: <T = Promise<AsyncIterator<Array<PlaceSubscription>>>>(
    args?: {
      where?: PlaceWhereInput;
      orderBy?: PlaceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  location: <T = LocationSubscription>(
    args?: { where?: LocationWhereInput },
    fragment?: string | object
  ) => T;
  bookings: <T = Promise<AsyncIterator<Array<BookingSubscription>>>>(
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  paymentAccount: <
    T = Promise<AsyncIterator<Array<PaymentAccountSubscription>>>
  >(
    args?: {
      where?: PaymentAccountWhereInput;
      orderBy?: PaymentAccountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  sentMessages: <T = Promise<AsyncIterator<Array<MessageSubscription>>>>(
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  receivedMessages: <T = Promise<AsyncIterator<Array<MessageSubscription>>>>(
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  notifications: <T = Promise<AsyncIterator<Array<NotificationSubscription>>>>(
    args?: {
      where?: NotificationWhereInput;
      orderBy?: NotificationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  profilePicture: <T = PictureSubscription>(
    args?: { where?: PictureWhereInput },
    fragment?: string | object
  ) => T;
  hostingExperiences: <
    T = Promise<AsyncIterator<Array<ExperienceSubscription>>>
  >(
    args?: {
      where?: ExperienceWhereInput;
      orderBy?: ExperienceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
}

export interface BookingPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  startDate: DateTimeOutput;
  endDate: DateTimeOutput;
}

export interface BookingPreviousValues
  extends Promise<BookingPreviousValuesNode> {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
}

export interface BookingPreviousValuesSubscription
  extends Promise<AsyncIterator<BookingPreviousValuesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CreditCardInformationEdgeNode {
  cursor: String;
}

export interface CreditCardInformationEdge
  extends Promise<CreditCardInformationEdgeNode> {
  node: <T = CreditCardInformation>() => T;
  cursor: () => Promise<String>;
}

export interface CreditCardInformationEdgeSubscription
  extends Promise<AsyncIterator<CreditCardInformationEdgeNode>> {
  node: <T = CreditCardInformationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CityNode {
  id: ID_Output;
  name: String;
}

export interface City extends Promise<CityNode> {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  neighbourhoods: <T = Promise<Array<NeighbourhoodNode>>>(
    args?: {
      where?: NeighbourhoodWhereInput;
      orderBy?: NeighbourhoodOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
}

export interface CitySubscription extends Promise<AsyncIterator<CityNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  neighbourhoods: <
    T = Promise<AsyncIterator<Array<NeighbourhoodSubscription>>>
  >(
    args?: {
      where?: NeighbourhoodWhereInput;
      orderBy?: NeighbourhoodOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
}

export interface PaymentAccountEdgeNode {
  cursor: String;
}

export interface PaymentAccountEdge extends Promise<PaymentAccountEdgeNode> {
  node: <T = PaymentAccount>() => T;
  cursor: () => Promise<String>;
}

export interface PaymentAccountEdgeSubscription
  extends Promise<AsyncIterator<PaymentAccountEdgeNode>> {
  node: <T = PaymentAccountSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PaymentSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PaymentSubscriptionPayload
  extends Promise<PaymentSubscriptionPayloadNode> {
  mutation: () => Promise<MutationType>;
  node: <T = Payment>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PaymentPreviousValues>() => T;
}

export interface PaymentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PaymentSubscriptionPayloadNode>> {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PaymentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PaymentPreviousValuesSubscription>() => T;
}

export interface AggregateReviewNode {
  count: Int;
}

export interface AggregateReview extends Promise<AggregateReviewNode> {
  count: () => Promise<Int>;
}

export interface AggregateReviewSubscription
  extends Promise<AsyncIterator<AggregateReviewNode>> {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  serviceFee: Float;
  placePrice: Float;
  totalPrice: Float;
}

export interface PaymentPreviousValues
  extends Promise<PaymentPreviousValuesNode> {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  serviceFee: () => Promise<Float>;
  placePrice: () => Promise<Float>;
  totalPrice: () => Promise<Float>;
}

export interface PaymentPreviousValuesSubscription
  extends Promise<AsyncIterator<PaymentPreviousValuesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  serviceFee: () => Promise<AsyncIterator<Float>>;
  placePrice: () => Promise<AsyncIterator<Float>>;
  totalPrice: () => Promise<AsyncIterator<Float>>;
}

export interface ExperienceCategoryEdgeNode {
  cursor: String;
}

export interface ExperienceCategoryEdge
  extends Promise<ExperienceCategoryEdgeNode> {
  node: <T = ExperienceCategory>() => T;
  cursor: () => Promise<String>;
}

export interface ExperienceCategoryEdgeSubscription
  extends Promise<AsyncIterator<ExperienceCategoryEdgeNode>> {
  node: <T = ExperienceCategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PictureNode {
  id: ID_Output;
  url: String;
}

export interface Picture extends Promise<PictureNode> {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
}

export interface PictureSubscription
  extends Promise<AsyncIterator<PictureNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface PictureConnectionNode {}

export interface PictureConnection extends Promise<PictureConnectionNode> {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<PictureEdgeNode>>>() => T;
  aggregate: <T = AggregatePicture>() => T;
}

export interface PictureConnectionSubscription
  extends Promise<AsyncIterator<PictureConnectionNode>> {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<PictureEdgeSubscription>>>>() => T;
  aggregate: <T = AggregatePictureSubscription>() => T;
}

export interface PaymentAccountSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PaymentAccountSubscriptionPayload
  extends Promise<PaymentAccountSubscriptionPayloadNode> {
  mutation: () => Promise<MutationType>;
  node: <T = PaymentAccount>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PaymentAccountPreviousValues>() => T;
}

export interface PaymentAccountSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PaymentAccountSubscriptionPayloadNode>> {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PaymentAccountSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PaymentAccountPreviousValuesSubscription>() => T;
}

export interface LocationEdgeNode {
  cursor: String;
}

export interface LocationEdge extends Promise<LocationEdgeNode> {
  node: <T = Location>() => T;
  cursor: () => Promise<String>;
}

export interface LocationEdgeSubscription
  extends Promise<AsyncIterator<LocationEdgeNode>> {
  node: <T = LocationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PaymentAccountPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  type?: PAYMENT_PROVIDER;
}

export interface PaymentAccountPreviousValues
  extends Promise<PaymentAccountPreviousValuesNode> {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  type: () => Promise<PAYMENT_PROVIDER>;
}

export interface PaymentAccountPreviousValuesSubscription
  extends Promise<AsyncIterator<PaymentAccountPreviousValuesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<PAYMENT_PROVIDER>>;
}

export interface AggregatePoliciesNode {
  count: Int;
}

export interface AggregatePolicies extends Promise<AggregatePoliciesNode> {
  count: () => Promise<Int>;
}

export interface AggregatePoliciesSubscription
  extends Promise<AsyncIterator<AggregatePoliciesNode>> {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NeighbourhoodNode {
  id: ID_Output;
  name: String;
  slug: String;
  featured: Boolean;
  popularity: Int;
}

export interface Neighbourhood extends Promise<NeighbourhoodNode> {
  id: () => Promise<ID_Output>;
  locations: <T = Promise<Array<LocationNode>>>(
    args?: {
      where?: LocationWhereInput;
      orderBy?: LocationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  homePreview: <T = Picture>(
    args?: { where?: PictureWhereInput },
    fragment?: string | object
  ) => T;
  city: <T = City>(
    args?: { where?: CityWhereInput },
    fragment?: string | object
  ) => T;
  featured: () => Promise<Boolean>;
  popularity: () => Promise<Int>;
}

export interface NeighbourhoodSubscription
  extends Promise<AsyncIterator<NeighbourhoodNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  locations: <T = Promise<AsyncIterator<Array<LocationSubscription>>>>(
    args?: {
      where?: LocationWhereInput;
      orderBy?: LocationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
    fragment?: string | object
  ) => T;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  homePreview: <T = PictureSubscription>(
    args?: { where?: PictureWhereInput },
    fragment?: string | object
  ) => T;
  city: <T = CitySubscription>(
    args?: { where?: CityWhereInput },
    fragment?: string | object
  ) => T;
  featured: () => Promise<AsyncIterator<Boolean>>;
  popularity: () => Promise<AsyncIterator<Int>>;
}

export interface PricingConnectionNode {}

export interface PricingConnection extends Promise<PricingConnectionNode> {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<PricingEdgeNode>>>() => T;
  aggregate: <T = AggregatePricing>() => T;
}

export interface PricingConnectionSubscription
  extends Promise<AsyncIterator<PricingConnectionNode>> {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<PricingEdgeSubscription>>>>() => T;
  aggregate: <T = AggregatePricingSubscription>() => T;
}

export interface PaypalInformationSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PaypalInformationSubscriptionPayload
  extends Promise<PaypalInformationSubscriptionPayloadNode> {
  mutation: () => Promise<MutationType>;
  node: <T = PaypalInformation>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PaypalInformationPreviousValues>() => T;
}

export interface PaypalInformationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PaypalInformationSubscriptionPayloadNode>> {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PaypalInformationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PaypalInformationPreviousValuesSubscription>() => T;
}

export interface PaypalInformationEdgeNode {
  cursor: String;
}

export interface PaypalInformationEdge
  extends Promise<PaypalInformationEdgeNode> {
  node: <T = PaypalInformation>() => T;
  cursor: () => Promise<String>;
}

export interface PaypalInformationEdgeSubscription
  extends Promise<AsyncIterator<PaypalInformationEdgeNode>> {
  node: <T = PaypalInformationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PaypalInformationPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  email: String;
}

export interface PaypalInformationPreviousValues
  extends Promise<PaypalInformationPreviousValuesNode> {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
}

export interface PaypalInformationPreviousValuesSubscription
  extends Promise<AsyncIterator<PaypalInformationPreviousValuesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
}

export interface AmenitiesEdgeNode {
  cursor: String;
}

export interface AmenitiesEdge extends Promise<AmenitiesEdgeNode> {
  node: <T = Amenities>() => T;
  cursor: () => Promise<String>;
}

export interface AmenitiesEdgeSubscription
  extends Promise<AsyncIterator<AmenitiesEdgeNode>> {
  node: <T = AmenitiesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LocationNode {
  id: ID_Output;
  lat: Float;
  lng: Float;
  address?: String;
  directions?: String;
}

export interface Location extends Promise<LocationNode> {
  id: () => Promise<ID_Output>;
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
  neighbourHood: <T = Neighbourhood>(
    args?: { where?: NeighbourhoodWhereInput },
    fragment?: string | object
  ) => T;
  user: <T = User>(
    args?: { where?: UserWhereInput },
    fragment?: string | object
  ) => T;
  place: <T = Place>(
    args?: { where?: PlaceWhereInput },
    fragment?: string | object
  ) => T;
  address: () => Promise<String>;
  directions: () => Promise<String>;
  experience: <T = Experience>(
    args?: { where?: ExperienceWhereInput },
    fragment?: string | object
  ) => T;
  restaurant: <T = Restaurant>(
    args?: { where?: RestaurantWhereInput },
    fragment?: string | object
  ) => T;
}

export interface LocationSubscription
  extends Promise<AsyncIterator<LocationNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  lat: () => Promise<AsyncIterator<Float>>;
  lng: () => Promise<AsyncIterator<Float>>;
  neighbourHood: <T = NeighbourhoodSubscription>(
    args?: { where?: NeighbourhoodWhereInput },
    fragment?: string | object
  ) => T;
  user: <T = UserSubscription>(
    args?: { where?: UserWhereInput },
    fragment?: string | object
  ) => T;
  place: <T = PlaceSubscription>(
    args?: { where?: PlaceWhereInput },
    fragment?: string | object
  ) => T;
  address: () => Promise<AsyncIterator<String>>;
  directions: () => Promise<AsyncIterator<String>>;
  experience: <T = ExperienceSubscription>(
    args?: { where?: ExperienceWhereInput },
    fragment?: string | object
  ) => T;
  restaurant: <T = RestaurantSubscription>(
    args?: { where?: RestaurantWhereInput },
    fragment?: string | object
  ) => T;
}

export interface AggregateNeighbourhoodNode {
  count: Int;
}

export interface AggregateNeighbourhood
  extends Promise<AggregateNeighbourhoodNode> {
  count: () => Promise<Int>;
}

export interface AggregateNeighbourhoodSubscription
  extends Promise<AsyncIterator<AggregateNeighbourhoodNode>> {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GuestRequirementsEdgeNode {
  cursor: String;
}

export interface GuestRequirementsEdge
  extends Promise<GuestRequirementsEdgeNode> {
  node: <T = GuestRequirements>() => T;
  cursor: () => Promise<String>;
}

export interface GuestRequirementsEdgeSubscription
  extends Promise<AsyncIterator<GuestRequirementsEdgeNode>> {
  node: <T = GuestRequirementsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MessageSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface MessageSubscriptionPayload
  extends Promise<MessageSubscriptionPayloadNode> {
  mutation: () => Promise<MutationType>;
  node: <T = Message>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MessagePreviousValues>() => T;
}

export interface MessageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MessageSubscriptionPayloadNode>> {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MessageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MessagePreviousValuesSubscription>() => T;
}

export interface ExperienceCategoryNode {
  id: ID_Output;
  mainColor: String;
  name: String;
}

export interface ExperienceCategory extends Promise<ExperienceCategoryNode> {
  id: () => Promise<ID_Output>;
  mainColor: () => Promise<String>;
  name: () => Promise<String>;
  experience: <T = Experience>(
    args?: { where?: ExperienceWhereInput },
    fragment?: string | object
  ) => T;
}

export interface ExperienceCategorySubscription
  extends Promise<AsyncIterator<ExperienceCategoryNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  mainColor: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  experience: <T = ExperienceSubscription>(
    args?: { where?: ExperienceWhereInput },
    fragment?: string | object
  ) => T;
}

export interface CreditCardInformationPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  cardNumber: String;
  expiresOnMonth: Int;
  expiresOnYear: Int;
  securityCode: String;
  firstName: String;
  lastName: String;
  postalCode: String;
  country: String;
}

export interface CreditCardInformationPreviousValues
  extends Promise<CreditCardInformationPreviousValuesNode> {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  cardNumber: () => Promise<String>;
  expiresOnMonth: () => Promise<Int>;
  expiresOnYear: () => Promise<Int>;
  securityCode: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  postalCode: () => Promise<String>;
  country: () => Promise<String>;
}

export interface CreditCardInformationPreviousValuesSubscription
  extends Promise<AsyncIterator<CreditCardInformationPreviousValuesNode>> {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  cardNumber: () => Promise<AsyncIterator<String>>;
  expiresOnMonth: () => Promise<AsyncIterator<Int>>;
  expiresOnYear: () => Promise<AsyncIterator<Int>>;
  securityCode: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  postalCode: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
}

export interface CreditCardInformationSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface CreditCardInformationSubscriptionPayload
  extends Promise<CreditCardInformationSubscriptionPayloadNode> {
  mutation: () => Promise<MutationType>;
  node: <T = CreditCardInformation>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CreditCardInformationPreviousValues>() => T;
}

export interface CreditCardInformationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CreditCardInformationSubscriptionPayloadNode>> {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CreditCardInformationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CreditCardInformationPreviousValuesSubscription>() => T;
}

export interface AggregateMessageNode {
  count: Int;
}

export interface AggregateMessage extends Promise<AggregateMessageNode> {
  count: () => Promise<Int>;
}

export interface AggregateMessageSubscription
  extends Promise<AsyncIterator<AggregateMessageNode>> {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ViewsConnectionNode {}

export interface ViewsConnection extends Promise<ViewsConnectionNode> {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<ViewsEdgeNode>>>() => T;
  aggregate: <T = AggregateViews>() => T;
}

export interface ViewsConnectionSubscription
  extends Promise<AsyncIterator<ViewsConnectionNode>> {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<ViewsEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateViewsSubscription>() => T;
}

export interface ExperienceEdgeNode {
  cursor: String;
}

export interface ExperienceEdge extends Promise<ExperienceEdgeNode> {
  node: <T = Experience>() => T;
  cursor: () => Promise<String>;
}

export interface ExperienceEdgeSubscription
  extends Promise<AsyncIterator<ExperienceEdgeNode>> {
  node: <T = ExperienceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PaymentConnectionNode {}

export interface PaymentConnection extends Promise<PaymentConnectionNode> {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<PaymentEdgeNode>>>() => T;
  aggregate: <T = AggregatePayment>() => T;
}

export interface PaymentConnectionSubscription
  extends Promise<AsyncIterator<PaymentConnectionNode>> {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<PaymentEdgeSubscription>>>>() => T;
  aggregate: <T = AggregatePaymentSubscription>() => T;
}

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Type Defs
 */

export const Prisma = makePrismaBindingClass<BindingConstructor<Prisma>>({
  typeDefs,
  endpoint: process.env["PRISMA_ENDPOINT"],
  secret: process.env["PRISMA_SECRET"]
});
export const prisma = new Prisma();
